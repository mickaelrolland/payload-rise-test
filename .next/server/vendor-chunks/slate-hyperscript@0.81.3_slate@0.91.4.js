"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate-hyperscript@0.81.3_slate@0.91.4";
exports.ids = ["vendor-chunks/slate-hyperscript@0.81.3_slate@0.91.4"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/slate-hyperscript@0.81.3_slate@0.91.4/node_modules/slate-hyperscript/dist/index.es.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/.pnpm/slate-hyperscript@0.81.3_slate@0.91.4/node_modules/slate-hyperscript/dist/index.es.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   createEditor: () => (/* binding */ createEditor),\n/* harmony export */   createHyperscript: () => (/* binding */ createHyperscript),\n/* harmony export */   createText: () => (/* binding */ createText),\n/* harmony export */   jsx: () => (/* binding */ jsx)\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var slate__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! slate */ \"(ssr)/./node_modules/.pnpm/slate@0.91.4/node_modules/slate/dist/index.es.js\");\n\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\n/**\r\n * A weak map to hold anchor tokens.\r\n */\nvar ANCHOR = new WeakMap();\n/**\r\n * A weak map to hold focus tokens.\r\n */\n\nvar FOCUS = new WeakMap();\n/**\r\n * All tokens inherit from a single constructor for `instanceof` checking.\r\n */\n\nclass Token {}\n/**\r\n * Anchor tokens represent the selection's anchor point.\r\n */\n\nclass AnchorToken extends Token {\n  constructor() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    var {\n      offset,\n      path\n    } = props;\n    this.offset = offset;\n    this.path = path;\n  }\n\n}\n/**\r\n * Focus tokens represent the selection's focus point.\r\n */\n\nclass FocusToken extends Token {\n  constructor() {\n    var props = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    var {\n      offset,\n      path\n    } = props;\n    this.offset = offset;\n    this.path = path;\n  }\n\n}\n/**\r\n * Add an anchor token to the end of a text node.\r\n */\n\nvar addAnchorToken = (text, token) => {\n  var offset = text.text.length;\n  ANCHOR.set(text, [offset, token]);\n};\n/**\r\n * Get the offset if a text node has an associated anchor token.\r\n */\n\nvar getAnchorOffset = text => {\n  return ANCHOR.get(text);\n};\n/**\r\n * Add a focus token to the end of a text node.\r\n */\n\nvar addFocusToken = (text, token) => {\n  var offset = text.text.length;\n  FOCUS.set(text, [offset, token]);\n};\n/**\r\n * Get the offset if a text node has an associated focus token.\r\n */\n\nvar getFocusOffset = text => {\n  return FOCUS.get(text);\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n/**\r\n * Resolve the descedants of a node by normalizing the children that can be\r\n * passed into a hyperscript creator function.\r\n */\n\nvar STRINGS = new WeakSet();\n\nvar resolveDescendants = children => {\n  var nodes = [];\n\n  var addChild = child => {\n    if (child == null) {\n      return;\n    }\n\n    var prev = nodes[nodes.length - 1];\n\n    if (typeof child === 'string') {\n      var text = {\n        text: child\n      };\n      STRINGS.add(text);\n      child = text;\n    }\n\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(child)) {\n      var c = child; // HACK: fix typescript complaining\n\n      if (slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(prev) && STRINGS.has(prev) && STRINGS.has(c) && slate__WEBPACK_IMPORTED_MODULE_1__.Text.equals(prev, c, {\n        loose: true\n      })) {\n        prev.text += c.text;\n      } else {\n        nodes.push(c);\n      }\n    } else if (slate__WEBPACK_IMPORTED_MODULE_1__.Element.isElement(child)) {\n      nodes.push(child);\n    } else if (child instanceof Token) {\n      var n = nodes[nodes.length - 1];\n\n      if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(n)) {\n        addChild('');\n        n = nodes[nodes.length - 1];\n      }\n\n      if (child instanceof AnchorToken) {\n        addAnchorToken(n, child);\n      } else if (child instanceof FocusToken) {\n        addFocusToken(n, child);\n      }\n    } else {\n      throw new Error(\"Unexpected hyperscript child object: \".concat(child));\n    }\n  };\n\n  for (var child of children.flat(Infinity)) {\n    addChild(child);\n  }\n\n  return nodes;\n};\n/**\r\n * Create an anchor token.\r\n */\n\n\nfunction createAnchor(tagName, attributes, children) {\n  return new AnchorToken(attributes);\n}\n/**\r\n * Create an anchor and a focus token.\r\n */\n\nfunction createCursor(tagName, attributes, children) {\n  return [new AnchorToken(attributes), new FocusToken(attributes)];\n}\n/**\r\n * Create an `Element` object.\r\n */\n\nfunction createElement(tagName, attributes, children) {\n  return _objectSpread$1(_objectSpread$1({}, attributes), {}, {\n    children: resolveDescendants(children)\n  });\n}\n/**\r\n * Create a focus token.\r\n */\n\nfunction createFocus(tagName, attributes, children) {\n  return new FocusToken(attributes);\n}\n/**\r\n * Create a fragment.\r\n */\n\nfunction createFragment(tagName, attributes, children) {\n  return resolveDescendants(children);\n}\n/**\r\n * Create a `Selection` object.\r\n */\n\nfunction createSelection(tagName, attributes, children) {\n  var anchor = children.find(c => c instanceof AnchorToken);\n  var focus = children.find(c => c instanceof FocusToken);\n\n  if (!anchor || anchor.offset == null || anchor.path == null) {\n    throw new Error(\"The <selection> hyperscript tag must have an <anchor> tag as a child with `path` and `offset` attributes defined.\");\n  }\n\n  if (!focus || focus.offset == null || focus.path == null) {\n    throw new Error(\"The <selection> hyperscript tag must have a <focus> tag as a child with `path` and `offset` attributes defined.\");\n  }\n\n  return _objectSpread$1({\n    anchor: {\n      offset: anchor.offset,\n      path: anchor.path\n    },\n    focus: {\n      offset: focus.offset,\n      path: focus.path\n    }\n  }, attributes);\n}\n/**\r\n * Create a `Text` object.\r\n */\n\nfunction createText(tagName, attributes, children) {\n  var nodes = resolveDescendants(children);\n\n  if (nodes.length > 1) {\n    throw new Error(\"The <text> hyperscript tag must only contain a single node's worth of children.\");\n  }\n\n  var [node] = nodes;\n\n  if (node == null) {\n    node = {\n      text: ''\n    };\n  }\n\n  if (!slate__WEBPACK_IMPORTED_MODULE_1__.Text.isText(node)) {\n    throw new Error(\"\\n    The <text> hyperscript tag can only contain text content as children.\");\n  } // COMPAT: If they used the <text> tag we want to guarantee that it won't be\n  // merge with other string children.\n\n\n  STRINGS.delete(node);\n  Object.assign(node, attributes);\n  return node;\n}\n/**\r\n * Create a top-level `Editor` object.\r\n */\n\nvar createEditor = makeEditor => (tagName, attributes, children) => {\n  var otherChildren = [];\n  var selectionChild;\n\n  for (var child of children) {\n    if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isRange(child)) {\n      selectionChild = child;\n    } else {\n      otherChildren.push(child);\n    }\n  }\n\n  var descendants = resolveDescendants(otherChildren);\n  var selection = {};\n  var editor = makeEditor();\n  Object.assign(editor, attributes);\n  editor.children = descendants; // Search the document's texts to see if any of them have tokens associated\n  // that need incorporated into the selection.\n\n  for (var [node, path] of slate__WEBPACK_IMPORTED_MODULE_1__.Node.texts(editor)) {\n    var anchor = getAnchorOffset(node);\n    var focus = getFocusOffset(node);\n\n    if (anchor != null) {\n      var [offset] = anchor;\n      selection.anchor = {\n        path,\n        offset\n      };\n    }\n\n    if (focus != null) {\n      var [_offset] = focus;\n      selection.focus = {\n        path,\n        offset: _offset\n      };\n    }\n  }\n\n  if (selection.anchor && !selection.focus) {\n    throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<anchor />`. For collapsed selections, use `<cursor />` instead.\");\n  }\n\n  if (!selection.anchor && selection.focus) {\n    throw new Error(\"Slate hyperscript ranges must have both `<anchor />` and `<focus />` defined if one is defined, but you only defined `<focus />`. For collapsed selections, use `<cursor />` instead.\");\n  }\n\n  if (selectionChild != null) {\n    editor.selection = selectionChild;\n  } else if (slate__WEBPACK_IMPORTED_MODULE_1__.Range.isRange(selection)) {\n    editor.selection = selection;\n  }\n\n  return editor;\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n/**\r\n * The default creators for Slate objects.\r\n */\n\nvar DEFAULT_CREATORS = {\n  anchor: createAnchor,\n  cursor: createCursor,\n  editor: createEditor(slate__WEBPACK_IMPORTED_MODULE_1__.createEditor),\n  element: createElement,\n  focus: createFocus,\n  fragment: createFragment,\n  selection: createSelection,\n  text: createText\n};\n/**\r\n * Create a Slate hyperscript function with `options`.\r\n */\n\nvar createHyperscript = function createHyperscript() {\n  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n  var {\n    elements = {}\n  } = options;\n  var elementCreators = normalizeElements(elements);\n\n  var creators = _objectSpread(_objectSpread(_objectSpread({}, DEFAULT_CREATORS), elementCreators), options.creators);\n\n  var jsx = createFactory(creators);\n  return jsx;\n};\n/**\r\n * Create a Slate hyperscript function with `options`.\r\n */\n\n\nvar createFactory = creators => {\n  var jsx = function jsx(tagName, attributes) {\n    for (var _len = arguments.length, children = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      children[_key - 2] = arguments[_key];\n    }\n\n    var creator = creators[tagName];\n\n    if (!creator) {\n      throw new Error(\"No hyperscript creator found for tag: <\".concat(tagName, \">\"));\n    }\n\n    if (attributes == null) {\n      attributes = {};\n    }\n\n    if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(attributes)) {\n      children = [attributes].concat(children);\n      attributes = {};\n    }\n\n    children = children.filter(child => Boolean(child)).flat();\n    var ret = creator(tagName, attributes, children);\n    return ret;\n  };\n\n  return jsx;\n};\n/**\r\n * Normalize a dictionary of element shorthands into creator functions.\r\n */\n\n\nvar normalizeElements = elements => {\n  var creators = {};\n\n  var _loop = function _loop(tagName) {\n    var props = elements[tagName];\n\n    if (typeof props !== 'object') {\n      throw new Error(\"Properties specified for a hyperscript shorthand should be an object, but for the custom element <\".concat(tagName, \">  tag you passed: \").concat(props));\n    }\n\n    creators[tagName] = (tagName, attributes, children) => {\n      return createElement('element', _objectSpread(_objectSpread({}, props), attributes), children);\n    };\n  };\n\n  for (var tagName in elements) {\n    _loop(tagName);\n  }\n\n  return creators;\n};\n\n/**\r\n * The default hyperscript factory that ships with Slate, without custom tags.\r\n */\n\nvar jsx = createHyperscript();\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc2xhdGUtaHlwZXJzY3JpcHRAMC44MS4zX3NsYXRlQDAuOTEuNC9ub2RlX21vZHVsZXMvc2xhdGUtaHlwZXJzY3JpcHQvZGlzdC9pbmRleC5lcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0Q7QUFDbUM7O0FBRW5GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFN1UsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSx5REFBeUQsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLG1EQUFtRCxtRkFBbUYsT0FBTztBQUM1Z0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLHVDQUFJO0FBQ1oscUJBQXFCOztBQUVyQixVQUFVLHVDQUFJLHdEQUF3RCx1Q0FBSTtBQUMxRTtBQUNBLE9BQU87QUFDUDtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTSxTQUFTLDBDQUFPO0FBQ3RCO0FBQ0EsTUFBTTtBQUNOOztBQUVBLFdBQVcsdUNBQUk7QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxpQkFBaUI7QUFDNUQ7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU8sdUNBQUk7QUFDWDtBQUNBLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUSx3Q0FBSztBQUNiO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQzs7QUFFQSwyQkFBMkIsdUNBQUk7QUFDL0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUksU0FBUyx3Q0FBSztBQUNsQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMkNBQTJDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELHNCQUFzQiwwQ0FBMEMsaUVBQWlFLEtBQUssa0NBQWtDOztBQUUzVSxpQ0FBaUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHVEQUF1RCw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8saURBQWlELG1GQUFtRixPQUFPO0FBQ3RnQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLCtDQUFjO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBLCtGQUErRixhQUFhO0FBQzVHO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDhEQUFhO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0VBQW9FO0FBQ3BFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUU0RDtBQUM1RCIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2thZWwvRG9jdW1lbnRzL2dhbGFkcmltL3Jpc2UvY21zX3Jlc2VhcmNoL3BheWxvYWQvcmlzZS9ub2RlX21vZHVsZXMvLnBucG0vc2xhdGUtaHlwZXJzY3JpcHRAMC44MS4zX3NsYXRlQDAuOTEuNC9ub2RlX21vZHVsZXMvc2xhdGUtaHlwZXJzY3JpcHQvZGlzdC9pbmRleC5lcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBpc1BsYWluT2JqZWN0IH0gZnJvbSAnaXMtcGxhaW4tb2JqZWN0JztcbmltcG9ydCB7IFRleHQsIFJhbmdlLCBOb2RlLCBFbGVtZW50LCBjcmVhdGVFZGl0b3IgYXMgY3JlYXRlRWRpdG9yJDEgfSBmcm9tICdzbGF0ZSc7XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgaWYgKGtleSBpbiBvYmopIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICB3cml0YWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIG9ialtrZXldID0gdmFsdWU7XG4gIH1cblxuICByZXR1cm4gb2JqO1xufVxuXG4vKipcclxuICogQSB3ZWFrIG1hcCB0byBob2xkIGFuY2hvciB0b2tlbnMuXHJcbiAqL1xudmFyIEFOQ0hPUiA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogQSB3ZWFrIG1hcCB0byBob2xkIGZvY3VzIHRva2Vucy5cclxuICovXG5cbnZhciBGT0NVUyA9IG5ldyBXZWFrTWFwKCk7XG4vKipcclxuICogQWxsIHRva2VucyBpbmhlcml0IGZyb20gYSBzaW5nbGUgY29uc3RydWN0b3IgZm9yIGBpbnN0YW5jZW9mYCBjaGVja2luZy5cclxuICovXG5cbmNsYXNzIFRva2VuIHt9XG4vKipcclxuICogQW5jaG9yIHRva2VucyByZXByZXNlbnQgdGhlIHNlbGVjdGlvbidzIGFuY2hvciBwb2ludC5cclxuICovXG5cbmNsYXNzIEFuY2hvclRva2VuIGV4dGVuZHMgVG9rZW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdmFyIHtcbiAgICAgIG9mZnNldCxcbiAgICAgIHBhdGhcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxuXG59XG4vKipcclxuICogRm9jdXMgdG9rZW5zIHJlcHJlc2VudCB0aGUgc2VsZWN0aW9uJ3MgZm9jdXMgcG9pbnQuXHJcbiAqL1xuXG5jbGFzcyBGb2N1c1Rva2VuIGV4dGVuZHMgVG9rZW4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB2YXIgcHJvcHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdmFyIHtcbiAgICAgIG9mZnNldCxcbiAgICAgIHBhdGhcbiAgICB9ID0gcHJvcHM7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgfVxuXG59XG4vKipcclxuICogQWRkIGFuIGFuY2hvciB0b2tlbiB0byB0aGUgZW5kIG9mIGEgdGV4dCBub2RlLlxyXG4gKi9cblxudmFyIGFkZEFuY2hvclRva2VuID0gKHRleHQsIHRva2VuKSA9PiB7XG4gIHZhciBvZmZzZXQgPSB0ZXh0LnRleHQubGVuZ3RoO1xuICBBTkNIT1Iuc2V0KHRleHQsIFtvZmZzZXQsIHRva2VuXSk7XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgb2Zmc2V0IGlmIGEgdGV4dCBub2RlIGhhcyBhbiBhc3NvY2lhdGVkIGFuY2hvciB0b2tlbi5cclxuICovXG5cbnZhciBnZXRBbmNob3JPZmZzZXQgPSB0ZXh0ID0+IHtcbiAgcmV0dXJuIEFOQ0hPUi5nZXQodGV4dCk7XG59O1xuLyoqXHJcbiAqIEFkZCBhIGZvY3VzIHRva2VuIHRvIHRoZSBlbmQgb2YgYSB0ZXh0IG5vZGUuXHJcbiAqL1xuXG52YXIgYWRkRm9jdXNUb2tlbiA9ICh0ZXh0LCB0b2tlbikgPT4ge1xuICB2YXIgb2Zmc2V0ID0gdGV4dC50ZXh0Lmxlbmd0aDtcbiAgRk9DVVMuc2V0KHRleHQsIFtvZmZzZXQsIHRva2VuXSk7XG59O1xuLyoqXHJcbiAqIEdldCB0aGUgb2Zmc2V0IGlmIGEgdGV4dCBub2RlIGhhcyBhbiBhc3NvY2lhdGVkIGZvY3VzIHRva2VuLlxyXG4gKi9cblxudmFyIGdldEZvY3VzT2Zmc2V0ID0gdGV4dCA9PiB7XG4gIHJldHVybiBGT0NVUy5nZXQodGV4dCk7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzJDEob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDEodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMShPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cbi8qKlxyXG4gKiBSZXNvbHZlIHRoZSBkZXNjZWRhbnRzIG9mIGEgbm9kZSBieSBub3JtYWxpemluZyB0aGUgY2hpbGRyZW4gdGhhdCBjYW4gYmVcclxuICogcGFzc2VkIGludG8gYSBoeXBlcnNjcmlwdCBjcmVhdG9yIGZ1bmN0aW9uLlxyXG4gKi9cblxudmFyIFNUUklOR1MgPSBuZXcgV2Vha1NldCgpO1xuXG52YXIgcmVzb2x2ZURlc2NlbmRhbnRzID0gY2hpbGRyZW4gPT4ge1xuICB2YXIgbm9kZXMgPSBbXTtcblxuICB2YXIgYWRkQ2hpbGQgPSBjaGlsZCA9PiB7XG4gICAgaWYgKGNoaWxkID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcHJldiA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHZhciB0ZXh0ID0ge1xuICAgICAgICB0ZXh0OiBjaGlsZFxuICAgICAgfTtcbiAgICAgIFNUUklOR1MuYWRkKHRleHQpO1xuICAgICAgY2hpbGQgPSB0ZXh0O1xuICAgIH1cblxuICAgIGlmIChUZXh0LmlzVGV4dChjaGlsZCkpIHtcbiAgICAgIHZhciBjID0gY2hpbGQ7IC8vIEhBQ0s6IGZpeCB0eXBlc2NyaXB0IGNvbXBsYWluaW5nXG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChwcmV2KSAmJiBTVFJJTkdTLmhhcyhwcmV2KSAmJiBTVFJJTkdTLmhhcyhjKSAmJiBUZXh0LmVxdWFscyhwcmV2LCBjLCB7XG4gICAgICAgIGxvb3NlOiB0cnVlXG4gICAgICB9KSkge1xuICAgICAgICBwcmV2LnRleHQgKz0gYy50ZXh0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbm9kZXMucHVzaChjKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KGNoaWxkKSkge1xuICAgICAgbm9kZXMucHVzaChjaGlsZCk7XG4gICAgfSBlbHNlIGlmIChjaGlsZCBpbnN0YW5jZW9mIFRva2VuKSB7XG4gICAgICB2YXIgbiA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG4pKSB7XG4gICAgICAgIGFkZENoaWxkKCcnKTtcbiAgICAgICAgbiA9IG5vZGVzW25vZGVzLmxlbmd0aCAtIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY2hpbGQgaW5zdGFuY2VvZiBBbmNob3JUb2tlbikge1xuICAgICAgICBhZGRBbmNob3JUb2tlbihuLCBjaGlsZCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkIGluc3RhbmNlb2YgRm9jdXNUb2tlbikge1xuICAgICAgICBhZGRGb2N1c1Rva2VuKG4sIGNoaWxkKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBoeXBlcnNjcmlwdCBjaGlsZCBvYmplY3Q6IFwiLmNvbmNhdChjaGlsZCkpO1xuICAgIH1cbiAgfTtcblxuICBmb3IgKHZhciBjaGlsZCBvZiBjaGlsZHJlbi5mbGF0KEluZmluaXR5KSkge1xuICAgIGFkZENoaWxkKGNoaWxkKTtcbiAgfVxuXG4gIHJldHVybiBub2Rlcztcbn07XG4vKipcclxuICogQ3JlYXRlIGFuIGFuY2hvciB0b2tlbi5cclxuICovXG5cblxuZnVuY3Rpb24gY3JlYXRlQW5jaG9yKHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSB7XG4gIHJldHVybiBuZXcgQW5jaG9yVG9rZW4oYXR0cmlidXRlcyk7XG59XG4vKipcclxuICogQ3JlYXRlIGFuIGFuY2hvciBhbmQgYSBmb2N1cyB0b2tlbi5cclxuICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUN1cnNvcih0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICByZXR1cm4gW25ldyBBbmNob3JUb2tlbihhdHRyaWJ1dGVzKSwgbmV3IEZvY3VzVG9rZW4oYXR0cmlidXRlcyldO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhbiBgRWxlbWVudGAgb2JqZWN0LlxyXG4gKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICByZXR1cm4gX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgYXR0cmlidXRlcyksIHt9LCB7XG4gICAgY2hpbGRyZW46IHJlc29sdmVEZXNjZW5kYW50cyhjaGlsZHJlbilcbiAgfSk7XG59XG4vKipcclxuICogQ3JlYXRlIGEgZm9jdXMgdG9rZW4uXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGb2N1cyh0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICByZXR1cm4gbmV3IEZvY3VzVG9rZW4oYXR0cmlidXRlcyk7XG59XG4vKipcclxuICogQ3JlYXRlIGEgZnJhZ21lbnQuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVGcmFnbWVudCh0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbikge1xuICByZXR1cm4gcmVzb2x2ZURlc2NlbmRhbnRzKGNoaWxkcmVuKTtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSBgU2VsZWN0aW9uYCBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVTZWxlY3Rpb24odGFnTmFtZSwgYXR0cmlidXRlcywgY2hpbGRyZW4pIHtcbiAgdmFyIGFuY2hvciA9IGNoaWxkcmVuLmZpbmQoYyA9PiBjIGluc3RhbmNlb2YgQW5jaG9yVG9rZW4pO1xuICB2YXIgZm9jdXMgPSBjaGlsZHJlbi5maW5kKGMgPT4gYyBpbnN0YW5jZW9mIEZvY3VzVG9rZW4pO1xuXG4gIGlmICghYW5jaG9yIHx8IGFuY2hvci5vZmZzZXQgPT0gbnVsbCB8fCBhbmNob3IucGF0aCA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIDxzZWxlY3Rpb24+IGh5cGVyc2NyaXB0IHRhZyBtdXN0IGhhdmUgYW4gPGFuY2hvcj4gdGFnIGFzIGEgY2hpbGQgd2l0aCBgcGF0aGAgYW5kIGBvZmZzZXRgIGF0dHJpYnV0ZXMgZGVmaW5lZC5cIik7XG4gIH1cblxuICBpZiAoIWZvY3VzIHx8IGZvY3VzLm9mZnNldCA9PSBudWxsIHx8IGZvY3VzLnBhdGggPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSA8c2VsZWN0aW9uPiBoeXBlcnNjcmlwdCB0YWcgbXVzdCBoYXZlIGEgPGZvY3VzPiB0YWcgYXMgYSBjaGlsZCB3aXRoIGBwYXRoYCBhbmQgYG9mZnNldGAgYXR0cmlidXRlcyBkZWZpbmVkLlwiKTtcbiAgfVxuXG4gIHJldHVybiBfb2JqZWN0U3ByZWFkJDEoe1xuICAgIGFuY2hvcjoge1xuICAgICAgb2Zmc2V0OiBhbmNob3Iub2Zmc2V0LFxuICAgICAgcGF0aDogYW5jaG9yLnBhdGhcbiAgICB9LFxuICAgIGZvY3VzOiB7XG4gICAgICBvZmZzZXQ6IGZvY3VzLm9mZnNldCxcbiAgICAgIHBhdGg6IGZvY3VzLnBhdGhcbiAgICB9XG4gIH0sIGF0dHJpYnV0ZXMpO1xufVxuLyoqXHJcbiAqIENyZWF0ZSBhIGBUZXh0YCBvYmplY3QuXHJcbiAqL1xuXG5mdW5jdGlvbiBjcmVhdGVUZXh0KHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSB7XG4gIHZhciBub2RlcyA9IHJlc29sdmVEZXNjZW5kYW50cyhjaGlsZHJlbik7XG5cbiAgaWYgKG5vZGVzLmxlbmd0aCA+IDEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgPHRleHQ+IGh5cGVyc2NyaXB0IHRhZyBtdXN0IG9ubHkgY29udGFpbiBhIHNpbmdsZSBub2RlJ3Mgd29ydGggb2YgY2hpbGRyZW4uXCIpO1xuICB9XG5cbiAgdmFyIFtub2RlXSA9IG5vZGVzO1xuXG4gIGlmIChub2RlID09IG51bGwpIHtcbiAgICBub2RlID0ge1xuICAgICAgdGV4dDogJydcbiAgICB9O1xuICB9XG5cbiAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICBUaGUgPHRleHQ+IGh5cGVyc2NyaXB0IHRhZyBjYW4gb25seSBjb250YWluIHRleHQgY29udGVudCBhcyBjaGlsZHJlbi5cIik7XG4gIH0gLy8gQ09NUEFUOiBJZiB0aGV5IHVzZWQgdGhlIDx0ZXh0PiB0YWcgd2Ugd2FudCB0byBndWFyYW50ZWUgdGhhdCBpdCB3b24ndCBiZVxuICAvLyBtZXJnZSB3aXRoIG90aGVyIHN0cmluZyBjaGlsZHJlbi5cblxuXG4gIFNUUklOR1MuZGVsZXRlKG5vZGUpO1xuICBPYmplY3QuYXNzaWduKG5vZGUsIGF0dHJpYnV0ZXMpO1xuICByZXR1cm4gbm9kZTtcbn1cbi8qKlxyXG4gKiBDcmVhdGUgYSB0b3AtbGV2ZWwgYEVkaXRvcmAgb2JqZWN0LlxyXG4gKi9cblxudmFyIGNyZWF0ZUVkaXRvciA9IG1ha2VFZGl0b3IgPT4gKHRhZ05hbWUsIGF0dHJpYnV0ZXMsIGNoaWxkcmVuKSA9PiB7XG4gIHZhciBvdGhlckNoaWxkcmVuID0gW107XG4gIHZhciBzZWxlY3Rpb25DaGlsZDtcblxuICBmb3IgKHZhciBjaGlsZCBvZiBjaGlsZHJlbikge1xuICAgIGlmIChSYW5nZS5pc1JhbmdlKGNoaWxkKSkge1xuICAgICAgc2VsZWN0aW9uQ2hpbGQgPSBjaGlsZDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3RoZXJDaGlsZHJlbi5wdXNoKGNoaWxkKTtcbiAgICB9XG4gIH1cblxuICB2YXIgZGVzY2VuZGFudHMgPSByZXNvbHZlRGVzY2VuZGFudHMob3RoZXJDaGlsZHJlbik7XG4gIHZhciBzZWxlY3Rpb24gPSB7fTtcbiAgdmFyIGVkaXRvciA9IG1ha2VFZGl0b3IoKTtcbiAgT2JqZWN0LmFzc2lnbihlZGl0b3IsIGF0dHJpYnV0ZXMpO1xuICBlZGl0b3IuY2hpbGRyZW4gPSBkZXNjZW5kYW50czsgLy8gU2VhcmNoIHRoZSBkb2N1bWVudCdzIHRleHRzIHRvIHNlZSBpZiBhbnkgb2YgdGhlbSBoYXZlIHRva2VucyBhc3NvY2lhdGVkXG4gIC8vIHRoYXQgbmVlZCBpbmNvcnBvcmF0ZWQgaW50byB0aGUgc2VsZWN0aW9uLlxuXG4gIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBOb2RlLnRleHRzKGVkaXRvcikpIHtcbiAgICB2YXIgYW5jaG9yID0gZ2V0QW5jaG9yT2Zmc2V0KG5vZGUpO1xuICAgIHZhciBmb2N1cyA9IGdldEZvY3VzT2Zmc2V0KG5vZGUpO1xuXG4gICAgaWYgKGFuY2hvciAhPSBudWxsKSB7XG4gICAgICB2YXIgW29mZnNldF0gPSBhbmNob3I7XG4gICAgICBzZWxlY3Rpb24uYW5jaG9yID0ge1xuICAgICAgICBwYXRoLFxuICAgICAgICBvZmZzZXRcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKGZvY3VzICE9IG51bGwpIHtcbiAgICAgIHZhciBbX29mZnNldF0gPSBmb2N1cztcbiAgICAgIHNlbGVjdGlvbi5mb2N1cyA9IHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0XG4gICAgICB9O1xuICAgIH1cbiAgfVxuXG4gIGlmIChzZWxlY3Rpb24uYW5jaG9yICYmICFzZWxlY3Rpb24uZm9jdXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGF0ZSBoeXBlcnNjcmlwdCByYW5nZXMgbXVzdCBoYXZlIGJvdGggYDxhbmNob3IgLz5gIGFuZCBgPGZvY3VzIC8+YCBkZWZpbmVkIGlmIG9uZSBpcyBkZWZpbmVkLCBidXQgeW91IG9ubHkgZGVmaW5lZCBgPGFuY2hvciAvPmAuIEZvciBjb2xsYXBzZWQgc2VsZWN0aW9ucywgdXNlIGA8Y3Vyc29yIC8+YCBpbnN0ZWFkLlwiKTtcbiAgfVxuXG4gIGlmICghc2VsZWN0aW9uLmFuY2hvciAmJiBzZWxlY3Rpb24uZm9jdXMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJTbGF0ZSBoeXBlcnNjcmlwdCByYW5nZXMgbXVzdCBoYXZlIGJvdGggYDxhbmNob3IgLz5gIGFuZCBgPGZvY3VzIC8+YCBkZWZpbmVkIGlmIG9uZSBpcyBkZWZpbmVkLCBidXQgeW91IG9ubHkgZGVmaW5lZCBgPGZvY3VzIC8+YC4gRm9yIGNvbGxhcHNlZCBzZWxlY3Rpb25zLCB1c2UgYDxjdXJzb3IgLz5gIGluc3RlYWQuXCIpO1xuICB9XG5cbiAgaWYgKHNlbGVjdGlvbkNoaWxkICE9IG51bGwpIHtcbiAgICBlZGl0b3Iuc2VsZWN0aW9uID0gc2VsZWN0aW9uQ2hpbGQ7XG4gIH0gZWxzZSBpZiAoUmFuZ2UuaXNSYW5nZShzZWxlY3Rpb24pKSB7XG4gICAgZWRpdG9yLnNlbGVjdGlvbiA9IHNlbGVjdGlvbjtcbiAgfVxuXG4gIHJldHVybiBlZGl0b3I7XG59O1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcclxuICogVGhlIGRlZmF1bHQgY3JlYXRvcnMgZm9yIFNsYXRlIG9iamVjdHMuXHJcbiAqL1xuXG52YXIgREVGQVVMVF9DUkVBVE9SUyA9IHtcbiAgYW5jaG9yOiBjcmVhdGVBbmNob3IsXG4gIGN1cnNvcjogY3JlYXRlQ3Vyc29yLFxuICBlZGl0b3I6IGNyZWF0ZUVkaXRvcihjcmVhdGVFZGl0b3IkMSksXG4gIGVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQsXG4gIGZvY3VzOiBjcmVhdGVGb2N1cyxcbiAgZnJhZ21lbnQ6IGNyZWF0ZUZyYWdtZW50LFxuICBzZWxlY3Rpb246IGNyZWF0ZVNlbGVjdGlvbixcbiAgdGV4dDogY3JlYXRlVGV4dFxufTtcbi8qKlxyXG4gKiBDcmVhdGUgYSBTbGF0ZSBoeXBlcnNjcmlwdCBmdW5jdGlvbiB3aXRoIGBvcHRpb25zYC5cclxuICovXG5cbnZhciBjcmVhdGVIeXBlcnNjcmlwdCA9IGZ1bmN0aW9uIGNyZWF0ZUh5cGVyc2NyaXB0KCkge1xuICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gIHZhciB7XG4gICAgZWxlbWVudHMgPSB7fVxuICB9ID0gb3B0aW9ucztcbiAgdmFyIGVsZW1lbnRDcmVhdG9ycyA9IG5vcm1hbGl6ZUVsZW1lbnRzKGVsZW1lbnRzKTtcblxuICB2YXIgY3JlYXRvcnMgPSBfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZCh7fSwgREVGQVVMVF9DUkVBVE9SUyksIGVsZW1lbnRDcmVhdG9ycyksIG9wdGlvbnMuY3JlYXRvcnMpO1xuXG4gIHZhciBqc3ggPSBjcmVhdGVGYWN0b3J5KGNyZWF0b3JzKTtcbiAgcmV0dXJuIGpzeDtcbn07XG4vKipcclxuICogQ3JlYXRlIGEgU2xhdGUgaHlwZXJzY3JpcHQgZnVuY3Rpb24gd2l0aCBgb3B0aW9uc2AuXHJcbiAqL1xuXG5cbnZhciBjcmVhdGVGYWN0b3J5ID0gY3JlYXRvcnMgPT4ge1xuICB2YXIganN4ID0gZnVuY3Rpb24ganN4KHRhZ05hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgY2hpbGRyZW4gPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgY2hpbGRyZW5bX2tleSAtIDJdID0gYXJndW1lbnRzW19rZXldO1xuICAgIH1cblxuICAgIHZhciBjcmVhdG9yID0gY3JlYXRvcnNbdGFnTmFtZV07XG5cbiAgICBpZiAoIWNyZWF0b3IpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGh5cGVyc2NyaXB0IGNyZWF0b3IgZm91bmQgZm9yIHRhZzogPFwiLmNvbmNhdCh0YWdOYW1lLCBcIj5cIikpO1xuICAgIH1cblxuICAgIGlmIChhdHRyaWJ1dGVzID09IG51bGwpIHtcbiAgICAgIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICB9XG5cbiAgICBpZiAoIWlzUGxhaW5PYmplY3QoYXR0cmlidXRlcykpIHtcbiAgICAgIGNoaWxkcmVuID0gW2F0dHJpYnV0ZXNdLmNvbmNhdChjaGlsZHJlbik7XG4gICAgICBhdHRyaWJ1dGVzID0ge307XG4gICAgfVxuXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoY2hpbGQgPT4gQm9vbGVhbihjaGlsZCkpLmZsYXQoKTtcbiAgICB2YXIgcmV0ID0gY3JlYXRvcih0YWdOYW1lLCBhdHRyaWJ1dGVzLCBjaGlsZHJlbik7XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4ganN4O1xufTtcbi8qKlxyXG4gKiBOb3JtYWxpemUgYSBkaWN0aW9uYXJ5IG9mIGVsZW1lbnQgc2hvcnRoYW5kcyBpbnRvIGNyZWF0b3IgZnVuY3Rpb25zLlxyXG4gKi9cblxuXG52YXIgbm9ybWFsaXplRWxlbWVudHMgPSBlbGVtZW50cyA9PiB7XG4gIHZhciBjcmVhdG9ycyA9IHt9O1xuXG4gIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKHRhZ05hbWUpIHtcbiAgICB2YXIgcHJvcHMgPSBlbGVtZW50c1t0YWdOYW1lXTtcblxuICAgIGlmICh0eXBlb2YgcHJvcHMgIT09ICdvYmplY3QnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQcm9wZXJ0aWVzIHNwZWNpZmllZCBmb3IgYSBoeXBlcnNjcmlwdCBzaG9ydGhhbmQgc2hvdWxkIGJlIGFuIG9iamVjdCwgYnV0IGZvciB0aGUgY3VzdG9tIGVsZW1lbnQgPFwiLmNvbmNhdCh0YWdOYW1lLCBcIj4gIHRhZyB5b3UgcGFzc2VkOiBcIikuY29uY2F0KHByb3BzKSk7XG4gICAgfVxuXG4gICAgY3JlYXRvcnNbdGFnTmFtZV0gPSAodGFnTmFtZSwgYXR0cmlidXRlcywgY2hpbGRyZW4pID0+IHtcbiAgICAgIHJldHVybiBjcmVhdGVFbGVtZW50KCdlbGVtZW50JywgX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKHt9LCBwcm9wcyksIGF0dHJpYnV0ZXMpLCBjaGlsZHJlbik7XG4gICAgfTtcbiAgfTtcblxuICBmb3IgKHZhciB0YWdOYW1lIGluIGVsZW1lbnRzKSB7XG4gICAgX2xvb3AodGFnTmFtZSk7XG4gIH1cblxuICByZXR1cm4gY3JlYXRvcnM7XG59O1xuXG4vKipcclxuICogVGhlIGRlZmF1bHQgaHlwZXJzY3JpcHQgZmFjdG9yeSB0aGF0IHNoaXBzIHdpdGggU2xhdGUsIHdpdGhvdXQgY3VzdG9tIHRhZ3MuXHJcbiAqL1xuXG52YXIganN4ID0gY3JlYXRlSHlwZXJzY3JpcHQoKTtcblxuZXhwb3J0IHsgY3JlYXRlRWRpdG9yLCBjcmVhdGVIeXBlcnNjcmlwdCwgY3JlYXRlVGV4dCwganN4IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/slate-hyperscript@0.81.3_slate@0.91.4/node_modules/slate-hyperscript/dist/index.es.js\n");

/***/ })

};
;