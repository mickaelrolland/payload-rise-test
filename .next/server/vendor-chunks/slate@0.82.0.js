"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/slate@0.82.0";
exports.ids = ["vendor-chunks/slate@0.82.0"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/slate@0.82.0/node_modules/slate/dist/index.es.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/slate@0.82.0/node_modules/slate/dist/index.es.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Operation: () => (/* binding */ Operation),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PathRef: () => (/* binding */ PathRef),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PointRef: () => (/* binding */ PointRef),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeRef: () => (/* binding */ RangeRef),\n/* harmony export */   Scrubber: () => (/* binding */ Scrubber),\n/* harmony export */   Span: () => (/* binding */ Span),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transforms: () => (/* binding */ Transforms),\n/* harmony export */   createEditor: () => (/* binding */ createEditor)\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"(rsc)/./node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! immer */ \"(rsc)/./node_modules/.pnpm/immer@9.0.21/node_modules/immer/dist/immer.esm.mjs\");\n\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\nfunction ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n/**\r\n * Create a new Slate `Editor` object.\r\n */\n\nvar createEditor = () => {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n    apply: op => {\n      for (var ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op);\n      }\n\n      for (var _ref of Editor.pointRefs(editor)) {\n        PointRef.transform(_ref, op);\n      }\n\n      for (var _ref2 of Editor.rangeRefs(editor)) {\n        RangeRef.transform(_ref2, op);\n      }\n\n      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n      var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n      var dirtyPaths;\n      var dirtyPathKeys;\n\n      var add = path => {\n        if (path) {\n          var key = path.join(',');\n\n          if (!dirtyPathKeys.has(key)) {\n            dirtyPathKeys.add(key);\n            dirtyPaths.push(path);\n          }\n        }\n      };\n\n      if (Path.operationCanTransformPath(op)) {\n        dirtyPaths = [];\n        dirtyPathKeys = new Set();\n\n        for (var path of oldDirtyPaths) {\n          var newPath = Path.transform(path, op);\n          add(newPath);\n        }\n      } else {\n        dirtyPaths = oldDirtyPaths;\n        dirtyPathKeys = oldDirtyPathKeys;\n      }\n\n      var newDirtyPaths = getDirtyPaths(op);\n\n      for (var _path of newDirtyPaths) {\n        add(_path);\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths);\n      DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n      Transforms.transform(editor, op);\n      editor.operations.push(op);\n      Editor.normalize(editor); // Clear any formats applied to the cursor if the selection changes.\n\n      if (op.type === 'set_selection') {\n        editor.marks = null;\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false);\n          editor.onChange();\n          editor.operations = [];\n        });\n      }\n    },\n    addMark: (key, value) => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(editor, {\n            [key]: value\n          }, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, {\n            [key]: value\n          });\n\n          editor.marks = marks;\n\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    },\n    deleteBackward: unit => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit,\n          reverse: true\n        });\n      }\n    },\n    deleteForward: unit => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit\n        });\n      }\n    },\n    deleteFragment: direction => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, {\n          reverse: direction === 'backward'\n        });\n      }\n    },\n    getFragment: () => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        return Node.fragment(editor, selection);\n      }\n\n      return [];\n    },\n    insertBreak: () => {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertSoftBreak: () => {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertFragment: fragment => {\n      Transforms.insertFragment(editor, fragment);\n    },\n    insertNode: node => {\n      Transforms.insertNodes(editor, node);\n    },\n    insertText: text => {\n      var {\n        selection,\n        marks\n      } = editor;\n\n      if (selection) {\n        if (marks) {\n          var node = _objectSpread$9({\n            text\n          }, marks);\n\n          Transforms.insertNodes(editor, node);\n        } else {\n          Transforms.insertText(editor, text);\n        }\n\n        editor.marks = null;\n      }\n    },\n    normalizeNode: entry => {\n      var [node, path] = entry; // There are no core normalizations for text nodes.\n\n      if (Text.isText(node)) {\n        return;\n      } // Ensure that block and inline nodes have at least one text child.\n\n\n      if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n          text: ''\n        };\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true\n        });\n        return;\n      } // Determine whether the node should have block or inline children.\n\n\n      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n\n      var n = 0;\n\n      for (var i = 0; i < node.children.length; i++, n++) {\n        var currentNode = Node.get(editor, path);\n        if (Text.isText(currentNode)) continue;\n        var _child = node.children[i];\n        var prev = currentNode.children[n - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (Element.isElement(_child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(_child)) {\n            if (prev == null || !Text.isText(prev)) {\n              var newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true\n              });\n              n++;\n            } else if (isLast) {\n              var _newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, _newChild, {\n                at: path.concat(n + 1),\n                voids: true\n              });\n              n++;\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(_child, prev, {\n              loose: true\n            })) {\n              Transforms.mergeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true\n              });\n              n--;\n            } else if (_child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            }\n          }\n        }\n      }\n    },\n    removeMark: key => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread$9({}, Editor.marks(editor) || {});\n\n          delete marks[key];\n          editor.marks = marks;\n\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    }\n  };\n  return editor;\n};\n/**\r\n * Get the \"dirty\" paths generated from an operation.\r\n */\n\nvar getDirtyPaths = op => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var {\n          path\n        } = op;\n        return Path.levels(path);\n      }\n\n    case 'insert_node':\n      {\n        var {\n          node,\n          path: _path2\n        } = op;\n        var levels = Path.levels(_path2);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), _ref3 => {\n          var [, p] = _ref3;\n          return _path2.concat(p);\n        });\n        return [...levels, ...descendants];\n      }\n\n    case 'merge_node':\n      {\n        var {\n          path: _path3\n        } = op;\n        var ancestors = Path.ancestors(_path3);\n        var previousPath = Path.previous(_path3);\n        return [...ancestors, previousPath];\n      }\n\n    case 'move_node':\n      {\n        var {\n          path: _path4,\n          newPath\n        } = op;\n\n        if (Path.equals(_path4, newPath)) {\n          return [];\n        }\n\n        var oldAncestors = [];\n        var newAncestors = [];\n\n        for (var ancestor of Path.ancestors(_path4)) {\n          var p = Path.transform(ancestor, op);\n          oldAncestors.push(p);\n        }\n\n        for (var _ancestor of Path.ancestors(newPath)) {\n          var _p = Path.transform(_ancestor, op);\n\n          newAncestors.push(_p);\n        }\n\n        var newParent = newAncestors[newAncestors.length - 1];\n        var newIndex = newPath[newPath.length - 1];\n        var resultPath = newParent.concat(newIndex);\n        return [...oldAncestors, ...newAncestors, resultPath];\n      }\n\n    case 'remove_node':\n      {\n        var {\n          path: _path5\n        } = op;\n\n        var _ancestors = Path.ancestors(_path5);\n\n        return [..._ancestors];\n      }\n\n    case 'split_node':\n      {\n        var {\n          path: _path6\n        } = op;\n\n        var _levels = Path.levels(_path6);\n\n        var nextPath = Path.next(_path6);\n        return [..._levels, nextPath];\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\nvar getCharacterDistance = function getCharacterDistance(str) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isLTR = !isRTL;\n  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n  var left = CodepointType.None;\n  var right = CodepointType.None;\n  var distance = 0; // Evaluation of these conditions are deferred.\n\n  var gb11 = null; // Is GB11 applicable?\n\n  var gb12Or13 = null; // Is GB12 or GB13 applicable?\n\n  for (var char of codepoints) {\n    var code = char.codePointAt(0);\n    if (!code) break;\n    var type = getCodepointType(char, code);\n    [left, right] = isLTR ? [right, type] : [type, left];\n\n    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n      if (isLTR) {\n        gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n      } else {\n        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n      }\n\n      if (!gb11) break;\n    }\n\n    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n      if (gb12Or13 !== null) {\n        gb12Or13 = !gb12Or13;\n      } else {\n        if (isLTR) {\n          gb12Or13 = true;\n        } else {\n          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n        }\n      }\n\n      if (!gb12Or13) break;\n    }\n\n    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n      break;\n    }\n\n    distance += char.length;\n  }\n\n  return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\n\nvar getWordDistance = function getWordDistance(text) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dist = 0;\n  var started = false;\n\n  while (text.length > 0) {\n    var charDist = getCharacterDistance(text, isRTL);\n    var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);\n\n    if (isWordCharacter(char, remaining, isRTL)) {\n      started = true;\n      dist += charDist;\n    } else if (!started) {\n      dist += charDist;\n    } else {\n      break;\n    }\n\n    text = remaining;\n  }\n\n  return dist;\n};\n/**\r\n * Split a string in two parts at a given distance starting from the end when\r\n * `isRTL` is set to `true`.\r\n */\n\nvar splitByCharacterDistance = (str, dist, isRTL) => {\n  if (isRTL) {\n    var at = str.length - dist;\n    return [str.slice(at, str.length), str.slice(0, at)];\n  }\n\n  return [str.slice(0, dist), str.slice(dist)];\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\n\nvar isWordCharacter = function isWordCharacter(char, remaining) {\n  var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (SPACE.test(char)) {\n    return false;\n  } // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n\n\n  if (CHAMELEON.test(char)) {\n    var charDist = getCharacterDistance(remaining, isRTL);\n    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n\n    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n      return true;\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Iterate on codepoints from right to left.\r\n */\n\n\nvar codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n  var end = str.length - 1;\n\n  for (var i = 0; i < str.length; i++) {\n    var char1 = str.charAt(end - i);\n\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      var char2 = str.charAt(end - i - 1);\n\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1;\n        i++;\n        continue;\n      }\n    }\n\n    yield char1;\n  }\n};\n/**\r\n * Is `charCode` a high surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */\n\nvar isHighSurrogate = charCode => {\n  return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\r\n * Is `charCode` a low surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */\n\n\nvar isLowSurrogate = charCode => {\n  return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\n\nvar CodepointType;\n\n(function (CodepointType) {\n  CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n  CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n  CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n  CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n  CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n  CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n  CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n  CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n  CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n  CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n  CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n  CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n  CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\n\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\n\nvar getCodepointType = (char, code) => {\n  var type = CodepointType.Any;\n\n  if (char.search(reExtend) !== -1) {\n    type |= CodepointType.Extend;\n  }\n\n  if (code === 0x200d) {\n    type |= CodepointType.ZWJ;\n  }\n\n  if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n    type |= CodepointType.RI;\n  }\n\n  if (char.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend;\n  }\n\n  if (char.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark;\n  }\n\n  if (char.search(reL) !== -1) {\n    type |= CodepointType.L;\n  }\n\n  if (char.search(reV) !== -1) {\n    type |= CodepointType.V;\n  }\n\n  if (char.search(reT) !== -1) {\n    type |= CodepointType.T;\n  }\n\n  if (char.search(reLV) !== -1) {\n    type |= CodepointType.LV;\n  }\n\n  if (char.search(reLVT) !== -1) {\n    type |= CodepointType.LVT;\n  }\n\n  if (char.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict;\n  }\n\n  return type;\n};\n\nfunction intersects(x, y) {\n  return (x & y) !== 0;\n}\n\nvar NonBoundaryPairs = [// GB6\n[CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT], // GB7\n[CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T], // GB8\n[CodepointType.LVT | CodepointType.T, CodepointType.T], // GB9\n[CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ], // GB9a\n[CodepointType.Any, CodepointType.SpacingMark], // GB9b\n[CodepointType.Prepend, CodepointType.Any], // GB11\n[CodepointType.ZWJ, CodepointType.ExtPict], // GB12 and GB13\n[CodepointType.RI, CodepointType.RI]];\n\nfunction isBoundaryPair(left, right) {\n  return NonBoundaryPairs.findIndex(r => intersects(left, r[0]) && intersects(right, r[1])) === -1;\n}\n\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\n\nvar endsWithEmojiZWJ = str => {\n  return str.search(endingEmojiZWJ) !== -1;\n};\n\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\n\nvar endsWithOddNumberOfRIs = str => {\n  var match = str.match(endingRIs);\n\n  if (match === null) {\n    return false;\n  } else {\n    // A RI is represented by a surrogate pair.\n    var numRIs = match[0].length / 2;\n    return numRIs % 2 === 1;\n  }\n};\n\n/**\r\n * Shared the function with isElementType utility\r\n */\n\nvar isElement = value => {\n  return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n}; // eslint-disable-next-line no-redeclare\n\n\nvar Element = {\n  /**\r\n   * Check if a value implements the 'Ancestor' interface.\r\n   */\n  isAncestor(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children);\n  },\n\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\n  isElement,\n\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\n  isElementList(value) {\n    return Array.isArray(value) && value.every(val => Element.isElement(val));\n  },\n\n  /**\r\n   * Check if a set of props is a partial of Element.\r\n   */\n  isElementProps(props) {\n    return props.children !== undefined;\n  },\n\n  /**\r\n   * Check if a value implements the `Element` interface and has elementKey with selected value.\r\n   * Default it check to `type` key value\r\n   */\n  isElementType: function isElementType(value, elementVal) {\n    var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';\n    return isElement(value) && value[elementKey] === elementVal;\n  },\n\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */\n  matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n};\n\nvar _excluded$4 = [\"text\"],\n    _excluded2$3 = [\"text\"];\n\nfunction ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar IS_EDITOR_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar Editor = {\n  /**\r\n   * Get the ancestor above a location in the document.\r\n   */\n  above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var path = Editor.path(editor, at);\n    var reverse = mode === 'lowest';\n\n    for (var [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse\n    })) {\n      if (!Text.isText(n) && !Path.equals(path, p)) {\n        return [n, p];\n      }\n    }\n  },\n\n  /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */\n  addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n\n  /**\r\n   * Get the point after a location.\r\n   */\n  after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n      edge: 'end'\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n      anchor,\n      focus\n    };\n    var {\n      distance = 1\n    } = options;\n    var d = 0;\n    var target;\n\n    for (var p of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      at: range\n    }))) {\n      if (d > distance) {\n        break;\n      }\n\n      if (d !== 0) {\n        target = p;\n      }\n\n      d++;\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Get the point before a location.\r\n   */\n  before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n      edge: 'start'\n    });\n    var range = {\n      anchor,\n      focus\n    };\n    var {\n      distance = 1\n    } = options;\n    var d = 0;\n    var target;\n\n    for (var p of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      at: range,\n      reverse: true\n    }))) {\n      if (d > distance) {\n        break;\n      }\n\n      if (d !== 0) {\n        target = p;\n      }\n\n      d++;\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */\n  deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteBackward(unit);\n  },\n\n  /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */\n  deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteForward(unit);\n  },\n\n  /**\r\n   * Delete the content in the current selection.\r\n   */\n  deleteFragment(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      direction = 'forward'\n    } = options;\n    editor.deleteFragment(direction);\n  },\n\n  /**\r\n   * Get the start and end points of a location.\r\n   */\n  edges(editor, at) {\n    return [Editor.start(editor, at), Editor.end(editor, at)];\n  },\n\n  /**\r\n   * Get the end point of a location.\r\n   */\n  end(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'end'\n    });\n  },\n\n  /**\r\n   * Get the first node at a location.\r\n   */\n  first(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'start'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the fragment at a location.\r\n   */\n  fragment(editor, at) {\n    var range = Editor.range(editor, at);\n    var fragment = Node.fragment(editor, range);\n    return fragment;\n  },\n\n  /**\r\n   * Check if a node has block children.\r\n   */\n  hasBlocks(editor, element) {\n    return element.children.some(n => Editor.isBlock(editor, n));\n  },\n\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\n  hasInlines(editor, element) {\n    return element.children.some(n => Text.isText(n) || Editor.isInline(editor, n));\n  },\n\n  /**\r\n   * Check if a node has text children.\r\n   */\n  hasTexts(editor, element) {\n    return element.children.every(n => Text.isText(n));\n  },\n\n  /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertBreak(editor) {\n    editor.insertBreak();\n  },\n\n  /**\r\n   * Insert a soft break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertSoftBreak(editor) {\n    editor.insertSoftBreak();\n  },\n\n  /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertFragment(editor, fragment) {\n    editor.insertFragment(fragment);\n  },\n\n  /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n\n  /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertText(editor, text) {\n    editor.insertText(text);\n  },\n\n  /**\r\n   * Check if a value is a block `Element` object.\r\n   */\n  isBlock(editor, value) {\n    return Element.isElement(value) && !editor.isInline(value);\n  },\n\n  /**\r\n   * Check if a value is an `Editor` object.\r\n   */\n  isEditor(value) {\n    var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n\n    if (cachedIsEditor !== undefined) {\n      return cachedIsEditor;\n    }\n\n    if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n      return false;\n    }\n\n    var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && (value.marks === null || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n    IS_EDITOR_CACHE.set(value, isEditor);\n    return isEditor;\n  },\n\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\n  isEnd(editor, point, at) {\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n  },\n\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\n  isEdge(editor, point, at) {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n  },\n\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\n  isEmpty(editor, element) {\n    var {\n      children\n    } = element;\n    var [first] = children;\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n  },\n\n  /**\r\n   * Check if a value is an inline `Element` object.\r\n   */\n  isInline(editor, value) {\n    return Element.isElement(value) && editor.isInline(value);\n  },\n\n  /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */\n  isNormalizing(editor) {\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n  },\n\n  /**\r\n   * Check if a point is the start point of a location.\r\n   */\n  isStart(editor, point, at) {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false;\n    }\n\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n  },\n\n  /**\r\n   * Check if a value is a void `Element` object.\r\n   */\n  isVoid(editor, value) {\n    return Element.isElement(value) && editor.isVoid(value);\n  },\n\n  /**\r\n   * Get the last node at a location.\r\n   */\n  last(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'end'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\n  leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\n  *levels(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n\n    if (match == null) {\n      match = () => true;\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var levels = [];\n    var path = Editor.path(editor, at);\n\n    for (var [n, p] of Node.levels(editor, path)) {\n      if (!match(n, p)) {\n        continue;\n      }\n\n      levels.push([n, p]);\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break;\n      }\n    }\n\n    if (reverse) {\n      levels.reverse();\n    }\n\n    yield* levels;\n  },\n\n  /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */\n  marks(editor) {\n    var {\n      marks,\n      selection\n    } = editor;\n\n    if (!selection) {\n      return null;\n    }\n\n    if (marks) {\n      return marks;\n    }\n\n    if (Range.isExpanded(selection)) {\n      var [match] = Editor.nodes(editor, {\n        match: Text.isText\n      });\n\n      if (match) {\n        var [_node] = match;\n\n        var _rest = _objectWithoutProperties(_node, _excluded$4);\n\n        return _rest;\n      } else {\n        return {};\n      }\n    }\n\n    var {\n      anchor\n    } = selection;\n    var {\n      path\n    } = anchor;\n    var [node] = Editor.leaf(editor, path);\n\n    if (anchor.offset === 0) {\n      var prev = Editor.previous(editor, {\n        at: path,\n        match: Text.isText\n      });\n      var block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n)\n      });\n\n      if (prev && block) {\n        var [prevNode, prevPath] = prev;\n        var [, blockPath] = block;\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n\n    var rest = _objectWithoutProperties(node, _excluded2$3);\n\n    return rest;\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\n  next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var pointAfterLocation = Editor.after(editor, at, {\n      voids\n    });\n    if (!pointAfterLocation) return;\n    var [, to] = Editor.last(editor, []);\n    var span = [pointAfterLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the next node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n\n        match = n => parent.children.includes(n);\n      } else {\n        match = () => true;\n      }\n    }\n\n    var [next] = Editor.nodes(editor, {\n      at: span,\n      match,\n      mode,\n      voids\n    });\n    return next;\n  },\n\n  /**\r\n   * Get the node at a location.\r\n   */\n  node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */\n  *nodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n\n    if (!match) {\n      match = () => true;\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var from;\n    var to;\n\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: 'start'\n      });\n      var last = Editor.path(editor, at, {\n        edge: 'end'\n      });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n\n    var nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: _ref => {\n        var [n] = _ref;\n        return voids ? false : Editor.isVoid(editor, n);\n      }\n    });\n    var matches = [];\n    var hit;\n\n    for (var [node, path] of nodeEntries) {\n      var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n\n      if (mode === 'highest' && isLower) {\n        continue;\n      }\n\n      if (!match(node, path)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return;\n        } else {\n          continue;\n        }\n      } // If there's a match and it's lower than the last, update the hit.\n\n\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path];\n        continue;\n      } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n\n\n      var emit = mode === 'lowest' ? hit : [node, path];\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit);\n        } else {\n          yield emit;\n        }\n      }\n\n      hit = [node, path];\n    } // Since lowest is always emitting one behind, catch up at the end.\n\n\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    } // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n\n\n    if (universal) {\n      yield* matches;\n    }\n  },\n\n  /**\r\n   * Normalize any dirty objects in the editor.\r\n   */\n  normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      force = false\n    } = options;\n\n    var getDirtyPaths = editor => {\n      return DIRTY_PATHS.get(editor) || [];\n    };\n\n    var getDirtyPathKeys = editor => {\n      return DIRTY_PATH_KEYS.get(editor) || new Set();\n    };\n\n    var popDirtyPath = editor => {\n      var path = getDirtyPaths(editor).pop();\n      var key = path.join(',');\n      getDirtyPathKeys(editor).delete(key);\n      return path;\n    };\n\n    if (!Editor.isNormalizing(editor)) {\n      return;\n    }\n\n    if (force) {\n      var allPaths = Array.from(Node.nodes(editor), _ref2 => {\n        var [, p] = _ref2;\n        return p;\n      });\n      var allPathKeys = new Set(allPaths.map(p => p.join(',')));\n      DIRTY_PATHS.set(editor, allPaths);\n      DIRTY_PATH_KEYS.set(editor, allPathKeys);\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return;\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      /*\r\n        Fix dirty elements with no children.\r\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\r\n        Running an initial pass avoids the catch-22 race condition.\r\n      */\n      for (var dirtyPath of getDirtyPaths(editor)) {\n        if (Node.has(editor, dirtyPath)) {\n          var entry = Editor.node(editor, dirtyPath);\n          var [node, _] = entry;\n          /*\r\n            The default normalizer inserts an empty text node in this scenario, but it can be customised.\r\n            So there is some risk here.\r\n                       As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\r\n            by definition adding children to an empty node can't cause other paths to change.\r\n          */\n\n          if (Element.isElement(node) && node.children.length === 0) {\n            editor.normalizeNode(entry);\n          }\n        }\n      }\n\n      var max = getDirtyPaths(editor).length * 42; // HACK: better way?\n\n      var m = 0;\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(\"\\n            Could not completely normalize the editor after \".concat(max, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\\n          \"));\n        }\n\n        var _dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.\n\n\n        if (Node.has(editor, _dirtyPath)) {\n          var _entry = Editor.node(editor, _dirtyPath);\n\n          editor.normalizeNode(_entry);\n        }\n\n        m++;\n      }\n    });\n  },\n\n  /**\r\n   * Get the parent node of a location.\r\n   */\n  parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n  },\n\n  /**\r\n   * Get the path of a location.\r\n   */\n  path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      depth,\n      edge\n    } = options;\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        var [, firstPath] = Node.first(editor, at);\n        at = firstPath;\n      } else if (edge === 'end') {\n        var [, lastPath] = Node.last(editor, at);\n        at = lastPath;\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at);\n      } else if (edge === 'end') {\n        at = Range.end(at);\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path);\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path;\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth);\n    }\n\n    return at;\n  },\n\n  hasPath(editor, path) {\n    return Node.has(editor, path);\n  },\n\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: path,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var pathRefs = Editor.pathRefs(editor);\n        pathRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */\n  pathRefs(editor) {\n    var refs = PATH_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      PATH_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Get the start or end point of a location.\r\n   */\n  point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      edge = 'start'\n    } = options;\n\n    if (Path.isPath(at)) {\n      var path;\n\n      if (edge === 'end') {\n        var [, lastPath] = Node.last(editor, at);\n        path = lastPath;\n      } else {\n        var [, firstPath] = Node.first(editor, at);\n        path = firstPath;\n      }\n\n      var node = Node.get(editor, path);\n\n      if (!Text.isText(node)) {\n        throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n      }\n\n      return {\n        path,\n        offset: edge === 'end' ? node.text.length : 0\n      };\n    }\n\n    if (Range.isRange(at)) {\n      var [start, end] = Range.edges(at);\n      return edge === 'start' ? start : end;\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: point,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var pointRefs = Editor.pointRefs(editor);\n        pointRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */\n  pointRefs(editor) {\n    var refs = POINT_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      POINT_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Return all the positions in `at` range where a `Point` can be placed.\r\n   *\r\n   * By default, moves forward by individual offsets at a time, but\r\n   * the `unit` option can be used to to move by character, word, line, or block.\r\n   *\r\n   * The `reverse` option can be used to change iteration direction.\r\n   *\r\n   * Note: By default void nodes are treated as a single point and iteration\r\n   * will not happen inside their content unless you pass in true for the\r\n   * `voids` option, then iteration will occur.\r\n   */\n  *positions(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      unit = 'offset',\n      reverse = false,\n      voids = false\n    } = options;\n\n    if (!at) {\n      return;\n    }\n    /**\r\n     * Algorithm notes:\r\n     *\r\n     * Each step `distance` is dynamic depending on the underlying text\r\n     * and the `unit` specified.  Each step, e.g., a line or word, may\r\n     * span multiple text nodes, so we iterate through the text both on\r\n     * two levels in step-sync:\r\n     *\r\n     * `leafText` stores the text on a text leaf level, and is advanced\r\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\r\n     *\r\n     * `blockText` stores the text on a block level, and is shortened\r\n     * by `distance` every time it is advanced.\r\n     *\r\n     * We only maintain a window of one blockText and one leafText because\r\n     * a block node always appears before all of its leaf nodes.\r\n     */\n\n\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var first = reverse ? end : start;\n    var isNewBlock = false;\n    var blockText = '';\n    var distance = 0; // Distance for leafText to catch up to blockText.\n\n    var leafTextRemaining = 0;\n    var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      reverse,\n      voids\n    })) {\n      /*\r\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\r\n       */\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, so by default we will always\n        // yield their first point. If the `voids` option is set to true,\n        // then we will iterate over their content.\n        if (!voids && editor.isVoid(node)) {\n          yield Editor.start(editor, path);\n          continue;\n        } // Inline element nodes are ignored as they don't themselves\n        // contribute to `blockText` or `leafText` - their parent and\n        // children do.\n\n\n        if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.\n\n        if (Editor.hasInlines(editor, node)) {\n          // We always exhaust block nodes before encountering a new one:\n          //   console.assert(blockText === '',\n          //     `blockText='${blockText}' - `+\n          //     `not exhausted before new block node`, path)\n          // Ensure range considered is capped to `range`, in the\n          // start/end edge cases where block extends beyond range.\n          // Equivalent to this, but presumably more performant:\n          //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n          //   blockRange = Range.intersection(range, blockRange) // intersect\n          //   blockText = Editor.string(editor, blockRange, { voids })\n          var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n          var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n          blockText = Editor.string(editor, {\n            anchor: s,\n            focus: e\n          }, {\n            voids\n          });\n          isNewBlock = true;\n        }\n      }\n      /*\r\n       * TEXT LEAF NODE - Iterate through text content, yielding\r\n       * positions every `distance` offset according to `unit`.\r\n       */\n\n\n      if (Text.isText(node)) {\n        var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:\n        //   console.assert(leafTextRemaining <= 0,\n        //     `leafTextRemaining=${leafTextRemaining} - `+\n        //     `not exhausted before new leaf text node`, path)\n        // Reset `leafText` counters for new text node.\n\n        if (isFirst) {\n          leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n          leafTextOffset = first.offset; // Works for reverse too.\n        } else {\n          leafTextRemaining = node.text.length;\n          leafTextOffset = reverse ? leafTextRemaining : 0;\n        } // Yield position at the start of node (potentially).\n\n\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield {\n            path,\n            offset: leafTextOffset\n          };\n          isNewBlock = false;\n        } // Yield positions every (dynamically calculated) `distance` offset.\n\n\n        while (true) {\n          // If `leafText` has caught up with `blockText` (distance=0),\n          // and if blockText is exhausted, break to get another block node,\n          // otherwise advance blockText forward by the new `distance`.\n          if (distance === 0) {\n            if (blockText === '') break;\n            distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the\n            // remaining string for the next iteration.\n\n            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n          } // Advance `leafText` by the current `distance`.\n\n\n          leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n          leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node\n          // and set distance to the overflow amount, so we'll (maybe)\n          // catch up to blockText in the next leaf text node.\n\n          if (leafTextRemaining < 0) {\n            distance = -leafTextRemaining;\n            break;\n          } // Successfully walked `distance` offsets through `leafText`\n          // to catch up with `blockText`, so we can reset `distance`\n          // and yield this position in this node.\n\n\n          distance = 0;\n          yield {\n            path,\n            offset: leafTextOffset\n          };\n        }\n      }\n    } // Proof that upon completion, we've exahusted both leaf and block text:\n    //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n    //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n    // Helper:\n    // Return the distance in offsets for a step of size `unit` on given string.\n\n\n    function calcDistance(text, unit, reverse) {\n      if (unit === 'character') {\n        return getCharacterDistance(text, reverse);\n      } else if (unit === 'word') {\n        return getWordDistance(text, reverse);\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length;\n      }\n\n      return 1;\n    }\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\n  previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var pointBeforeLocation = Editor.before(editor, at, {\n      voids\n    });\n\n    if (!pointBeforeLocation) {\n      return;\n    }\n\n    var [, to] = Editor.first(editor, []); // The search location is from the start of the document to the path of\n    // the point before the location passed in\n\n    var span = [pointBeforeLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n\n        match = n => parent.children.includes(n);\n      } else {\n        match = () => true;\n      }\n    }\n\n    var [previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids\n    });\n    return previous;\n  },\n\n  /**\r\n   * Get a range of a location.\r\n   */\n  range(editor, at, to) {\n    if (Range.isRange(at) && !to) {\n      return at;\n    }\n\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: range,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var rangeRefs = Editor.rangeRefs(editor);\n        rangeRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */\n  rangeRefs(editor) {\n    var refs = RANGE_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      RANGE_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */\n  removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n\n  /**\r\n   * Manually set if the editor should currently be normalizing.\r\n   *\r\n   * Note: Using this incorrectly can leave the editor in an invalid state.\r\n   *\r\n   */\n  setNormalizing(editor, isNormalizing) {\n    NORMALIZING.set(editor, isNormalizing);\n  },\n\n  /**\r\n   * Get the start point of a location.\r\n   */\n  start(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'start'\n    });\n  },\n\n  /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: by default the text of void nodes is considered to be an empty\r\n   * string, regardless of content, unless you pass in true for the voids option\r\n   */\n  string(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      voids = false\n    } = options;\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var text = '';\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids\n    })) {\n      var t = node.text;\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset);\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset);\n      }\n\n      text += t;\n    }\n\n    return text;\n  },\n\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\n  unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      voids = false\n    } = options;\n    var [start, end] = Range.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.\n\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range;\n    }\n\n    var endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n)\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, start);\n    var before = {\n      anchor: first,\n      focus: end\n    };\n    var skip = true;\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids\n    })) {\n      if (skip) {\n        skip = false;\n        continue;\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = {\n          path,\n          offset: node.text.length\n        };\n        break;\n      }\n    }\n\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Match a void node in the current branch of the editor.\r\n   */\n  void(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      match: n => Editor.isVoid(editor, n)\n    }));\n  },\n\n  /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */\n  withoutNormalizing(editor, fn) {\n    var value = Editor.isNormalizing(editor);\n    Editor.setNormalizing(editor, false);\n\n    try {\n      fn();\n    } finally {\n      Editor.setNormalizing(editor, value);\n    }\n\n    Editor.normalize(editor);\n  }\n\n};\n\nvar Location = {\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\n  isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n\n}; // eslint-disable-next-line no-redeclare\n\nvar Span = {\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\n  isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n\n};\n\nvar _excluded$3 = [\"children\"],\n    _excluded2$2 = [\"text\"];\nvar IS_NODE_LIST_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar Node = {\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\n  ancestor(root, path) {\n    var node = Node.get(root, path);\n\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  *ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (var p of Path.ancestors(path, options)) {\n      var n = Node.ancestor(root, p);\n      var entry = [n, p];\n      yield entry;\n    }\n  },\n\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\n  child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n    }\n\n    var c = root.children[index];\n\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n    }\n\n    return c;\n  },\n\n  /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */\n  *children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      reverse = false\n    } = options;\n    var ancestor = Node.ancestor(root, path);\n    var {\n      children\n    } = ancestor;\n    var index = reverse ? children.length - 1 : 0;\n\n    while (reverse ? index >= 0 : index < children.length) {\n      var child = Node.child(ancestor, index);\n      var childPath = path.concat(index);\n      yield [child, childPath];\n      index = reverse ? index - 1 : index + 1;\n    }\n  },\n\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\n  common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\n  descendant(root, path) {\n    var node = Node.get(root, path);\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the descendant node entries inside a root node.\r\n   */\n  *descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path];\n      }\n    }\n  },\n\n  /**\r\n   * Return a generator of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\n  *elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path];\n      }\n    }\n  },\n\n  /**\r\n   * Extract props from a Node.\r\n   */\n  extractProps(node) {\n    if (Element.isAncestor(node)) {\n      var properties = _objectWithoutProperties(node, _excluded$3);\n\n      return properties;\n    } else {\n      var properties = _objectWithoutProperties(node, _excluded2$2);\n\n      return properties;\n    }\n  },\n\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\n  first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\n  fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n    }\n\n    var newRoot = (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)({\n      children: root.children\n    }, r => {\n      var [start, end] = Range.edges(range);\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: _ref => {\n          var [, path] = _ref;\n          return !Range.includes(range, path);\n        }\n      });\n\n      for (var [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          var parent = Node.parent(r, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 1);\n        }\n\n        if (Path.equals(path, end.path)) {\n          var leaf = Node.leaf(r, path);\n          leaf.text = leaf.text.slice(0, end.offset);\n        }\n\n        if (Path.equals(path, start.path)) {\n          var _leaf = Node.leaf(r, path);\n\n          _leaf.text = _leaf.text.slice(start.offset);\n        }\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\n  get(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n      }\n\n      node = node.children[p];\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\n  has(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n\n      node = node.children[p];\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\n  isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\n  isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n\n    var isNodeList = value.every(val => Node.isNode(val));\n    IS_NODE_LIST_CACHE.set(value, isNodeList);\n    return isNodeList;\n  },\n\n  /**\r\n   * Get the last node entry in a root node from a path.\r\n   */\n  last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\n  leaf(root, path) {\n    var node = Node.get(root, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  *levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (var p of Path.levels(path, options)) {\n      var n = Node.get(root, p);\n      yield [n, p];\n    }\n  },\n\n  /**\r\n   * Check if a node matches a set of props.\r\n   */\n  matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n\n  /**\r\n   * Return a generator of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\n  *nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      pass,\n      reverse = false\n    } = options;\n    var {\n      from = [],\n      to\n    } = options;\n    var visited = new Set();\n    var p = [];\n    var n = root;\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break;\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p];\n      } // If we're allowed to go downward and we haven't descended yet, do.\n\n\n      if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n        visited.add(n);\n        var nextIndex = reverse ? n.children.length - 1 : 0;\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length];\n        }\n\n        p = p.concat(nextIndex);\n        n = Node.get(root, p);\n        continue;\n      } // If we're at the root and we can't go down, we're done.\n\n\n      if (p.length === 0) {\n        break;\n      } // If we're going forward...\n\n\n      if (!reverse) {\n        var newPath = Path.next(p);\n\n        if (Node.has(root, newPath)) {\n          p = newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n      } // If we're going backward...\n\n\n      if (reverse && p[p.length - 1] !== 0) {\n        var _newPath = Path.previous(p);\n\n        p = _newPath;\n        n = Node.get(root, p);\n        continue;\n      } // Otherwise we're going upward...\n\n\n      p = Path.parent(p);\n      n = Node.get(root, p);\n      visited.add(n);\n    }\n  },\n\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\n  parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n\n    return p;\n  },\n\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\n  string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n\n  /**\r\n   * Return a generator of all leaf text nodes in a root node.\r\n   */\n  *texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path];\n      }\n    }\n  }\n\n};\n\nfunction ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Operation = {\n  /**\r\n   * Check of a value is a `NodeOperation` object.\r\n   */\n  isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n\n  /**\r\n   * Check of a value is an `Operation` object.\r\n   */\n  isOperation(value) {\n    if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n      return false;\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'set_node':\n        return Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\n  isOperationList(value) {\n    return Array.isArray(value) && value.every(val => Operation.isOperation(val));\n  },\n\n  /**\r\n   * Check of a value is a `SelectionOperation` object.\r\n   */\n  isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n\n  /**\r\n   * Check of a value is a `TextOperation` object.\r\n   */\n  isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\n  inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n\n      case 'insert_text':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n\n      case 'merge_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n\n      case 'move_node':\n        {\n          var {\n            newPath,\n            path\n          } = op; // PERF: in this case the move operation is a no-op anyways.\n\n          if (Path.equals(newPath, path)) {\n            return op;\n          } // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n\n\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          } // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n\n\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n\n      case 'remove_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n\n      case 'remove_text':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n\n      case 'set_node':\n        {\n          var {\n            properties,\n            newProperties\n          } = op;\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n\n      case 'set_selection':\n        {\n          var {\n            properties: _properties,\n            newProperties: _newProperties\n          } = op;\n\n          if (_properties == null) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n\n      case 'split_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n\n};\n\nvar Path = {\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\n  ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var paths = Path.levels(path, options);\n\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n\n    return paths;\n  },\n\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\n  common(path, another) {\n    var common = [];\n\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n\n      if (av !== bv) {\n        break;\n      }\n\n      common.push(av);\n    }\n\n    return common;\n  },\n\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\n  compare(path, another) {\n    var min = Math.min(path.length, another.length);\n\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\n  endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\n  endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\n  endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\n  equals(path, another) {\n    return path.length === another.length && path.every((n, i) => n === another[i]);\n  },\n\n  /**\r\n   * Check if the path of previous sibling node exists\r\n   */\n  hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n\n  /**\r\n   * Check if a path is after another.\r\n   */\n  isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\n  isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is before another.\r\n   */\n  isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n\n  /**\r\n   * Check if a path is a child of another.\r\n   */\n  isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\n  isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\n  isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\n  isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\n  isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\n  isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\n  levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var list = [];\n\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n\n    if (reverse) {\n      list.reverse();\n    }\n\n    return list;\n  },\n\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\n  next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n\n  /**\r\n   * Returns whether this operation can affect paths or not. Used as an\r\n   * optimization when updating dirty paths during normalization\r\n   *\r\n   * NOTE: This *must* be kept in sync with the implementation of 'transform'\r\n   * below\r\n   */\n  operationCanTransformPath(operation) {\n    switch (operation.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n      case 'move_node':\n        return true;\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\n  parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n\n    return path.slice(0, -1);\n  },\n\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\n  previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n\n    var last = path[path.length - 1];\n\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\n  relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n\n    return path.slice(ancestor.length);\n  },\n\n  /**\r\n   * Transform a path by an operation.\r\n   */\n  transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(path, p => {\n      var {\n        affinity = 'forward'\n      } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.\n\n      if (!path || (path === null || path === void 0 ? void 0 : path.length) === 0) {\n        return;\n      }\n\n      if (p === null) {\n        return null;\n      }\n\n      switch (operation.type) {\n        case 'insert_node':\n          {\n            var {\n              path: op\n            } = operation;\n\n            if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n              p[op.length - 1] += 1;\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            var {\n              path: _op\n            } = operation;\n\n            if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n              return null;\n            } else if (Path.endsBefore(_op, p)) {\n              p[_op.length - 1] -= 1;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            var {\n              path: _op2,\n              position\n            } = operation;\n\n            if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n            } else if (Path.isAncestor(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n              p[_op2.length] += position;\n            }\n\n            break;\n          }\n\n        case 'split_node':\n          {\n            var {\n              path: _op3,\n              position: _position\n            } = operation;\n\n            if (Path.equals(_op3, p)) {\n              if (affinity === 'forward') {\n                p[p.length - 1] += 1;\n              } else if (affinity === 'backward') ; else {\n                return null;\n              }\n            } else if (Path.endsBefore(_op3, p)) {\n              p[_op3.length - 1] += 1;\n            } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n              p[_op3.length - 1] += 1;\n              p[_op3.length] -= _position;\n            }\n\n            break;\n          }\n\n        case 'move_node':\n          {\n            var {\n              path: _op4,\n              newPath: onp\n            } = operation; // If the old and new path are the same, it's a no-op.\n\n            if (Path.equals(_op4, onp)) {\n              return;\n            }\n\n            if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n              var copy = onp.slice();\n\n              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                copy[_op4.length - 1] -= 1;\n              }\n\n              return copy.concat(p.slice(_op4.length));\n            } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              } else {\n                p[_op4.length - 1] += 1;\n              }\n            } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              }\n\n              p[onp.length - 1] += 1;\n            } else if (Path.endsBefore(_op4, p)) {\n              if (Path.equals(onp, p)) {\n                p[onp.length - 1] += 1;\n              }\n\n              p[_op4.length - 1] -= 1;\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n};\n\nvar PathRef = {\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Path.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nfunction ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Point = {\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\n  compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Check if a point is after another.\r\n   */\n  isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n\n  /**\r\n   * Check if a point is before another.\r\n   */\n  isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\n  equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\n  isPoint(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n\n  /**\r\n   * Transform a point by an operation.\r\n   */\n  transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(point, p => {\n      if (p === null) {\n        return null;\n      }\n\n      var {\n        affinity = 'forward'\n      } = options;\n      var {\n        path,\n        offset\n      } = p;\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {\n              p.offset += op.text.length;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n};\n\nvar PointRef = {\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var point = Point.transform(current, op, {\n      affinity\n    });\n    ref.current = point;\n\n    if (point == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nvar _excluded$2 = [\"anchor\", \"focus\"];\n\nfunction ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Range = {\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\n  edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var {\n      anchor,\n      focus\n    } = range;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n\n  /**\r\n   * Get the end point of a range.\r\n   */\n  end(range) {\n    var [, end] = Range.edges(range);\n    return end;\n  },\n\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\n  equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\n  includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n\n      var [rs, re] = Range.edges(range);\n      var [ts, te] = Range.edges(target);\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n\n    var [start, end] = Range.edges(range);\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n\n    return isAfterStart && isBeforeEnd;\n  },\n\n  /**\r\n   * Get the intersection of a range with another.\r\n   */\n  intersection(range, another) {\n    var rest = _objectWithoutProperties(range, _excluded$2);\n\n    var [s1, e1] = Range.edges(range);\n    var [s2, e2] = Range.edges(another);\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$5({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\n  isBackward(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.isAfter(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\n  isCollapsed(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.equals(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\n  isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\n  isForward(range) {\n    return !Range.isBackward(range);\n  },\n\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\n  isRange(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n\n  /**\r\n   * Iterate through all of the point entries in a range.\r\n   */\n  *points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n\n  /**\r\n   * Get the start point of a range.\r\n   */\n  start(range) {\n    var [start] = Range.edges(range);\n    return start;\n  },\n\n  /**\r\n   * Transform a range by an operation.\r\n   */\n  transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(range, r => {\n      if (r === null) {\n        return null;\n      }\n\n      var {\n        affinity = 'inward'\n      } = options;\n      var affinityAnchor;\n      var affinityFocus;\n\n      if (affinity === 'inward') {\n        // If the range is collapsed, make sure to use the same affinity to\n        // avoid the two points passing each other and expanding in the opposite\n        // direction\n        var isCollapsed = Range.isCollapsed(r);\n\n        if (Range.isForward(r)) {\n          affinityAnchor = 'forward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'backward';\n        } else {\n          affinityAnchor = 'backward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'forward';\n        }\n      } else if (affinity === 'outward') {\n        if (Range.isForward(r)) {\n          affinityAnchor = 'backward';\n          affinityFocus = 'forward';\n        } else {\n          affinityAnchor = 'forward';\n          affinityFocus = 'backward';\n        }\n      } else {\n        affinityAnchor = affinity;\n        affinityFocus = affinity;\n      }\n\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n\n      if (!anchor || !focus) {\n        return null;\n      }\n\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n\n};\n\nvar RangeRef = {\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Range.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nvar _scrubber = undefined;\n/**\r\n * This interface implements a stringify() function, which is used by Slate\r\n * internally when generating exceptions containing end user data. Developers\r\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\r\n * stringify() function.\r\n *\r\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\r\n *\r\n *    import { Scrubber } from 'slate';\r\n *    Scrubber.setScrubber((key, val) => {\r\n *      if (key === 'text') return '...scrubbed...'\r\n *      return val\r\n *    });\r\n *\r\n */\n// eslint-disable-next-line no-redeclare\n\nvar Scrubber = {\n  setScrubber(scrubber) {\n    _scrubber = scrubber;\n  },\n\n  stringify(value) {\n    return JSON.stringify(value, _scrubber);\n  }\n\n};\n\n/*\r\n  Custom deep equal comparison for Slate nodes.\r\n\n  We don't need general purpose deep equality;\r\n  Slate only supports plain values, Arrays, and nested objects.\r\n  Complex values nested inside Arrays are not supported.\r\n\n  Slate objects are designed to be serialised, so\r\n  missing keys are deliberately normalised to undefined.\r\n */\n\nvar isDeepEqual = (node, another) => {\n  for (var key in node) {\n    var a = node[key];\n    var b = another[key];\n\n    if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(a) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(b)) {\n      if (!isDeepEqual(a, b)) return false;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n\n      for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false;\n      }\n    } else if (a !== b) {\n      return false;\n    }\n  }\n  /*\r\n    Deep object equality is only necessary in one direction; in the reverse direction\r\n    we are only looking for keys that are missing.\r\n    As above, undefined keys are normalised to missing.\r\n  */\n\n\n  for (var _key in another) {\n    if (node[_key] === undefined && another[_key] !== undefined) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar _excluded$1 = [\"text\"],\n    _excluded2$1 = [\"anchor\", \"focus\"];\n\nfunction ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Text = {\n  /**\r\n   * Check if two text nodes are equal.\r\n   *\r\n   * When loose is set, the text is not compared. This is\r\n   * used to check whether sibling text nodes can be merged.\r\n   */\n  equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      loose = false\n    } = options;\n\n    function omitText(obj) {\n      var rest = _objectWithoutProperties(obj, _excluded$1);\n\n      return rest;\n    }\n\n    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n  },\n\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\n  isText(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.text === 'string';\n  },\n\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\n  isTextList(value) {\n    return Array.isArray(value) && value.every(val => Text.isText(val));\n  },\n\n  /**\r\n   * Check if some props are a partial of Text.\r\n   */\n  isTextProps(props) {\n    return props.text !== undefined;\n  },\n\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */\n  matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Get the leaves for a text node given decorations.\r\n   */\n  decorations(node, decorations) {\n    var leaves = [_objectSpread$4({}, node)];\n\n    for (var dec of decorations) {\n      var rest = _objectWithoutProperties(dec, _excluded2$1);\n\n      var [start, end] = Range.edges(dec);\n      var next = [];\n      var leafEnd = 0;\n      var decorationStart = start.offset;\n      var decorationEnd = end.offset;\n\n      for (var leaf of leaves) {\n        var {\n          length\n        } = leaf.text;\n        var leafStart = leafEnd;\n        leafEnd += length; // If the range encompasses the entire leaf, add the range.\n\n        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n          Object.assign(leaf, rest);\n          next.push(leaf);\n          continue;\n        } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n\n\n        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n          next.push(leaf);\n          continue;\n        } // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n\n\n        var middle = leaf;\n        var before = void 0;\n        var after = void 0;\n\n        if (decorationEnd < leafEnd) {\n          var off = decorationEnd - leafStart;\n          after = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(off)\n          });\n          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(0, off)\n          });\n        }\n\n        if (decorationStart > leafStart) {\n          var _off = decorationStart - leafStart;\n\n          before = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(0, _off)\n          });\n          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(_off)\n          });\n        }\n\n        Object.assign(middle, rest);\n\n        if (before) {\n          next.push(before);\n        }\n\n        next.push(middle);\n\n        if (after) {\n          next.push(after);\n        }\n      }\n\n      leaves = next;\n    }\n\n    return leaves;\n  }\n\n};\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar applyToDraft = (editor, selection, op) => {\n  switch (op.type) {\n    case 'insert_node':\n      {\n        var {\n          path,\n          node\n        } = op;\n        var parent = Node.parent(editor, path);\n        var index = path[path.length - 1];\n\n        if (index > parent.children.length) {\n          throw new Error(\"Cannot apply an \\\"insert_node\\\" operation at path [\".concat(path, \"] because the destination is past the end of the node.\"));\n        }\n\n        parent.children.splice(index, 0, node);\n\n        if (selection) {\n          for (var [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'insert_text':\n      {\n        var {\n          path: _path,\n          offset,\n          text\n        } = op;\n        if (text.length === 0) break;\n\n        var _node = Node.leaf(editor, _path);\n\n        var before = _node.text.slice(0, offset);\n\n        var after = _node.text.slice(offset);\n\n        _node.text = before + text + after;\n\n        if (selection) {\n          for (var [_point, _key] of Range.points(selection)) {\n            selection[_key] = Point.transform(_point, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'merge_node':\n      {\n        var {\n          path: _path2\n        } = op;\n\n        var _node2 = Node.get(editor, _path2);\n\n        var prevPath = Path.previous(_path2);\n        var prev = Node.get(editor, prevPath);\n\n        var _parent = Node.parent(editor, _path2);\n\n        var _index = _path2[_path2.length - 1];\n\n        if (Text.isText(_node2) && Text.isText(prev)) {\n          prev.text += _node2.text;\n        } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n          prev.children.push(..._node2.children);\n        } else {\n          throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n        }\n\n        _parent.children.splice(_index, 1);\n\n        if (selection) {\n          for (var [_point2, _key2] of Range.points(selection)) {\n            selection[_key2] = Point.transform(_point2, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'move_node':\n      {\n        var {\n          path: _path3,\n          newPath\n        } = op;\n\n        if (Path.isAncestor(_path3, newPath)) {\n          throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n        }\n\n        var _node3 = Node.get(editor, _path3);\n\n        var _parent2 = Node.parent(editor, _path3);\n\n        var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n\n        _parent2.children.splice(_index2, 1);\n\n        var truePath = Path.transform(_path3, op);\n        var newParent = Node.get(editor, Path.parent(truePath));\n        var newIndex = truePath[truePath.length - 1];\n        newParent.children.splice(newIndex, 0, _node3);\n\n        if (selection) {\n          for (var [_point3, _key3] of Range.points(selection)) {\n            selection[_key3] = Point.transform(_point3, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_node':\n      {\n        var {\n          path: _path4\n        } = op;\n        var _index3 = _path4[_path4.length - 1];\n\n        var _parent3 = Node.parent(editor, _path4);\n\n        _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n\n\n        if (selection) {\n          for (var [_point4, _key4] of Range.points(selection)) {\n            var result = Point.transform(_point4, op);\n\n            if (selection != null && result != null) {\n              selection[_key4] = result;\n            } else {\n              var _prev = void 0;\n\n              var next = void 0;\n\n              for (var [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, _path4) === -1) {\n                  _prev = [n, p];\n                } else {\n                  next = [n, p];\n                  break;\n                }\n              }\n\n              var preferNext = false;\n\n              if (_prev && next) {\n                if (Path.equals(next[1], _path4)) {\n                  preferNext = !Path.hasPrevious(next[1]);\n                } else {\n                  preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                }\n              }\n\n              if (_prev && !preferNext) {\n                _point4.path = _prev[1];\n                _point4.offset = _prev[0].text.length;\n              } else if (next) {\n                _point4.path = next[1];\n                _point4.offset = 0;\n              } else {\n                selection = null;\n              }\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_text':\n      {\n        var {\n          path: _path5,\n          offset: _offset,\n          text: _text\n        } = op;\n        if (_text.length === 0) break;\n\n        var _node4 = Node.leaf(editor, _path5);\n\n        var _before = _node4.text.slice(0, _offset);\n\n        var _after = _node4.text.slice(_offset + _text.length);\n\n        _node4.text = _before + _after;\n\n        if (selection) {\n          for (var [_point5, _key5] of Range.points(selection)) {\n            selection[_key5] = Point.transform(_point5, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'set_node':\n      {\n        var {\n          path: _path6,\n          properties,\n          newProperties\n        } = op;\n\n        if (_path6.length === 0) {\n          throw new Error(\"Cannot set properties on the root node!\");\n        }\n\n        var _node5 = Node.get(editor, _path6);\n\n        for (var _key6 in newProperties) {\n          if (_key6 === 'children' || _key6 === 'text') {\n            throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n          }\n\n          var value = newProperties[_key6];\n\n          if (value == null) {\n            delete _node5[_key6];\n          } else {\n            _node5[_key6] = value;\n          }\n        } // properties that were previously defined, but are now missing, must be deleted\n\n\n        for (var _key7 in properties) {\n          if (!newProperties.hasOwnProperty(_key7)) {\n            delete _node5[_key7];\n          }\n        }\n\n        break;\n      }\n\n    case 'set_selection':\n      {\n        var {\n          newProperties: _newProperties\n        } = op;\n\n        if (_newProperties == null) {\n          selection = _newProperties;\n        } else {\n          if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n\n            selection = _objectSpread$3({}, _newProperties);\n          }\n\n          for (var _key8 in _newProperties) {\n            var _value = _newProperties[_key8];\n\n            if (_value == null) {\n              if (_key8 === 'anchor' || _key8 === 'focus') {\n                throw new Error(\"Cannot remove the \\\"\".concat(_key8, \"\\\" selection property\"));\n              }\n\n              delete selection[_key8];\n            } else {\n              selection[_key8] = _value;\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'split_node':\n      {\n        var {\n          path: _path7,\n          position,\n          properties: _properties\n        } = op;\n\n        if (_path7.length === 0) {\n          throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n        }\n\n        var _node6 = Node.get(editor, _path7);\n\n        var _parent4 = Node.parent(editor, _path7);\n\n        var _index4 = _path7[_path7.length - 1];\n        var newNode;\n\n        if (Text.isText(_node6)) {\n          var _before2 = _node6.text.slice(0, position);\n\n          var _after2 = _node6.text.slice(position);\n\n          _node6.text = _before2;\n          newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n            text: _after2\n          });\n        } else {\n          var _before3 = _node6.children.slice(0, position);\n\n          var _after3 = _node6.children.slice(position);\n\n          _node6.children = _before3;\n          newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n            children: _after3\n          });\n        }\n\n        _parent4.children.splice(_index4 + 1, 0, newNode);\n\n        if (selection) {\n          for (var [_point6, _key9] of Range.points(selection)) {\n            selection[_key9] = Point.transform(_point6, op);\n          }\n        }\n\n        break;\n      }\n  }\n\n  return selection;\n}; // eslint-disable-next-line no-redeclare\n\n\nvar GeneralTransforms = {\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform(editor, op) {\n    editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.children);\n    var selection = editor.selection && (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.selection);\n\n    try {\n      selection = applyToDraft(editor, selection, op);\n    } finally {\n      editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(editor.children);\n\n      if (selection) {\n        editor.selection = (0,immer__WEBPACK_IMPORTED_MODULE_1__.isDraft)(selection) ? (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(selection) : selection;\n      } else {\n        editor.selection = null;\n      }\n    }\n  }\n\n};\n\nvar _excluded = [\"text\"],\n    _excluded2 = [\"children\"];\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar NodeTransforms = {\n  /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */\n  insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n      var {\n        at,\n        match,\n        select\n      } = options;\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes];\n      }\n\n      if (nodes.length === 0) {\n        return;\n      }\n\n      var [node] = nodes; // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection;\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, []);\n        } else {\n          at = [0];\n        }\n\n        select = true;\n      }\n\n      if (select == null) {\n        select = false;\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = Range.edges(at);\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n);\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n);\n          } else {\n            match = n => Editor.isBlock(editor, n);\n          }\n        }\n\n        var [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids\n        });\n\n        if (entry) {\n          var [, _matchPath] = entry;\n          var pathRef = Editor.pathRef(editor, _matchPath);\n          var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n          Transforms.splitNodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n          });\n          var path = pathRef.unref();\n          at = isAtEnd ? Path.next(path) : path;\n        } else {\n          return;\n        }\n      }\n\n      var parentPath = Path.parent(at);\n      var index = at[at.length - 1];\n\n      if (!voids && Editor.void(editor, {\n        at: parentPath\n      })) {\n        return;\n      }\n\n      for (var _node of nodes) {\n        var _path = parentPath.concat(index);\n\n        index++;\n        editor.apply({\n          type: 'insert_node',\n          path: _path,\n          node: _node\n        });\n        at = Path.next(at);\n      }\n\n      at = Path.previous(at);\n\n      if (select) {\n        var point = Editor.end(editor, at);\n\n        if (point) {\n          Transforms.select(editor, point);\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\n  liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match\n      } = options;\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var matches = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(matches, _ref => {\n        var [, p] = _ref;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n\n        if (path.length < 2) {\n          throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n        }\n\n        var parentNodeEntry = Editor.node(editor, Path.parent(path));\n        var [parent, parentPath] = parentNodeEntry;\n        var index = path[path.length - 1];\n        var {\n          length\n        } = parent.children;\n\n        if (length === 1) {\n          var toPath = Path.next(parentPath);\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: toPath,\n            voids\n          });\n          Transforms.removeNodes(editor, {\n            at: parentPath,\n            voids\n          });\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: parentPath,\n            voids\n          });\n        } else if (index === length - 1) {\n          var _toPath = Path.next(parentPath);\n\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath,\n            voids\n          });\n        } else {\n          var splitPath = Path.next(path);\n\n          var _toPath2 = Path.next(parentPath);\n\n          Transforms.splitNodes(editor, {\n            at: splitPath,\n            voids\n          });\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath2,\n            voids\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\n  mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        match,\n        at = editor.selection\n      } = options;\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var [parent] = Editor.parent(editor, at);\n\n          match = n => parent.children.includes(n);\n        } else {\n          match = n => Editor.isBlock(editor, n);\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = Range.edges(at);\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n\n          if (options.at == null) {\n            Transforms.select(editor, at);\n          }\n        }\n      }\n\n      var [current] = Editor.nodes(editor, {\n        at,\n        match,\n        voids,\n        mode\n      });\n      var prev = Editor.previous(editor, {\n        at,\n        match,\n        voids,\n        mode\n      });\n\n      if (!current || !prev) {\n        return;\n      }\n\n      var [node, path] = current;\n      var [prevNode, prevPath] = prev;\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return;\n      }\n\n      var newPath = Path.next(prevPath);\n      var commonPath = Path.common(path, prevPath);\n      var isPreviousSibling = Path.isSibling(path, prevPath);\n      var levels = Array.from(Editor.levels(editor, {\n        at: path\n      }), _ref2 => {\n        var [n] = _ref2;\n        return n;\n      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n\n      var emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n => levels.includes(n) && hasSingleChildNest(editor, n)\n      });\n      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n      var properties;\n      var position; // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        var rest = _objectWithoutProperties(node, _excluded);\n\n        position = prevNode.text.length;\n        properties = rest;\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        var rest = _objectWithoutProperties(node, _excluded2);\n\n        position = prevNode.children.length;\n        properties = rest;\n      } else {\n        throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n      } // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n\n\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: newPath,\n          voids\n        });\n      } // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n\n\n      if (emptyRef) {\n        Transforms.removeNodes(editor, {\n          at: emptyRef.current,\n          voids\n        });\n      } // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      // if prevNode is first child in parent,don't remove it.\n\n\n      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0) {\n        Transforms.removeNodes(editor, {\n          at: prevPath,\n          voids\n        });\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          properties\n        });\n      }\n\n      if (emptyRef) {\n        emptyRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\n  moveNodes(editor, options) {\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      var toRef = Editor.pathRef(editor, to);\n      var targets = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(targets, _ref3 => {\n        var [, p] = _ref3;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n        var newPath = toRef.current;\n\n        if (path.length !== 0) {\n          editor.apply({\n            type: 'move_node',\n            path,\n            newPath\n          });\n        }\n\n        if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n          // When performing a sibling move to a later index, the path at the destination is shifted\n          // to before the insertion point instead of after. To ensure our group of nodes are inserted\n          // in the correct order we increment toRef to account for that\n          toRef.current = Path.next(toRef.current);\n        }\n      }\n\n      toRef.unref();\n    });\n  },\n\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\n  removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n      var {\n        at = editor.selection,\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      var depths = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(depths, _ref4 => {\n        var [, p] = _ref4;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n\n        if (path) {\n          var [node] = Editor.node(editor, path);\n          editor.apply({\n            type: 'remove_node',\n            path,\n            node\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Set new properties on the nodes at a location.\r\n   */\n  setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        match,\n        at = editor.selection,\n        compare,\n        merge\n      } = options;\n      var {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (split && Range.isRange(at)) {\n        if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n          // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n          // set that won't get normalized away\n          return;\n        }\n\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        var [start, end] = Range.edges(at);\n        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n        var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids,\n          always: !endAtEndOfNode\n        });\n        var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids,\n          always: !startAtStartOfNode\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      if (!compare) {\n        compare = (prop, nodeProp) => prop !== nodeProp;\n      }\n\n      for (var [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      })) {\n        var properties = {};\n        var newProperties = {}; // You can't set properties on the editor node.\n\n        if (path.length === 0) {\n          continue;\n        }\n\n        var hasChanges = false;\n\n        for (var k in props) {\n          if (k === 'children' || k === 'text') {\n            continue;\n          }\n\n          if (compare(props[k], node[k])) {\n            hasChanges = true; // Omit new properties from the old properties list\n\n            if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list\n\n            if (merge) {\n              if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n            } else {\n              if (props[k] != null) newProperties[k] = props[k];\n            }\n          }\n        }\n\n        if (hasChanges) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\n  splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match,\n        at = editor.selection,\n        height = 0,\n        always = false\n      } = options;\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n);\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at);\n      } // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n\n\n      if (Path.isPath(at)) {\n        var path = at;\n        var point = Editor.point(editor, path);\n        var [parent] = Editor.parent(editor, path);\n\n        match = n => n === parent;\n\n        height = point.path.length - path.length + 1;\n        at = point;\n        always = true;\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward'\n      });\n      var afterRef;\n\n      try {\n        var [highest] = Editor.nodes(editor, {\n          at,\n          match,\n          mode,\n          voids\n        });\n\n        if (!highest) {\n          return;\n        }\n\n        var voidMatch = Editor.void(editor, {\n          at,\n          mode: 'highest'\n        });\n        var nudge = 0;\n\n        if (!voids && voidMatch) {\n          var [voidNode, voidPath] = voidMatch;\n\n          if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n            var after = Editor.after(editor, voidPath);\n\n            if (!after) {\n              var text = {\n                text: ''\n              };\n              var afterPath = Path.next(voidPath);\n              Transforms.insertNodes(editor, text, {\n                at: afterPath,\n                voids\n              });\n              after = Editor.point(editor, afterPath);\n            }\n\n            at = after;\n            always = true;\n          }\n\n          var siblingHeight = at.path.length - voidPath.length;\n          height = siblingHeight + 1;\n          always = true;\n        }\n\n        afterRef = Editor.pointRef(editor, at);\n        var depth = at.path.length - height;\n        var [, highestPath] = highest;\n        var lowestPath = at.path.slice(0, depth);\n        var position = height === 0 ? at.offset : at.path[depth] + nudge;\n\n        for (var [node, _path2] of Editor.levels(editor, {\n          at: lowestPath,\n          reverse: true,\n          voids\n        })) {\n          var split = false;\n\n          if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {\n            break;\n          }\n\n          var _point = beforeRef.current;\n          var isEnd = Editor.isEnd(editor, _point, _path2);\n\n          if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {\n            split = true;\n            var properties = Node.extractProps(node);\n            editor.apply({\n              type: 'split_node',\n              path: _path2,\n              position,\n              properties\n            });\n          }\n\n          position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n        }\n\n        if (options.at == null) {\n          var _point2 = afterRef.current || Editor.end(editor, []);\n\n          Transforms.select(editor, _point2);\n        }\n      } finally {\n        var _afterRef;\n\n        beforeRef.unref();\n        (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Unset properties on the nodes at a location.\r\n   */\n  unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!Array.isArray(props)) {\n      props = [props];\n    }\n\n    var obj = {};\n\n    for (var key of props) {\n      obj[key] = null;\n    }\n\n    Transforms.setNodes(editor, obj, options);\n  },\n\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\n  unwrapNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection,\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n      var matches = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(matches, _ref5 => {\n        var [, p] = _ref5;\n        return Editor.pathRef(editor, p);\n      } // unwrapNode will call liftNode which does not support splitting the node when nested.\n      // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n      // that wrap target node. So we reverse the order.\n      ).reverse();\n\n      var _loop = function _loop(pathRef) {\n        var path = pathRef.unref();\n        var [node] = Editor.node(editor, path);\n        var range = Editor.range(editor, path);\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current, range);\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => Element.isAncestor(node) && node.children.includes(n),\n          voids\n        });\n      };\n\n      for (var pathRef of pathRefs) {\n        _loop(pathRef);\n      }\n\n      if (rangeRef) {\n        rangeRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\n  wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n      var {\n        match,\n        at = editor.selection\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at);\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n);\n        } else {\n          match = n => Editor.isBlock(editor, n);\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        var [start, end] = Range.edges(at);\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var roots = Array.from(Editor.nodes(editor, {\n        at,\n        match: editor.isInline(element) ? n => Editor.isBlock(editor, n) : n => Editor.isEditor(n),\n        mode: 'lowest',\n        voids\n      }));\n\n      for (var [, rootPath] of roots) {\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n\n        if (!a) {\n          continue;\n        }\n\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match,\n          mode,\n          voids\n        }));\n\n        if (matches.length > 0) {\n          var _ret = function () {\n            var [first] = matches;\n            var last = matches[matches.length - 1];\n            var [, firstPath] = first;\n            var [, lastPath] = last;\n\n            if (firstPath.length === 0 && lastPath.length === 0) {\n              // if there's no matching parent - usually means the node is an editor - don't do anything\n              return \"continue\";\n            }\n\n            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n            var range = Editor.range(editor, firstPath, lastPath);\n            var commonNodeEntry = Editor.node(editor, commonPath);\n            var [commonNode] = commonNodeEntry;\n            var depth = commonPath.length + 1;\n            var wrapperPath = Path.next(lastPath.slice(0, depth));\n\n            var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {\n              children: []\n            });\n\n            Transforms.insertNodes(editor, wrapper, {\n              at: wrapperPath,\n              voids\n            });\n            Transforms.moveNodes(editor, {\n              at: range,\n              match: n => Element.isAncestor(commonNode) && commonNode.children.includes(n),\n              to: wrapperPath.concat(0),\n              voids\n            });\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n      }\n    });\n  }\n\n};\n\nvar hasSingleChildNest = (editor, node) => {\n  if (Element.isElement(node)) {\n    var element = node;\n\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\n\n\nvar deleteRange = (editor, range) => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var [, end] = Range.edges(range);\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms.delete(editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\n\nvar matchPath = (editor, path) => {\n  var [node] = Editor.node(editor, path);\n  return n => n === node;\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar SelectionTransforms = {\n  /**\r\n   * Collapse the selection.\r\n   */\n  collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      edge = 'anchor'\n    } = options;\n    var {\n      selection\n    } = editor;\n\n    if (!selection) {\n      return;\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor);\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus);\n    } else if (edge === 'start') {\n      var [start] = Range.edges(selection);\n      Transforms.select(editor, start);\n    } else if (edge === 'end') {\n      var [, end] = Range.edges(selection);\n      Transforms.select(editor, end);\n    }\n  },\n\n  /**\r\n   * Unset the selection.\r\n   */\n  deselect(editor) {\n    var {\n      selection\n    } = editor;\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null\n      });\n    }\n  },\n\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\n  move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      selection\n    } = editor;\n    var {\n      distance = 1,\n      unit = 'character',\n      reverse = false\n    } = options;\n    var {\n      edge = null\n    } = options;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var {\n      anchor,\n      focus\n    } = selection;\n    var opts = {\n      distance,\n      unit\n    };\n    var props = {};\n\n    if (edge == null || edge === 'anchor') {\n      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n\n      if (point) {\n        props.anchor = point;\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n\n      if (_point) {\n        props.focus = _point;\n      }\n    }\n\n    Transforms.setSelection(editor, props);\n  },\n\n  /**\r\n   * Set the selection to a new value.\r\n   */\n  select(editor, target) {\n    var {\n      selection\n    } = editor;\n    target = Editor.range(editor, target);\n\n    if (selection) {\n      Transforms.setSelection(editor, target);\n      return;\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target\n    });\n  },\n\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\n  setPoint(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      selection\n    } = editor;\n    var {\n      edge = 'both'\n    } = options;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var {\n      anchor,\n      focus\n    } = selection;\n    var point = edge === 'anchor' ? anchor : focus;\n    Transforms.setSelection(editor, {\n      [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$1(_objectSpread$1({}, point), props)\n    });\n  },\n\n  /**\r\n   * Set new properties on the selection.\r\n   */\n  setSelection(editor, props) {\n    var {\n      selection\n    } = editor;\n    var oldProps = {};\n    var newProps = {};\n\n    if (!selection) {\n      return;\n    }\n\n    for (var k in props) {\n      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n        oldProps[k] = selection[k];\n        newProps[k] = props[k];\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps\n      });\n    }\n  }\n\n};\n\nvar TextTransforms = {\n  /**\r\n   * Delete content in the editor.\r\n   */\n  delete(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection,\n        hanging = false\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      var isCollapsed = false;\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        isCollapsed = true;\n        at = at.anchor;\n      }\n\n      if (Point.isPoint(at)) {\n        var furthestVoid = Editor.void(editor, {\n          at,\n          mode: 'highest'\n        });\n\n        if (!voids && furthestVoid) {\n          var [, voidPath] = furthestVoid;\n          at = voidPath;\n        } else {\n          var opts = {\n            unit,\n            distance\n          };\n          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n          at = {\n            anchor: at,\n            focus: target\n          };\n          hanging = true;\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, {\n          at,\n          voids\n        });\n        return;\n      }\n\n      if (Range.isCollapsed(at)) {\n        return;\n      }\n\n      if (!hanging) {\n        var [, _end] = Range.edges(at);\n        var endOfDoc = Editor.end(editor, []);\n\n        if (!Point.equals(_end, endOfDoc)) {\n          at = Editor.unhangRange(editor, at, {\n            voids\n          });\n        }\n      }\n\n      var [start, end] = Range.edges(at);\n      var startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids\n      });\n      var endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids\n      });\n      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n      var isSingleText = Path.equals(start.path, end.path);\n      var startVoid = voids ? null : Editor.void(editor, {\n        at: start,\n        mode: 'highest'\n      });\n      var endVoid = voids ? null : Editor.void(editor, {\n        at: end,\n        mode: 'highest'\n      }); // If the start or end points are inside an inline void, nudge them out.\n\n      if (startVoid) {\n        var before = Editor.before(editor, start);\n\n        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n          start = before;\n        }\n      }\n\n      if (endVoid) {\n        var after = Editor.after(editor, end);\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after;\n        }\n      } // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n\n\n      var matches = [];\n      var lastPath;\n\n      for (var entry of Editor.nodes(editor, {\n        at,\n        voids\n      })) {\n        var [node, path] = entry;\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue;\n        }\n\n        if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n          matches.push(entry);\n          lastPath = path;\n        }\n      }\n\n      var pathRefs = Array.from(matches, _ref => {\n        var [, p] = _ref;\n        return Editor.pathRef(editor, p);\n      });\n      var startRef = Editor.pointRef(editor, start);\n      var endRef = Editor.pointRef(editor, end);\n      var removedText = '';\n\n      if (!isSingleText && !startVoid) {\n        var _point = startRef.current;\n        var [_node] = Editor.leaf(editor, _point);\n        var {\n          path: _path\n        } = _point;\n        var {\n          offset\n        } = start;\n\n        var text = _node.text.slice(offset);\n\n        if (text.length > 0) {\n          editor.apply({\n            type: 'remove_text',\n            path: _path,\n            offset,\n            text\n          });\n          removedText = text;\n        }\n      }\n\n      for (var pathRef of pathRefs) {\n        var _path2 = pathRef.unref();\n\n        Transforms.removeNodes(editor, {\n          at: _path2,\n          voids\n        });\n      }\n\n      if (!endVoid) {\n        var _point2 = endRef.current;\n        var [_node2] = Editor.leaf(editor, _point2);\n        var {\n          path: _path3\n        } = _point2;\n\n        var _offset = isSingleText ? start.offset : 0;\n\n        var _text = _node2.text.slice(_offset, end.offset);\n\n        if (_text.length > 0) {\n          editor.apply({\n            type: 'remove_text',\n            path: _path3,\n            offset: _offset,\n            text: _text\n          });\n          removedText = _text;\n        }\n      }\n\n      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids\n        });\n      } // For Thai script, deleting N character(s) backward should delete\n      // N code point(s) instead of an entire grapheme cluster.\n      // Therefore, the remaining code points should be inserted back.\n\n\n      if (isCollapsed && reverse && unit === 'character' && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n        Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n      }\n\n      var startUnref = startRef.unref();\n      var endUnref = endRef.unref();\n      var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point);\n      }\n    });\n  },\n\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\n  insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection\n      } = options;\n\n      if (!fragment.length) {\n        return;\n      }\n\n      if (!at) {\n        return;\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = Range.edges(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at);\n      }\n\n      if (!voids && Editor.void(editor, {\n        at\n      })) {\n        return;\n      } // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n\n\n      var inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (inlineElementMatch) {\n        var [, _inlinePath] = inlineElementMatch;\n\n        if (Editor.isEnd(editor, at, _inlinePath)) {\n          var after = Editor.after(editor, _inlinePath);\n          at = after;\n        } else if (Editor.isStart(editor, at, _inlinePath)) {\n          var before = Editor.before(editor, _inlinePath);\n          at = before;\n        }\n      }\n\n      var blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids\n      });\n      var [, blockPath] = blockMatch;\n      var isBlockStart = Editor.isStart(editor, at, blockPath);\n      var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n      var isBlockEmpty = isBlockStart && isBlockEnd;\n      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n      var mergeEnd = !isBlockEnd;\n      var [, firstPath] = Node.first({\n        children: fragment\n      }, []);\n      var [, lastPath] = Node.last({\n        children: fragment\n      }, []);\n      var matches = [];\n\n      var matcher = _ref2 => {\n        var [n, p] = _ref2;\n        var isRoot = p.length === 0;\n\n        if (isRoot) {\n          return false;\n        }\n\n        if (isBlockEmpty) {\n          return true;\n        }\n\n        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        return true;\n      };\n\n      for (var entry of Node.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })) {\n        if (matcher(entry)) {\n          matches.push(entry);\n        }\n      }\n\n      var starts = [];\n      var middles = [];\n      var ends = [];\n      var starting = true;\n      var hasBlocks = false;\n\n      for (var [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          hasBlocks = true;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n\n      var [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n      var [, inlinePath] = inlineMatch;\n      var isInlineStart = Editor.isStart(editor, at, inlinePath);\n      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n      var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.splitNodes(editor, {\n        at,\n        match: n => hasBlocks ? Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n        voids\n      });\n      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n        Transforms.delete(editor, {\n          at: blockPath,\n          voids\n        });\n      }\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids\n      });\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (!options.at) {\n        var path;\n\n        if (ends.length > 0 && endRef.current) {\n          path = Path.previous(endRef.current);\n        } else if (middles.length > 0 && middleRef.current) {\n          path = Path.previous(middleRef.current);\n        } else if (startRef.current) {\n          path = Path.previous(startRef.current);\n        }\n\n        if (path) {\n          var _end2 = Editor.end(editor, path);\n\n          Transforms.select(editor, _end2);\n        }\n      }\n\n      startRef.unref();\n      middleRef.unref();\n      endRef.unref();\n    });\n  },\n\n  /**\r\n   * Insert a string of text in the Editor.\r\n   */\n  insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        voids = false\n      } = options;\n      var {\n        at = editor.selection\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var start = Range.start(at);\n          var startRef = Editor.pointRef(editor, start);\n          var endRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at,\n            voids\n          });\n          var startPoint = startRef.unref();\n          var endPoint = endRef.unref();\n          at = startPoint || endPoint;\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n\n      if (!voids && Editor.void(editor, {\n        at\n      })) {\n        return;\n      }\n\n      var {\n        path,\n        offset\n      } = at;\n      if (text.length > 0) editor.apply({\n        type: 'insert_text',\n        path,\n        offset,\n        text\n      });\n    });\n  }\n\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc2xhdGVAMC44Mi4wL25vZGVfbW9kdWxlcy9zbGF0ZS9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNtQjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxtREFBbUQsbUZBQW1GLE9BQU87QUFDNWdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWLHdEQUF3RCw0QkFBNEIsS0FBSztBQUN6RjtBQUNBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7OztBQUdSLHNOQUFzTjtBQUN0Tjs7QUFFQTs7QUFFQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVix3Q0FBd0MsNEJBQTRCOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEIsbUJBQW1COztBQUVuQix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDhEQUFhO0FBQ3RCLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUFhO0FBQ3hCLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFN1UsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSx5REFBeUQsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLG1EQUFtRCxtRkFBbUYsT0FBTztBQUM1Z0IscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLDZFQUE2RSxjQUFjO0FBQzNGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSw2RUFBNkUsY0FBYztBQUMzRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDhEQUFhO0FBQ3RCO0FBQ0E7O0FBRUEsMHFCQUEwcUIsOERBQWE7QUFDdnJCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDOzs7QUFHL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxPQUFPO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQSxZQUFZOzs7QUFHWjtBQUNBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGNBQWM7QUFDaEY7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDhDQUFPO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxtREFBbUQsbUZBQW1GLE9BQU87O0FBRTVnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBYTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGLDhEQUFhOztBQUU3RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyw4REFBYSxzQkFBc0IsOERBQWE7O0FBRTFGO0FBQ0EscUpBQXFKLDhEQUFhLHNCQUFzQiw4REFBYTs7QUFFck07QUFDQSxnRkFBZ0YsOERBQWE7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNOztBQUVsQjtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7QUFHQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1oscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1oscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBTztBQUNsQjtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkNBQTZDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELHNCQUFzQiwwQ0FBMEMsaUVBQWlFLEtBQUssa0NBQWtDOztBQUU3VSxtQ0FBbUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHlEQUF5RCw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8sbURBQW1ELG1GQUFtRixPQUFPOztBQUU1Z0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQWE7QUFDeEIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG9GQUFvRixjQUFjO0FBQ2xHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFN1UsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSx5REFBeUQsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLG1EQUFtRCxtRkFBbUYsT0FBTzs7QUFFNWdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQWE7QUFDeEIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSw4REFBYSxPQUFPLDhEQUFhO0FBQ3pDO0FBQ0EsTUFBTTtBQUNOOztBQUVBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxtREFBbUQsbUZBQW1GLE9BQU87O0FBRTVnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4REFBYTtBQUN4QixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0EsV0FBVztBQUNYLHFEQUFxRCxhQUFhO0FBQ2xFO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUEscURBQXFELGFBQWE7QUFDbEU7QUFDQSxXQUFXO0FBQ1gscURBQXFELGFBQWE7QUFDbEU7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxtREFBbUQsbUZBQW1GLE9BQU87O0FBRTVnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUEsOENBQThDO0FBQzlDOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzREFBc0Qsa0JBQWtCO0FBQ3hFO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEU7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtEQUFXO0FBQ2pDLHdDQUF3QyxrREFBVzs7QUFFbkQ7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0Isa0RBQVc7O0FBRW5DO0FBQ0EsMkJBQTJCLDhDQUFPLGNBQWMsa0RBQVc7QUFDM0QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELHNCQUFzQiwwQ0FBMEMsaUVBQWlFLEtBQUssa0NBQWtDOztBQUU3VSxtQ0FBbUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHlEQUF5RCw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8sbURBQW1ELG1GQUFtRixPQUFPOztBQUU1Z0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU8seUNBQXlDO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0IsaUVBQWlFOztBQUVqRTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTRELGNBQWM7QUFDMUU7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFN1UsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSx5REFBeUQsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLG1EQUFtRCxtRkFBbUYsT0FBTzs7QUFFNWdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGtGQUFrRjtBQUNsRixLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBOztBQUVBLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFM1UsaUNBQWlDLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSx1REFBdUQsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLGlEQUFpRCxtRkFBbUYsT0FBTztBQUN0Z0IsMkVBQTJFOztBQUU0RTtBQUN2SiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2thZWwvRG9jdW1lbnRzL2dhbGFkcmltL3Jpc2UvY21zX3Jlc2VhcmNoL3BheWxvYWQvcmlzZS9ub2RlX21vZHVsZXMvLnBucG0vc2xhdGVAMC44Mi4wL25vZGVfbW9kdWxlcy9zbGF0ZS9kaXN0L2luZGV4LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICdpcy1wbGFpbi1vYmplY3QnO1xuaW1wb3J0IHsgcHJvZHVjZSwgY3JlYXRlRHJhZnQsIGZpbmlzaERyYWZ0LCBpc0RyYWZ0IH0gZnJvbSAnaW1tZXInO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIERJUlRZX1BBVEhTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBESVJUWV9QQVRIX0tFWVMgPSBuZXcgV2Vha01hcCgpO1xudmFyIEZMVVNISU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT1JNQUxJWklORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUEFUSF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQT0lOVF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBSQU5HRV9SRUZTID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gb3duS2V5cyQ5KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ5KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkOShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDkoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IFNsYXRlIGBFZGl0b3JgIG9iamVjdC5cclxuICovXG5cbnZhciBjcmVhdGVFZGl0b3IgPSAoKSA9PiB7XG4gIHZhciBlZGl0b3IgPSB7XG4gICAgY2hpbGRyZW46IFtdLFxuICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgIHNlbGVjdGlvbjogbnVsbCxcbiAgICBtYXJrczogbnVsbCxcbiAgICBpc0lubGluZTogKCkgPT4gZmFsc2UsXG4gICAgaXNWb2lkOiAoKSA9PiBmYWxzZSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge30sXG4gICAgYXBwbHk6IG9wID0+IHtcbiAgICAgIGZvciAodmFyIHJlZiBvZiBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKSkge1xuICAgICAgICBQYXRoUmVmLnRyYW5zZm9ybShyZWYsIG9wKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX3JlZiBvZiBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcikpIHtcbiAgICAgICAgUG9pbnRSZWYudHJhbnNmb3JtKF9yZWYsIG9wKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX3JlZjIgb2YgRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpKSB7XG4gICAgICAgIFJhbmdlUmVmLnRyYW5zZm9ybShfcmVmMiwgb3ApO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2xkRGlydHlQYXRocyA9IERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICAgICAgdmFyIG9sZERpcnR5UGF0aEtleXMgPSBESVJUWV9QQVRIX0tFWVMuZ2V0KGVkaXRvcikgfHwgbmV3IFNldCgpO1xuICAgICAgdmFyIGRpcnR5UGF0aHM7XG4gICAgICB2YXIgZGlydHlQYXRoS2V5cztcblxuICAgICAgdmFyIGFkZCA9IHBhdGggPT4ge1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcblxuICAgICAgICAgIGlmICghZGlydHlQYXRoS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgZGlydHlQYXRoS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGRpcnR5UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChQYXRoLm9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgob3ApKSB7XG4gICAgICAgIGRpcnR5UGF0aHMgPSBbXTtcbiAgICAgICAgZGlydHlQYXRoS2V5cyA9IG5ldyBTZXQoKTtcblxuICAgICAgICBmb3IgKHZhciBwYXRoIG9mIG9sZERpcnR5UGF0aHMpIHtcbiAgICAgICAgICB2YXIgbmV3UGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKTtcbiAgICAgICAgICBhZGQobmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcnR5UGF0aHMgPSBvbGREaXJ0eVBhdGhzO1xuICAgICAgICBkaXJ0eVBhdGhLZXlzID0gb2xkRGlydHlQYXRoS2V5cztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0RpcnR5UGF0aHMgPSBnZXREaXJ0eVBhdGhzKG9wKTtcblxuICAgICAgZm9yICh2YXIgX3BhdGggb2YgbmV3RGlydHlQYXRocykge1xuICAgICAgICBhZGQoX3BhdGgpO1xuICAgICAgfVxuXG4gICAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhzKTtcbiAgICAgIERJUlRZX1BBVEhfS0VZUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhLZXlzKTtcbiAgICAgIFRyYW5zZm9ybXMudHJhbnNmb3JtKGVkaXRvciwgb3ApO1xuICAgICAgZWRpdG9yLm9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7IC8vIENsZWFyIGFueSBmb3JtYXRzIGFwcGxpZWQgdG8gdGhlIGN1cnNvciBpZiB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuXG5cbiAgICAgIGlmIChvcC50eXBlID09PSAnc2V0X3NlbGVjdGlvbicpIHtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICBGTFVTSElORy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIGVkaXRvci5vcGVyYXRpb25zID0gW107XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkTWFyazogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ5KF9vYmplY3RTcHJlYWQkOSh7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pLCB7fSwge1xuICAgICAgICAgICAgW2tleV06IHZhbHVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcblxuICAgICAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlQmFja3dhcmQ6IHVuaXQgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgdW5pdCxcbiAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlRm9yd2FyZDogdW5pdCA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICB1bml0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlRnJhZ21lbnQ6IGRpcmVjdGlvbiA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIHJldmVyc2U6IGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEZyYWdtZW50OiAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIE5vZGUuZnJhZ21lbnQoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBpbnNlcnRCcmVhazogKCkgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhbHdheXM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaW5zZXJ0U29mdEJyZWFrOiAoKSA9PiB7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpbnNlcnRGcmFnbWVudDogZnJhZ21lbnQgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KTtcbiAgICB9LFxuICAgIGluc2VydE5vZGU6IG5vZGUgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5vZGUpO1xuICAgIH0sXG4gICAgaW5zZXJ0VGV4dDogdGV4dCA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIG1hcmtzXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChtYXJrcykge1xuICAgICAgICAgIHZhciBub2RlID0gX29iamVjdFNwcmVhZCQ5KHtcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9LCBtYXJrcyk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgdGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgbm9ybWFsaXplTm9kZTogZW50cnkgPT4ge1xuICAgICAgdmFyIFtub2RlLCBwYXRoXSA9IGVudHJ5OyAvLyBUaGVyZSBhcmUgbm8gY29yZSBub3JtYWxpemF0aW9ucyBmb3IgdGV4dCBub2Rlcy5cblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRW5zdXJlIHRoYXQgYmxvY2sgYW5kIGlubGluZSBub2RlcyBoYXZlIGF0IGxlYXN0IG9uZSB0ZXh0IGNoaWxkLlxuXG5cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgdGV4dDogJydcbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGNoaWxkLCB7XG4gICAgICAgICAgYXQ6IHBhdGguY29uY2F0KDApLFxuICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBoYXZlIGJsb2NrIG9yIGlubGluZSBjaGlsZHJlbi5cblxuXG4gICAgICB2YXIgc2hvdWxkSGF2ZUlubGluZXMgPSBFZGl0b3IuaXNFZGl0b3Iobm9kZSkgPyBmYWxzZSA6IEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkgfHwgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgVGV4dC5pc1RleHQobm9kZS5jaGlsZHJlblswXSkgfHwgZWRpdG9yLmlzSW5saW5lKG5vZGUuY2hpbGRyZW5bMF0pKTsgLy8gU2luY2Ugd2UnbGwgYmUgYXBwbHlpbmcgb3BlcmF0aW9ucyB3aGlsZSBpdGVyYXRpbmcsIGtlZXAgdHJhY2sgb2YgYW5cbiAgICAgIC8vIGluZGV4IHRoYXQgYWNjb3VudHMgZm9yIGFueSBhZGRlZC9yZW1vdmVkIG5vZGVzLlxuXG4gICAgICB2YXIgbiA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKywgbisrKSB7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChjdXJyZW50Tm9kZSkpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgX2NoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgdmFyIHByZXYgPSBjdXJyZW50Tm9kZS5jaGlsZHJlbltuIC0gMV07XG4gICAgICAgIHZhciBpc0xhc3QgPSBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBpc0lubGluZU9yVGV4dCA9IFRleHQuaXNUZXh0KF9jaGlsZCkgfHwgRWxlbWVudC5pc0VsZW1lbnQoX2NoaWxkKSAmJiBlZGl0b3IuaXNJbmxpbmUoX2NoaWxkKTsgLy8gT25seSBhbGxvdyBibG9jayBub2RlcyBpbiB0aGUgdG9wLWxldmVsIGNoaWxkcmVuIGFuZCBwYXJlbnQgYmxvY2tzXG4gICAgICAgIC8vIHRoYXQgb25seSBjb250YWluIGJsb2NrIG5vZGVzLiBTaW1pbGFybHksIG9ubHkgYWxsb3cgaW5saW5lIG5vZGVzIGluXG4gICAgICAgIC8vIG90aGVyIGlubGluZSBub2Rlcywgb3IgcGFyZW50IGJsb2NrcyB0aGF0IG9ubHkgY29udGFpbiBpbmxpbmVzIGFuZFxuICAgICAgICAvLyB0ZXh0LlxuXG4gICAgICAgIGlmIChpc0lubGluZU9yVGV4dCAhPT0gc2hvdWxkSGF2ZUlubGluZXMpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQoX2NoaWxkKSkge1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGlubGluZSBub2RlcyBhcmUgc3Vycm91bmRlZCBieSB0ZXh0IG5vZGVzLlxuICAgICAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUoX2NoaWxkKSkge1xuICAgICAgICAgICAgaWYgKHByZXYgPT0gbnVsbCB8fCAhVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBuZXdDaGlsZCwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgdmFyIF9uZXdDaGlsZCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgX25ld0NoaWxkLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gKyAxKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIHRoYXQgYXJlIGVtcHR5IG9yIG1hdGNoLlxuICAgICAgICAgIGlmIChwcmV2ICE9IG51bGwgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgIGlmIChUZXh0LmVxdWFscyhfY2hpbGQsIHByZXYsIHtcbiAgICAgICAgICAgICAgbG9vc2U6IHRydWVcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldi50ZXh0ID09PSAnJykge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuIC0gMSksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2NoaWxkLnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVNYXJrOiBrZXkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCBrZXksIHtcbiAgICAgICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ5KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSk7XG5cbiAgICAgICAgICBkZWxldGUgbWFya3Nba2V5XTtcbiAgICAgICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcblxuICAgICAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG4vKipcclxuICogR2V0IHRoZSBcImRpcnR5XCIgcGF0aHMgZ2VuZXJhdGVkIGZyb20gYW4gb3BlcmF0aW9uLlxyXG4gKi9cblxudmFyIGdldERpcnR5UGF0aHMgPSBvcCA9PiB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGhcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICByZXR1cm4gUGF0aC5sZXZlbHMocGF0aCk7XG4gICAgICB9XG5cbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwYXRoOiBfcGF0aDJcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGgyKTtcbiAgICAgICAgdmFyIGRlc2NlbmRhbnRzID0gVGV4dC5pc1RleHQobm9kZSkgPyBbXSA6IEFycmF5LmZyb20oTm9kZS5ub2Rlcyhub2RlKSwgX3JlZjMgPT4ge1xuICAgICAgICAgIHZhciBbLCBwXSA9IF9yZWYzO1xuICAgICAgICAgIHJldHVybiBfcGF0aDIuY29uY2F0KHApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFsuLi5sZXZlbHMsIC4uLmRlc2NlbmRhbnRzXTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoM1xuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBhbmNlc3RvcnMgPSBQYXRoLmFuY2VzdG9ycyhfcGF0aDMpO1xuICAgICAgICB2YXIgcHJldmlvdXNQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDMpO1xuICAgICAgICByZXR1cm4gWy4uLmFuY2VzdG9ycywgcHJldmlvdXNQYXRoXTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg0LFxuICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhfcGF0aDQsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZEFuY2VzdG9ycyA9IFtdO1xuICAgICAgICB2YXIgbmV3QW5jZXN0b3JzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgYW5jZXN0b3Igb2YgUGF0aC5hbmNlc3RvcnMoX3BhdGg0KSkge1xuICAgICAgICAgIHZhciBwID0gUGF0aC50cmFuc2Zvcm0oYW5jZXN0b3IsIG9wKTtcbiAgICAgICAgICBvbGRBbmNlc3RvcnMucHVzaChwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9hbmNlc3RvciBvZiBQYXRoLmFuY2VzdG9ycyhuZXdQYXRoKSkge1xuICAgICAgICAgIHZhciBfcCA9IFBhdGgudHJhbnNmb3JtKF9hbmNlc3Rvciwgb3ApO1xuXG4gICAgICAgICAgbmV3QW5jZXN0b3JzLnB1c2goX3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IG5ld0FuY2VzdG9yc1tuZXdBbmNlc3RvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuZXdJbmRleCA9IG5ld1BhdGhbbmV3UGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJlc3VsdFBhdGggPSBuZXdQYXJlbnQuY29uY2F0KG5ld0luZGV4KTtcbiAgICAgICAgcmV0dXJuIFsuLi5vbGRBbmNlc3RvcnMsIC4uLm5ld0FuY2VzdG9ycywgcmVzdWx0UGF0aF07XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg1XG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICB2YXIgX2FuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoNSk7XG5cbiAgICAgICAgcmV0dXJuIFsuLi5fYW5jZXN0b3JzXTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNlxuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgdmFyIF9sZXZlbHMgPSBQYXRoLmxldmVscyhfcGF0aDYpO1xuXG4gICAgICAgIHZhciBuZXh0UGF0aCA9IFBhdGgubmV4dChfcGF0aDYpO1xuICAgICAgICByZXR1cm4gWy4uLl9sZXZlbHMsIG5leHRQYXRoXTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIENoYXJhY3RlciAoZ3JhcGhlbWUgY2x1c3RlcikgYm91bmRhcmllcyBhcmUgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG9cbi8vIHRoZSBkZWZhdWx0IGdyYXBoZW1lIGNsdXN0ZXIgYm91bmRhcnkgc3BlY2lmaWNhdGlvbiwgZXh0ZW5kZWQgZ3JhcGhlbWUgY2x1c3RlcnMgdmFyaWFudFsxXS5cbi8vXG4vLyBSZWZlcmVuY2VzOlxuLy9cbi8vIFsxXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMjkvI0RlZmF1bHRfR3JhcGhlbWVfQ2x1c3Rlcl9UYWJsZVxuLy8gWzJdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Byb3BlcnR5LnR4dFxuLy8gWzNdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QuaHRtbFxuLy8gWzRdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QudHh0XG5cbi8qKlxyXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN0cmluZyBvZiB0ZXh0LlxyXG4gKi9cbnZhciBnZXRDaGFyYWN0ZXJEaXN0YW5jZSA9IGZ1bmN0aW9uIGdldENoYXJhY3RlckRpc3RhbmNlKHN0cikge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgaXNMVFIgPSAhaXNSVEw7XG4gIHZhciBjb2RlcG9pbnRzID0gaXNSVEwgPyBjb2RlcG9pbnRzSXRlcmF0b3JSVEwoc3RyKSA6IHN0cjtcbiAgdmFyIGxlZnQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciByaWdodCA9IENvZGVwb2ludFR5cGUuTm9uZTtcbiAgdmFyIGRpc3RhbmNlID0gMDsgLy8gRXZhbHVhdGlvbiBvZiB0aGVzZSBjb25kaXRpb25zIGFyZSBkZWZlcnJlZC5cblxuICB2YXIgZ2IxMSA9IG51bGw7IC8vIElzIEdCMTEgYXBwbGljYWJsZT9cblxuICB2YXIgZ2IxMk9yMTMgPSBudWxsOyAvLyBJcyBHQjEyIG9yIEdCMTMgYXBwbGljYWJsZT9cblxuICBmb3IgKHZhciBjaGFyIG9mIGNvZGVwb2ludHMpIHtcbiAgICB2YXIgY29kZSA9IGNoYXIuY29kZVBvaW50QXQoMCk7XG4gICAgaWYgKCFjb2RlKSBicmVhaztcbiAgICB2YXIgdHlwZSA9IGdldENvZGVwb2ludFR5cGUoY2hhciwgY29kZSk7XG4gICAgW2xlZnQsIHJpZ2h0XSA9IGlzTFRSID8gW3JpZ2h0LCB0eXBlXSA6IFt0eXBlLCBsZWZ0XTtcblxuICAgIGlmIChpbnRlcnNlY3RzKGxlZnQsIENvZGVwb2ludFR5cGUuWldKKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCBDb2RlcG9pbnRUeXBlLkV4dFBpY3QpKSB7XG4gICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgZ2IxMSA9IGVuZHNXaXRoRW1vamlaV0ooc3RyLnN1YnN0cmluZygwLCBkaXN0YW5jZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2IxMSA9IGVuZHNXaXRoRW1vamlaV0ooc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFnYjExKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJzZWN0cyhsZWZ0LCBDb2RlcG9pbnRUeXBlLlJJKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCBDb2RlcG9pbnRUeXBlLlJJKSkge1xuICAgICAgaWYgKGdiMTJPcjEzICE9PSBudWxsKSB7XG4gICAgICAgIGdiMTJPcjEzID0gIWdiMTJPcjEzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTFRSKSB7XG4gICAgICAgICAgZ2IxMk9yMTMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdiMTJPcjEzID0gZW5kc1dpdGhPZGROdW1iZXJPZlJJcyhzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2IxMk9yMTMpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChsZWZ0ICE9PSBDb2RlcG9pbnRUeXBlLk5vbmUgJiYgcmlnaHQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiBpc0JvdW5kYXJ5UGFpcihsZWZ0LCByaWdodCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRpc3RhbmNlICs9IGNoYXIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGRpc3RhbmNlIHx8IDE7XG59O1xudmFyIFNQQUNFID0gL1xccy87XG52YXIgUFVOQ1RVQVRJT04gPSAvW1xcdTAwMjEtXFx1MDAyM1xcdTAwMjUtXFx1MDAyQVxcdTAwMkMtXFx1MDAyRlxcdTAwM0FcXHUwMDNCXFx1MDAzRlxcdTAwNDBcXHUwMDVCLVxcdTAwNURcXHUwMDVGXFx1MDA3QlxcdTAwN0RcXHUwMEExXFx1MDBBN1xcdTAwQUJcXHUwMEI2XFx1MDBCN1xcdTAwQkJcXHUwMEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFM0JcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdLztcbnZhciBDSEFNRUxFT04gPSAvWydcXHUyMDE4XFx1MjAxOV0vO1xuLyoqXHJcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3Qgd29yZCBpbiBhIHN0cmluZyBvZiB0ZXh0LlxyXG4gKi9cblxudmFyIGdldFdvcmREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldFdvcmREaXN0YW5jZSh0ZXh0KSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBkaXN0ID0gMDtcbiAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcblxuICB3aGlsZSAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGNoYXJEaXN0ID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgaXNSVEwpO1xuICAgIHZhciBbY2hhciwgcmVtYWluaW5nXSA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBjaGFyRGlzdCwgaXNSVEwpO1xuXG4gICAgaWYgKGlzV29yZENoYXJhY3RlcihjaGFyLCByZW1haW5pbmcsIGlzUlRMKSkge1xuICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgIGRpc3QgKz0gY2hhckRpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRleHQgPSByZW1haW5pbmc7XG4gIH1cblxuICByZXR1cm4gZGlzdDtcbn07XG4vKipcclxuICogU3BsaXQgYSBzdHJpbmcgaW4gdHdvIHBhcnRzIGF0IGEgZ2l2ZW4gZGlzdGFuY2Ugc3RhcnRpbmcgZnJvbSB0aGUgZW5kIHdoZW5cclxuICogYGlzUlRMYCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gKi9cblxudmFyIHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSA9IChzdHIsIGRpc3QsIGlzUlRMKSA9PiB7XG4gIGlmIChpc1JUTCkge1xuICAgIHZhciBhdCA9IHN0ci5sZW5ndGggLSBkaXN0O1xuICAgIHJldHVybiBbc3RyLnNsaWNlKGF0LCBzdHIubGVuZ3RoKSwgc3RyLnNsaWNlKDAsIGF0KV07XG4gIH1cblxuICByZXR1cm4gW3N0ci5zbGljZSgwLCBkaXN0KSwgc3RyLnNsaWNlKGRpc3QpXTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBjaGFyYWN0ZXIgaXMgYSB3b3JkIGNoYXJhY3Rlci4gVGhlIGByZW1haW5pbmdgIGFyZ3VtZW50IGlzIHVzZWRcclxuICogYmVjYXVzZSBzb21ldGltZXMgeW91IG11c3QgcmVhZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMgdG8gdHJ1bHkgZGV0ZXJtaW5lIGl0LlxyXG4gKi9cblxudmFyIGlzV29yZENoYXJhY3RlciA9IGZ1bmN0aW9uIGlzV29yZENoYXJhY3RlcihjaGFyLCByZW1haW5pbmcpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICBpZiAoU1BBQ0UudGVzdChjaGFyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBDaGFtZWxlb25zIGNvdW50IGFzIHdvcmQgY2hhcmFjdGVycyBhcyBsb25nIGFzIHRoZXkncmUgaW4gYSB3b3JkLCBzb1xuICAvLyByZWN1cnNlIHRvIHNlZSBpZiB0aGUgbmV4dCBvbmUgaXMgYSB3b3JkIGNoYXJhY3RlciBvciBub3QuXG5cblxuICBpZiAoQ0hBTUVMRU9OLnRlc3QoY2hhcikpIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGlzUlRMKTtcbiAgICB2YXIgW25leHRDaGFyLCBuZXh0UmVtYWluaW5nXSA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGNoYXJEaXN0LCBpc1JUTCk7XG5cbiAgICBpZiAoaXNXb3JkQ2hhcmFjdGVyKG5leHRDaGFyLCBuZXh0UmVtYWluaW5nLCBpc1JUTCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChQVU5DVFVBVElPTi50ZXN0KGNoYXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXHJcbiAqIEl0ZXJhdGUgb24gY29kZXBvaW50cyBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAqL1xuXG5cbnZhciBjb2RlcG9pbnRzSXRlcmF0b3JSVEwgPSBmdW5jdGlvbiogY29kZXBvaW50c0l0ZXJhdG9yUlRMKHN0cikge1xuICB2YXIgZW5kID0gc3RyLmxlbmd0aCAtIDE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhcjEgPSBzdHIuY2hhckF0KGVuZCAtIGkpO1xuXG4gICAgaWYgKGlzTG93U3Vycm9nYXRlKGNoYXIxLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICB2YXIgY2hhcjIgPSBzdHIuY2hhckF0KGVuZCAtIGkgLSAxKTtcblxuICAgICAgaWYgKGlzSGlnaFN1cnJvZ2F0ZShjaGFyMi5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICB5aWVsZCBjaGFyMiArIGNoYXIxO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHlpZWxkIGNoYXIxO1xuICB9XG59O1xuLyoqXHJcbiAqIElzIGBjaGFyQ29kZWAgYSBoaWdoIHN1cnJvZ2F0ZS5cclxuICpcclxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXHJcbiAqL1xuXG52YXIgaXNIaWdoU3Vycm9nYXRlID0gY2hhckNvZGUgPT4ge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhkODAwICYmIGNoYXJDb2RlIDw9IDB4ZGJmZjtcbn07XG4vKipcclxuICogSXMgYGNoYXJDb2RlYCBhIGxvdyBzdXJyb2dhdGUuXHJcbiAqXHJcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbF9DaGFyYWN0ZXJfU2V0X2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xyXG4gKi9cblxuXG52YXIgaXNMb3dTdXJyb2dhdGUgPSBjaGFyQ29kZSA9PiB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweGRjMDAgJiYgY2hhckNvZGUgPD0gMHhkZmZmO1xufTtcblxudmFyIENvZGVwb2ludFR5cGU7XG5cbihmdW5jdGlvbiAoQ29kZXBvaW50VHlwZSkge1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiRXh0ZW5kXCJdID0gMV0gPSBcIkV4dGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJaV0pcIl0gPSAyXSA9IFwiWldKXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlJJXCJdID0gNF0gPSBcIlJJXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlByZXBlbmRcIl0gPSA4XSA9IFwiUHJlcGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJTcGFjaW5nTWFya1wiXSA9IDE2XSA9IFwiU3BhY2luZ01hcmtcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFwiXSA9IDMyXSA9IFwiTFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJWXCJdID0gNjRdID0gXCJWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlRcIl0gPSAxMjhdID0gXCJUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWXCJdID0gMjU2XSA9IFwiTFZcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFZUXCJdID0gNTEyXSA9IFwiTFZUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dFBpY3RcIl0gPSAxMDI0XSA9IFwiRXh0UGljdFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJBbnlcIl0gPSAyMDQ4XSA9IFwiQW55XCI7XG59KShDb2RlcG9pbnRUeXBlIHx8IChDb2RlcG9pbnRUeXBlID0ge30pKTtcblxudmFyIHJlRXh0ZW5kID0gL14oPzpbXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA3RkRcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEQzLVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlCRVxcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUZFXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRkEtXFx1MEFGRlxcdTBCMDFcXHUwQjNDXFx1MEIzRVxcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NS1cXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRVxcdTBCQzBcXHUwQkNEXFx1MEJEN1xcdTBDMDBcXHUwQzA0XFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQzBcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY5XFx1MURGQi1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURGNDYtXFx1REY1MF18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0JcXHVERjNDXFx1REYzRVxcdURGNDBcXHVERjU3XFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQzVFXFx1RENCMFxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JEXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQUZcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDZbXFx1REMyRi1cXHVEQzM3XFx1REMzOVxcdURDM0FcXHVERDMwXFx1REQzQlxcdUREM0NcXHVERDNFXFx1REQ0M1xcdURERDQtXFx1REREN1xcdUREREFcXHVERERCXFx1RERFMFxcdURFMDEtXFx1REUwQVxcdURFMzMtXFx1REUzOFxcdURFM0ItXFx1REUzRVxcdURFNDdcXHVERTUxLVxcdURFNTZcXHVERTU5LVxcdURFNUJcXHVERThBLVxcdURFOTZcXHVERTk4XFx1REU5OV18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNlxcdUREMzEtXFx1REQzNlxcdUREM0FcXHVERDNDXFx1REQzRFxcdUREM0YtXFx1REQ0NVxcdURENDdcXHVERDkwXFx1REQ5MVxcdUREOTVcXHVERDk3XFx1REVGM1xcdURFRjRdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGNEZcXHVERjhGLVxcdURGOTJcXHVERkU0XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVERDMwLVxcdUREMzZcXHVERUVDLVxcdURFRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSQvO1xudmFyIHJlUHJlcGVuZCA9IC9eKD86W1xcdTA2MDAtXFx1MDYwNVxcdTA2RERcXHUwNzBGXFx1MDg5MFxcdTA4OTFcXHUwOEUyXFx1MEQ0RV18XFx1RDgwNFtcXHVEQ0JEXFx1RENDRFxcdUREQzJcXHVEREMzXXxcXHVEODA2W1xcdUREM0ZcXHVERDQxXFx1REUzQVxcdURFODQtXFx1REU4OV18XFx1RDgwN1xcdURENDYpJC87XG52YXIgcmVTcGFjaW5nTWFyayA9IC9eKD86W1xcdTA5MDNcXHUwOTNCXFx1MDkzRS1cXHUwOTQwXFx1MDk0OS1cXHUwOTRDXFx1MDk0RVxcdTA5NEZcXHUwOTgyXFx1MDk4M1xcdTA5QkZcXHUwOUMwXFx1MDlDN1xcdTA5QzhcXHUwOUNCXFx1MDlDQ1xcdTBBMDNcXHUwQTNFLVxcdTBBNDBcXHUwQTgzXFx1MEFCRS1cXHUwQUMwXFx1MEFDOVxcdTBBQ0JcXHUwQUNDXFx1MEIwMlxcdTBCMDNcXHUwQjQwXFx1MEI0N1xcdTBCNDhcXHUwQjRCXFx1MEI0Q1xcdTBCQkZcXHUwQkMxXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDQ1xcdTBDMDEtXFx1MEMwM1xcdTBDNDEtXFx1MEM0NFxcdTBDODJcXHUwQzgzXFx1MENCRVxcdTBDQzBcXHUwQ0MxXFx1MENDM1xcdTBDQzRcXHUwQ0M3XFx1MENDOFxcdTBDQ0FcXHUwQ0NCXFx1MEQwMlxcdTBEMDNcXHUwRDNGXFx1MEQ0MFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0Q1xcdTBEODJcXHUwRDgzXFx1MEREMFxcdTBERDFcXHUwREQ4LVxcdTBEREVcXHUwREYyXFx1MERGM1xcdTBFMzNcXHUwRUIzXFx1MEYzRVxcdTBGM0ZcXHUwRjdGXFx1MTAzMVxcdTEwM0JcXHUxMDNDXFx1MTA1NlxcdTEwNTdcXHUxMDg0XFx1MTcxNVxcdTE3MzRcXHUxN0I2XFx1MTdCRS1cXHUxN0M1XFx1MTdDN1xcdTE3QzhcXHUxOTIzLVxcdTE5MjZcXHUxOTI5LVxcdTE5MkJcXHUxOTMwXFx1MTkzMVxcdTE5MzMtXFx1MTkzOFxcdTFBMTlcXHUxQTFBXFx1MUE1NVxcdTFBNTdcXHUxQTZELVxcdTFBNzJcXHUxQjA0XFx1MUIzQlxcdTFCM0QtXFx1MUI0MVxcdTFCNDNcXHUxQjQ0XFx1MUI4MlxcdTFCQTFcXHUxQkE2XFx1MUJBN1xcdTFCQUFcXHUxQkU3XFx1MUJFQS1cXHUxQkVDXFx1MUJFRVxcdTFCRjJcXHUxQkYzXFx1MUMyNC1cXHUxQzJCXFx1MUMzNFxcdTFDMzVcXHUxQ0UxXFx1MUNGN1xcdUE4MjNcXHVBODI0XFx1QTgyN1xcdUE4ODBcXHVBODgxXFx1QThCNC1cXHVBOEMzXFx1QTk1MlxcdUE5NTNcXHVBOTgzXFx1QTlCNFxcdUE5QjVcXHVBOUJBXFx1QTlCQlxcdUE5QkUtXFx1QTlDMFxcdUFBMkZcXHVBQTMwXFx1QUEzM1xcdUFBMzRcXHVBQTREXFx1QUFFQlxcdUFBRUVcXHVBQUVGXFx1QUFGNVxcdUFCRTNcXHVBQkU0XFx1QUJFNlxcdUFCRTdcXHVBQkU5XFx1QUJFQVxcdUFCRUNdfFxcdUQ4MDRbXFx1REMwMFxcdURDMDJcXHVEQzgyXFx1RENCMC1cXHVEQ0IyXFx1RENCN1xcdURDQjhcXHVERDJDXFx1REQ0NVxcdURENDZcXHVERDgyXFx1RERCMy1cXHVEREI1XFx1RERCRlxcdUREQzBcXHVERENFXFx1REUyQy1cXHVERTJFXFx1REUzMlxcdURFMzNcXHVERTM1XFx1REVFMC1cXHVERUUyXFx1REYwMlxcdURGMDNcXHVERjNGXFx1REY0MS1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjYyXFx1REY2M118XFx1RDgwNVtcXHVEQzM1LVxcdURDMzdcXHVEQzQwXFx1REM0MVxcdURDNDVcXHVEQ0IxXFx1RENCMlxcdURDQjlcXHVEQ0JCXFx1RENCQ1xcdURDQkVcXHVEQ0MxXFx1RERCMFxcdUREQjFcXHVEREI4LVxcdUREQkJcXHVEREJFXFx1REUzMC1cXHVERTMyXFx1REUzQlxcdURFM0NcXHVERTNFXFx1REVBQ1xcdURFQUVcXHVERUFGXFx1REVCNlxcdURGMjZdfFxcdUQ4MDZbXFx1REMyQy1cXHVEQzJFXFx1REMzOFxcdUREMzEtXFx1REQzNVxcdUREMzdcXHVERDM4XFx1REQzRFxcdURENDBcXHVERDQyXFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERGXFx1RERFNFxcdURFMzlcXHVERTU3XFx1REU1OFxcdURFOTddfFxcdUQ4MDdbXFx1REMyRlxcdURDM0VcXHVEQ0E5XFx1RENCMVxcdURDQjRcXHVERDhBLVxcdUREOEVcXHVERDkzXFx1REQ5NFxcdUREOTZcXHVERUY1XFx1REVGNl18XFx1RDgxQltcXHVERjUxLVxcdURGODdcXHVERkYwXFx1REZGMV18XFx1RDgzNFtcXHVERDY2XFx1REQ2RF0pJC87XG52YXIgcmVMID0gL15bXFx1MTEwMC1cXHUxMTVGXFx1QTk2MC1cXHVBOTdDXSQvO1xudmFyIHJlViA9IC9eW1xcdTExNjAtXFx1MTFBN1xcdUQ3QjAtXFx1RDdDNl0kLztcbnZhciByZVQgPSAvXltcXHUxMUE4LVxcdTExRkZcXHVEN0NCLVxcdUQ3RkJdJC87XG52YXIgcmVMViA9IC9eW1xcdUFDMDBcXHVBQzFDXFx1QUMzOFxcdUFDNTRcXHVBQzcwXFx1QUM4Q1xcdUFDQThcXHVBQ0M0XFx1QUNFMFxcdUFDRkNcXHVBRDE4XFx1QUQzNFxcdUFENTBcXHVBRDZDXFx1QUQ4OFxcdUFEQTRcXHVBREMwXFx1QUREQ1xcdUFERjhcXHVBRTE0XFx1QUUzMFxcdUFFNENcXHVBRTY4XFx1QUU4NFxcdUFFQTBcXHVBRUJDXFx1QUVEOFxcdUFFRjRcXHVBRjEwXFx1QUYyQ1xcdUFGNDhcXHVBRjY0XFx1QUY4MFxcdUFGOUNcXHVBRkI4XFx1QUZENFxcdUFGRjBcXHVCMDBDXFx1QjAyOFxcdUIwNDRcXHVCMDYwXFx1QjA3Q1xcdUIwOThcXHVCMEI0XFx1QjBEMFxcdUIwRUNcXHVCMTA4XFx1QjEyNFxcdUIxNDBcXHVCMTVDXFx1QjE3OFxcdUIxOTRcXHVCMUIwXFx1QjFDQ1xcdUIxRThcXHVCMjA0XFx1QjIyMFxcdUIyM0NcXHVCMjU4XFx1QjI3NFxcdUIyOTBcXHVCMkFDXFx1QjJDOFxcdUIyRTRcXHVCMzAwXFx1QjMxQ1xcdUIzMzhcXHVCMzU0XFx1QjM3MFxcdUIzOENcXHVCM0E4XFx1QjNDNFxcdUIzRTBcXHVCM0ZDXFx1QjQxOFxcdUI0MzRcXHVCNDUwXFx1QjQ2Q1xcdUI0ODhcXHVCNEE0XFx1QjRDMFxcdUI0RENcXHVCNEY4XFx1QjUxNFxcdUI1MzBcXHVCNTRDXFx1QjU2OFxcdUI1ODRcXHVCNUEwXFx1QjVCQ1xcdUI1RDhcXHVCNUY0XFx1QjYxMFxcdUI2MkNcXHVCNjQ4XFx1QjY2NFxcdUI2ODBcXHVCNjlDXFx1QjZCOFxcdUI2RDRcXHVCNkYwXFx1QjcwQ1xcdUI3MjhcXHVCNzQ0XFx1Qjc2MFxcdUI3N0NcXHVCNzk4XFx1QjdCNFxcdUI3RDBcXHVCN0VDXFx1QjgwOFxcdUI4MjRcXHVCODQwXFx1Qjg1Q1xcdUI4NzhcXHVCODk0XFx1QjhCMFxcdUI4Q0NcXHVCOEU4XFx1QjkwNFxcdUI5MjBcXHVCOTNDXFx1Qjk1OFxcdUI5NzRcXHVCOTkwXFx1QjlBQ1xcdUI5QzhcXHVCOUU0XFx1QkEwMFxcdUJBMUNcXHVCQTM4XFx1QkE1NFxcdUJBNzBcXHVCQThDXFx1QkFBOFxcdUJBQzRcXHVCQUUwXFx1QkFGQ1xcdUJCMThcXHVCQjM0XFx1QkI1MFxcdUJCNkNcXHVCQjg4XFx1QkJBNFxcdUJCQzBcXHVCQkRDXFx1QkJGOFxcdUJDMTRcXHVCQzMwXFx1QkM0Q1xcdUJDNjhcXHVCQzg0XFx1QkNBMFxcdUJDQkNcXHVCQ0Q4XFx1QkNGNFxcdUJEMTBcXHVCRDJDXFx1QkQ0OFxcdUJENjRcXHVCRDgwXFx1QkQ5Q1xcdUJEQjhcXHVCREQ0XFx1QkRGMFxcdUJFMENcXHVCRTI4XFx1QkU0NFxcdUJFNjBcXHVCRTdDXFx1QkU5OFxcdUJFQjRcXHVCRUQwXFx1QkVFQ1xcdUJGMDhcXHVCRjI0XFx1QkY0MFxcdUJGNUNcXHVCRjc4XFx1QkY5NFxcdUJGQjBcXHVCRkNDXFx1QkZFOFxcdUMwMDRcXHVDMDIwXFx1QzAzQ1xcdUMwNThcXHVDMDc0XFx1QzA5MFxcdUMwQUNcXHVDMEM4XFx1QzBFNFxcdUMxMDBcXHVDMTFDXFx1QzEzOFxcdUMxNTRcXHVDMTcwXFx1QzE4Q1xcdUMxQThcXHVDMUM0XFx1QzFFMFxcdUMxRkNcXHVDMjE4XFx1QzIzNFxcdUMyNTBcXHVDMjZDXFx1QzI4OFxcdUMyQTRcXHVDMkMwXFx1QzJEQ1xcdUMyRjhcXHVDMzE0XFx1QzMzMFxcdUMzNENcXHVDMzY4XFx1QzM4NFxcdUMzQTBcXHVDM0JDXFx1QzNEOFxcdUMzRjRcXHVDNDEwXFx1QzQyQ1xcdUM0NDhcXHVDNDY0XFx1QzQ4MFxcdUM0OUNcXHVDNEI4XFx1QzRENFxcdUM0RjBcXHVDNTBDXFx1QzUyOFxcdUM1NDRcXHVDNTYwXFx1QzU3Q1xcdUM1OThcXHVDNUI0XFx1QzVEMFxcdUM1RUNcXHVDNjA4XFx1QzYyNFxcdUM2NDBcXHVDNjVDXFx1QzY3OFxcdUM2OTRcXHVDNkIwXFx1QzZDQ1xcdUM2RThcXHVDNzA0XFx1QzcyMFxcdUM3M0NcXHVDNzU4XFx1Qzc3NFxcdUM3OTBcXHVDN0FDXFx1QzdDOFxcdUM3RTRcXHVDODAwXFx1QzgxQ1xcdUM4MzhcXHVDODU0XFx1Qzg3MFxcdUM4OENcXHVDOEE4XFx1QzhDNFxcdUM4RTBcXHVDOEZDXFx1QzkxOFxcdUM5MzRcXHVDOTUwXFx1Qzk2Q1xcdUM5ODhcXHVDOUE0XFx1QzlDMFxcdUM5RENcXHVDOUY4XFx1Q0ExNFxcdUNBMzBcXHVDQTRDXFx1Q0E2OFxcdUNBODRcXHVDQUEwXFx1Q0FCQ1xcdUNBRDhcXHVDQUY0XFx1Q0IxMFxcdUNCMkNcXHVDQjQ4XFx1Q0I2NFxcdUNCODBcXHVDQjlDXFx1Q0JCOFxcdUNCRDRcXHVDQkYwXFx1Q0MwQ1xcdUNDMjhcXHVDQzQ0XFx1Q0M2MFxcdUNDN0NcXHVDQzk4XFx1Q0NCNFxcdUNDRDBcXHVDQ0VDXFx1Q0QwOFxcdUNEMjRcXHVDRDQwXFx1Q0Q1Q1xcdUNENzhcXHVDRDk0XFx1Q0RCMFxcdUNEQ0NcXHVDREU4XFx1Q0UwNFxcdUNFMjBcXHVDRTNDXFx1Q0U1OFxcdUNFNzRcXHVDRTkwXFx1Q0VBQ1xcdUNFQzhcXHVDRUU0XFx1Q0YwMFxcdUNGMUNcXHVDRjM4XFx1Q0Y1NFxcdUNGNzBcXHVDRjhDXFx1Q0ZBOFxcdUNGQzRcXHVDRkUwXFx1Q0ZGQ1xcdUQwMThcXHVEMDM0XFx1RDA1MFxcdUQwNkNcXHVEMDg4XFx1RDBBNFxcdUQwQzBcXHVEMERDXFx1RDBGOFxcdUQxMTRcXHVEMTMwXFx1RDE0Q1xcdUQxNjhcXHVEMTg0XFx1RDFBMFxcdUQxQkNcXHVEMUQ4XFx1RDFGNFxcdUQyMTBcXHVEMjJDXFx1RDI0OFxcdUQyNjRcXHVEMjgwXFx1RDI5Q1xcdUQyQjhcXHVEMkQ0XFx1RDJGMFxcdUQzMENcXHVEMzI4XFx1RDM0NFxcdUQzNjBcXHVEMzdDXFx1RDM5OFxcdUQzQjRcXHVEM0QwXFx1RDNFQ1xcdUQ0MDhcXHVENDI0XFx1RDQ0MFxcdUQ0NUNcXHVENDc4XFx1RDQ5NFxcdUQ0QjBcXHVENENDXFx1RDRFOFxcdUQ1MDRcXHVENTIwXFx1RDUzQ1xcdUQ1NThcXHVENTc0XFx1RDU5MFxcdUQ1QUNcXHVENUM4XFx1RDVFNFxcdUQ2MDBcXHVENjFDXFx1RDYzOFxcdUQ2NTRcXHVENjcwXFx1RDY4Q1xcdUQ2QThcXHVENkM0XFx1RDZFMFxcdUQ2RkNcXHVENzE4XFx1RDczNFxcdUQ3NTBcXHVENzZDXFx1RDc4OF0kLztcbnZhciByZUxWVCA9IC9eW1xcdUFDMDEtXFx1QUMxQlxcdUFDMUQtXFx1QUMzN1xcdUFDMzktXFx1QUM1M1xcdUFDNTUtXFx1QUM2RlxcdUFDNzEtXFx1QUM4QlxcdUFDOEQtXFx1QUNBN1xcdUFDQTktXFx1QUNDM1xcdUFDQzUtXFx1QUNERlxcdUFDRTEtXFx1QUNGQlxcdUFDRkQtXFx1QUQxN1xcdUFEMTktXFx1QUQzM1xcdUFEMzUtXFx1QUQ0RlxcdUFENTEtXFx1QUQ2QlxcdUFENkQtXFx1QUQ4N1xcdUFEODktXFx1QURBM1xcdUFEQTUtXFx1QURCRlxcdUFEQzEtXFx1QUREQlxcdUFEREQtXFx1QURGN1xcdUFERjktXFx1QUUxM1xcdUFFMTUtXFx1QUUyRlxcdUFFMzEtXFx1QUU0QlxcdUFFNEQtXFx1QUU2N1xcdUFFNjktXFx1QUU4M1xcdUFFODUtXFx1QUU5RlxcdUFFQTEtXFx1QUVCQlxcdUFFQkQtXFx1QUVEN1xcdUFFRDktXFx1QUVGM1xcdUFFRjUtXFx1QUYwRlxcdUFGMTEtXFx1QUYyQlxcdUFGMkQtXFx1QUY0N1xcdUFGNDktXFx1QUY2M1xcdUFGNjUtXFx1QUY3RlxcdUFGODEtXFx1QUY5QlxcdUFGOUQtXFx1QUZCN1xcdUFGQjktXFx1QUZEM1xcdUFGRDUtXFx1QUZFRlxcdUFGRjEtXFx1QjAwQlxcdUIwMEQtXFx1QjAyN1xcdUIwMjktXFx1QjA0M1xcdUIwNDUtXFx1QjA1RlxcdUIwNjEtXFx1QjA3QlxcdUIwN0QtXFx1QjA5N1xcdUIwOTktXFx1QjBCM1xcdUIwQjUtXFx1QjBDRlxcdUIwRDEtXFx1QjBFQlxcdUIwRUQtXFx1QjEwN1xcdUIxMDktXFx1QjEyM1xcdUIxMjUtXFx1QjEzRlxcdUIxNDEtXFx1QjE1QlxcdUIxNUQtXFx1QjE3N1xcdUIxNzktXFx1QjE5M1xcdUIxOTUtXFx1QjFBRlxcdUIxQjEtXFx1QjFDQlxcdUIxQ0QtXFx1QjFFN1xcdUIxRTktXFx1QjIwM1xcdUIyMDUtXFx1QjIxRlxcdUIyMjEtXFx1QjIzQlxcdUIyM0QtXFx1QjI1N1xcdUIyNTktXFx1QjI3M1xcdUIyNzUtXFx1QjI4RlxcdUIyOTEtXFx1QjJBQlxcdUIyQUQtXFx1QjJDN1xcdUIyQzktXFx1QjJFM1xcdUIyRTUtXFx1QjJGRlxcdUIzMDEtXFx1QjMxQlxcdUIzMUQtXFx1QjMzN1xcdUIzMzktXFx1QjM1M1xcdUIzNTUtXFx1QjM2RlxcdUIzNzEtXFx1QjM4QlxcdUIzOEQtXFx1QjNBN1xcdUIzQTktXFx1QjNDM1xcdUIzQzUtXFx1QjNERlxcdUIzRTEtXFx1QjNGQlxcdUIzRkQtXFx1QjQxN1xcdUI0MTktXFx1QjQzM1xcdUI0MzUtXFx1QjQ0RlxcdUI0NTEtXFx1QjQ2QlxcdUI0NkQtXFx1QjQ4N1xcdUI0ODktXFx1QjRBM1xcdUI0QTUtXFx1QjRCRlxcdUI0QzEtXFx1QjREQlxcdUI0REQtXFx1QjRGN1xcdUI0RjktXFx1QjUxM1xcdUI1MTUtXFx1QjUyRlxcdUI1MzEtXFx1QjU0QlxcdUI1NEQtXFx1QjU2N1xcdUI1NjktXFx1QjU4M1xcdUI1ODUtXFx1QjU5RlxcdUI1QTEtXFx1QjVCQlxcdUI1QkQtXFx1QjVEN1xcdUI1RDktXFx1QjVGM1xcdUI1RjUtXFx1QjYwRlxcdUI2MTEtXFx1QjYyQlxcdUI2MkQtXFx1QjY0N1xcdUI2NDktXFx1QjY2M1xcdUI2NjUtXFx1QjY3RlxcdUI2ODEtXFx1QjY5QlxcdUI2OUQtXFx1QjZCN1xcdUI2QjktXFx1QjZEM1xcdUI2RDUtXFx1QjZFRlxcdUI2RjEtXFx1QjcwQlxcdUI3MEQtXFx1QjcyN1xcdUI3MjktXFx1Qjc0M1xcdUI3NDUtXFx1Qjc1RlxcdUI3NjEtXFx1Qjc3QlxcdUI3N0QtXFx1Qjc5N1xcdUI3OTktXFx1QjdCM1xcdUI3QjUtXFx1QjdDRlxcdUI3RDEtXFx1QjdFQlxcdUI3RUQtXFx1QjgwN1xcdUI4MDktXFx1QjgyM1xcdUI4MjUtXFx1QjgzRlxcdUI4NDEtXFx1Qjg1QlxcdUI4NUQtXFx1Qjg3N1xcdUI4NzktXFx1Qjg5M1xcdUI4OTUtXFx1QjhBRlxcdUI4QjEtXFx1QjhDQlxcdUI4Q0QtXFx1QjhFN1xcdUI4RTktXFx1QjkwM1xcdUI5MDUtXFx1QjkxRlxcdUI5MjEtXFx1QjkzQlxcdUI5M0QtXFx1Qjk1N1xcdUI5NTktXFx1Qjk3M1xcdUI5NzUtXFx1Qjk4RlxcdUI5OTEtXFx1QjlBQlxcdUI5QUQtXFx1QjlDN1xcdUI5QzktXFx1QjlFM1xcdUI5RTUtXFx1QjlGRlxcdUJBMDEtXFx1QkExQlxcdUJBMUQtXFx1QkEzN1xcdUJBMzktXFx1QkE1M1xcdUJBNTUtXFx1QkE2RlxcdUJBNzEtXFx1QkE4QlxcdUJBOEQtXFx1QkFBN1xcdUJBQTktXFx1QkFDM1xcdUJBQzUtXFx1QkFERlxcdUJBRTEtXFx1QkFGQlxcdUJBRkQtXFx1QkIxN1xcdUJCMTktXFx1QkIzM1xcdUJCMzUtXFx1QkI0RlxcdUJCNTEtXFx1QkI2QlxcdUJCNkQtXFx1QkI4N1xcdUJCODktXFx1QkJBM1xcdUJCQTUtXFx1QkJCRlxcdUJCQzEtXFx1QkJEQlxcdUJCREQtXFx1QkJGN1xcdUJCRjktXFx1QkMxM1xcdUJDMTUtXFx1QkMyRlxcdUJDMzEtXFx1QkM0QlxcdUJDNEQtXFx1QkM2N1xcdUJDNjktXFx1QkM4M1xcdUJDODUtXFx1QkM5RlxcdUJDQTEtXFx1QkNCQlxcdUJDQkQtXFx1QkNEN1xcdUJDRDktXFx1QkNGM1xcdUJDRjUtXFx1QkQwRlxcdUJEMTEtXFx1QkQyQlxcdUJEMkQtXFx1QkQ0N1xcdUJENDktXFx1QkQ2M1xcdUJENjUtXFx1QkQ3RlxcdUJEODEtXFx1QkQ5QlxcdUJEOUQtXFx1QkRCN1xcdUJEQjktXFx1QkREM1xcdUJERDUtXFx1QkRFRlxcdUJERjEtXFx1QkUwQlxcdUJFMEQtXFx1QkUyN1xcdUJFMjktXFx1QkU0M1xcdUJFNDUtXFx1QkU1RlxcdUJFNjEtXFx1QkU3QlxcdUJFN0QtXFx1QkU5N1xcdUJFOTktXFx1QkVCM1xcdUJFQjUtXFx1QkVDRlxcdUJFRDEtXFx1QkVFQlxcdUJFRUQtXFx1QkYwN1xcdUJGMDktXFx1QkYyM1xcdUJGMjUtXFx1QkYzRlxcdUJGNDEtXFx1QkY1QlxcdUJGNUQtXFx1QkY3N1xcdUJGNzktXFx1QkY5M1xcdUJGOTUtXFx1QkZBRlxcdUJGQjEtXFx1QkZDQlxcdUJGQ0QtXFx1QkZFN1xcdUJGRTktXFx1QzAwM1xcdUMwMDUtXFx1QzAxRlxcdUMwMjEtXFx1QzAzQlxcdUMwM0QtXFx1QzA1N1xcdUMwNTktXFx1QzA3M1xcdUMwNzUtXFx1QzA4RlxcdUMwOTEtXFx1QzBBQlxcdUMwQUQtXFx1QzBDN1xcdUMwQzktXFx1QzBFM1xcdUMwRTUtXFx1QzBGRlxcdUMxMDEtXFx1QzExQlxcdUMxMUQtXFx1QzEzN1xcdUMxMzktXFx1QzE1M1xcdUMxNTUtXFx1QzE2RlxcdUMxNzEtXFx1QzE4QlxcdUMxOEQtXFx1QzFBN1xcdUMxQTktXFx1QzFDM1xcdUMxQzUtXFx1QzFERlxcdUMxRTEtXFx1QzFGQlxcdUMxRkQtXFx1QzIxN1xcdUMyMTktXFx1QzIzM1xcdUMyMzUtXFx1QzI0RlxcdUMyNTEtXFx1QzI2QlxcdUMyNkQtXFx1QzI4N1xcdUMyODktXFx1QzJBM1xcdUMyQTUtXFx1QzJCRlxcdUMyQzEtXFx1QzJEQlxcdUMyREQtXFx1QzJGN1xcdUMyRjktXFx1QzMxM1xcdUMzMTUtXFx1QzMyRlxcdUMzMzEtXFx1QzM0QlxcdUMzNEQtXFx1QzM2N1xcdUMzNjktXFx1QzM4M1xcdUMzODUtXFx1QzM5RlxcdUMzQTEtXFx1QzNCQlxcdUMzQkQtXFx1QzNEN1xcdUMzRDktXFx1QzNGM1xcdUMzRjUtXFx1QzQwRlxcdUM0MTEtXFx1QzQyQlxcdUM0MkQtXFx1QzQ0N1xcdUM0NDktXFx1QzQ2M1xcdUM0NjUtXFx1QzQ3RlxcdUM0ODEtXFx1QzQ5QlxcdUM0OUQtXFx1QzRCN1xcdUM0QjktXFx1QzREM1xcdUM0RDUtXFx1QzRFRlxcdUM0RjEtXFx1QzUwQlxcdUM1MEQtXFx1QzUyN1xcdUM1MjktXFx1QzU0M1xcdUM1NDUtXFx1QzU1RlxcdUM1NjEtXFx1QzU3QlxcdUM1N0QtXFx1QzU5N1xcdUM1OTktXFx1QzVCM1xcdUM1QjUtXFx1QzVDRlxcdUM1RDEtXFx1QzVFQlxcdUM1RUQtXFx1QzYwN1xcdUM2MDktXFx1QzYyM1xcdUM2MjUtXFx1QzYzRlxcdUM2NDEtXFx1QzY1QlxcdUM2NUQtXFx1QzY3N1xcdUM2NzktXFx1QzY5M1xcdUM2OTUtXFx1QzZBRlxcdUM2QjEtXFx1QzZDQlxcdUM2Q0QtXFx1QzZFN1xcdUM2RTktXFx1QzcwM1xcdUM3MDUtXFx1QzcxRlxcdUM3MjEtXFx1QzczQlxcdUM3M0QtXFx1Qzc1N1xcdUM3NTktXFx1Qzc3M1xcdUM3NzUtXFx1Qzc4RlxcdUM3OTEtXFx1QzdBQlxcdUM3QUQtXFx1QzdDN1xcdUM3QzktXFx1QzdFM1xcdUM3RTUtXFx1QzdGRlxcdUM4MDEtXFx1QzgxQlxcdUM4MUQtXFx1QzgzN1xcdUM4MzktXFx1Qzg1M1xcdUM4NTUtXFx1Qzg2RlxcdUM4NzEtXFx1Qzg4QlxcdUM4OEQtXFx1QzhBN1xcdUM4QTktXFx1QzhDM1xcdUM4QzUtXFx1QzhERlxcdUM4RTEtXFx1QzhGQlxcdUM4RkQtXFx1QzkxN1xcdUM5MTktXFx1QzkzM1xcdUM5MzUtXFx1Qzk0RlxcdUM5NTEtXFx1Qzk2QlxcdUM5NkQtXFx1Qzk4N1xcdUM5ODktXFx1QzlBM1xcdUM5QTUtXFx1QzlCRlxcdUM5QzEtXFx1QzlEQlxcdUM5REQtXFx1QzlGN1xcdUM5RjktXFx1Q0ExM1xcdUNBMTUtXFx1Q0EyRlxcdUNBMzEtXFx1Q0E0QlxcdUNBNEQtXFx1Q0E2N1xcdUNBNjktXFx1Q0E4M1xcdUNBODUtXFx1Q0E5RlxcdUNBQTEtXFx1Q0FCQlxcdUNBQkQtXFx1Q0FEN1xcdUNBRDktXFx1Q0FGM1xcdUNBRjUtXFx1Q0IwRlxcdUNCMTEtXFx1Q0IyQlxcdUNCMkQtXFx1Q0I0N1xcdUNCNDktXFx1Q0I2M1xcdUNCNjUtXFx1Q0I3RlxcdUNCODEtXFx1Q0I5QlxcdUNCOUQtXFx1Q0JCN1xcdUNCQjktXFx1Q0JEM1xcdUNCRDUtXFx1Q0JFRlxcdUNCRjEtXFx1Q0MwQlxcdUNDMEQtXFx1Q0MyN1xcdUNDMjktXFx1Q0M0M1xcdUNDNDUtXFx1Q0M1RlxcdUNDNjEtXFx1Q0M3QlxcdUNDN0QtXFx1Q0M5N1xcdUNDOTktXFx1Q0NCM1xcdUNDQjUtXFx1Q0NDRlxcdUNDRDEtXFx1Q0NFQlxcdUNDRUQtXFx1Q0QwN1xcdUNEMDktXFx1Q0QyM1xcdUNEMjUtXFx1Q0QzRlxcdUNENDEtXFx1Q0Q1QlxcdUNENUQtXFx1Q0Q3N1xcdUNENzktXFx1Q0Q5M1xcdUNEOTUtXFx1Q0RBRlxcdUNEQjEtXFx1Q0RDQlxcdUNEQ0QtXFx1Q0RFN1xcdUNERTktXFx1Q0UwM1xcdUNFMDUtXFx1Q0UxRlxcdUNFMjEtXFx1Q0UzQlxcdUNFM0QtXFx1Q0U1N1xcdUNFNTktXFx1Q0U3M1xcdUNFNzUtXFx1Q0U4RlxcdUNFOTEtXFx1Q0VBQlxcdUNFQUQtXFx1Q0VDN1xcdUNFQzktXFx1Q0VFM1xcdUNFRTUtXFx1Q0VGRlxcdUNGMDEtXFx1Q0YxQlxcdUNGMUQtXFx1Q0YzN1xcdUNGMzktXFx1Q0Y1M1xcdUNGNTUtXFx1Q0Y2RlxcdUNGNzEtXFx1Q0Y4QlxcdUNGOEQtXFx1Q0ZBN1xcdUNGQTktXFx1Q0ZDM1xcdUNGQzUtXFx1Q0ZERlxcdUNGRTEtXFx1Q0ZGQlxcdUNGRkQtXFx1RDAxN1xcdUQwMTktXFx1RDAzM1xcdUQwMzUtXFx1RDA0RlxcdUQwNTEtXFx1RDA2QlxcdUQwNkQtXFx1RDA4N1xcdUQwODktXFx1RDBBM1xcdUQwQTUtXFx1RDBCRlxcdUQwQzEtXFx1RDBEQlxcdUQwREQtXFx1RDBGN1xcdUQwRjktXFx1RDExM1xcdUQxMTUtXFx1RDEyRlxcdUQxMzEtXFx1RDE0QlxcdUQxNEQtXFx1RDE2N1xcdUQxNjktXFx1RDE4M1xcdUQxODUtXFx1RDE5RlxcdUQxQTEtXFx1RDFCQlxcdUQxQkQtXFx1RDFEN1xcdUQxRDktXFx1RDFGM1xcdUQxRjUtXFx1RDIwRlxcdUQyMTEtXFx1RDIyQlxcdUQyMkQtXFx1RDI0N1xcdUQyNDktXFx1RDI2M1xcdUQyNjUtXFx1RDI3RlxcdUQyODEtXFx1RDI5QlxcdUQyOUQtXFx1RDJCN1xcdUQyQjktXFx1RDJEM1xcdUQyRDUtXFx1RDJFRlxcdUQyRjEtXFx1RDMwQlxcdUQzMEQtXFx1RDMyN1xcdUQzMjktXFx1RDM0M1xcdUQzNDUtXFx1RDM1RlxcdUQzNjEtXFx1RDM3QlxcdUQzN0QtXFx1RDM5N1xcdUQzOTktXFx1RDNCM1xcdUQzQjUtXFx1RDNDRlxcdUQzRDEtXFx1RDNFQlxcdUQzRUQtXFx1RDQwN1xcdUQ0MDktXFx1RDQyM1xcdUQ0MjUtXFx1RDQzRlxcdUQ0NDEtXFx1RDQ1QlxcdUQ0NUQtXFx1RDQ3N1xcdUQ0NzktXFx1RDQ5M1xcdUQ0OTUtXFx1RDRBRlxcdUQ0QjEtXFx1RDRDQlxcdUQ0Q0QtXFx1RDRFN1xcdUQ0RTktXFx1RDUwM1xcdUQ1MDUtXFx1RDUxRlxcdUQ1MjEtXFx1RDUzQlxcdUQ1M0QtXFx1RDU1N1xcdUQ1NTktXFx1RDU3M1xcdUQ1NzUtXFx1RDU4RlxcdUQ1OTEtXFx1RDVBQlxcdUQ1QUQtXFx1RDVDN1xcdUQ1QzktXFx1RDVFM1xcdUQ1RTUtXFx1RDVGRlxcdUQ2MDEtXFx1RDYxQlxcdUQ2MUQtXFx1RDYzN1xcdUQ2MzktXFx1RDY1M1xcdUQ2NTUtXFx1RDY2RlxcdUQ2NzEtXFx1RDY4QlxcdUQ2OEQtXFx1RDZBN1xcdUQ2QTktXFx1RDZDM1xcdUQ2QzUtXFx1RDZERlxcdUQ2RTEtXFx1RDZGQlxcdUQ2RkQtXFx1RDcxN1xcdUQ3MTktXFx1RDczM1xcdUQ3MzUtXFx1RDc0RlxcdUQ3NTEtXFx1RDc2QlxcdUQ3NkQtXFx1RDc4N1xcdUQ3ODktXFx1RDdBM10kLztcbnZhciByZUV4dFBpY3QgPSAvXig/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkkLztcblxudmFyIGdldENvZGVwb2ludFR5cGUgPSAoY2hhciwgY29kZSkgPT4ge1xuICB2YXIgdHlwZSA9IENvZGVwb2ludFR5cGUuQW55O1xuXG4gIGlmIChjaGFyLnNlYXJjaChyZUV4dGVuZCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dGVuZDtcbiAgfVxuXG4gIGlmIChjb2RlID09PSAweDIwMGQpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuWldKO1xuICB9XG5cbiAgaWYgKGNvZGUgPj0gMHgxZjFlNiAmJiBjb2RlIDw9IDB4MWYxZmYpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUkk7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVQcmVwZW5kKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUHJlcGVuZDtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZVNwYWNpbmdNYXJrKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuU3BhY2luZ01hcms7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVMKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTDtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZVYpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5WO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlQ7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVMVikgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlTFZUKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTFZUO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlRXh0UGljdCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dFBpY3Q7XG4gIH1cblxuICByZXR1cm4gdHlwZTtcbn07XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoeCwgeSkge1xuICByZXR1cm4gKHggJiB5KSAhPT0gMDtcbn1cblxudmFyIE5vbkJvdW5kYXJ5UGFpcnMgPSBbLy8gR0I2XG5bQ29kZXBvaW50VHlwZS5MLCBDb2RlcG9pbnRUeXBlLkwgfCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5MVlRdLCAvLyBHQjdcbltDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5WLCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLlRdLCAvLyBHQjhcbltDb2RlcG9pbnRUeXBlLkxWVCB8IENvZGVwb2ludFR5cGUuVCwgQ29kZXBvaW50VHlwZS5UXSwgLy8gR0I5XG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuRXh0ZW5kIHwgQ29kZXBvaW50VHlwZS5aV0pdLCAvLyBHQjlhXG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuU3BhY2luZ01hcmtdLCAvLyBHQjliXG5bQ29kZXBvaW50VHlwZS5QcmVwZW5kLCBDb2RlcG9pbnRUeXBlLkFueV0sIC8vIEdCMTFcbltDb2RlcG9pbnRUeXBlLlpXSiwgQ29kZXBvaW50VHlwZS5FeHRQaWN0XSwgLy8gR0IxMiBhbmQgR0IxM1xuW0NvZGVwb2ludFR5cGUuUkksIENvZGVwb2ludFR5cGUuUkldXTtcblxuZnVuY3Rpb24gaXNCb3VuZGFyeVBhaXIobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIE5vbkJvdW5kYXJ5UGFpcnMuZmluZEluZGV4KHIgPT4gaW50ZXJzZWN0cyhsZWZ0LCByWzBdKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCByWzFdKSkgPT09IC0xO1xufVxuXG52YXIgZW5kaW5nRW1vamlaV0ogPSAvKD86W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyMzg4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA1XFx1MjYwNy1cXHUyNjEyXFx1MjYxNC1cXHUyNjg1XFx1MjY5MC1cXHUyNzA1XFx1MjcwOC1cXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2My1cXHUyNzY3XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERBRC1cXHVEREU1XFx1REUwMS1cXHVERTBGXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTNDLVxcdURFM0ZcXHVERTQ5LVxcdURGRkFdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDNEXFx1REQ0Ni1cXHVERTRGXFx1REU4MC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1RENGRlxcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REVGRl18XFx1RDgzRltcXHVEQzAwLVxcdURGRkRdKSg/OltcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDdGRFxcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RDMtXFx1MDhFMVxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUJFXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTA5RkVcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEFGQS1cXHUwQUZGXFx1MEIwMVxcdTBCM0NcXHUwQjNFXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU1LVxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFXFx1MEJDMFxcdTBCQ0RcXHUwQkQ3XFx1MEMwMFxcdTBDMDRcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDMlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwXFx1MEQwMVxcdTBEM0JcXHUwRDNDXFx1MEQzRVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgxXFx1MERDQVxcdTBEQ0ZcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MERERlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFDMFxcdTFCMDAtXFx1MUIwM1xcdTFCMzQtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjlcXHUxREZCLVxcdTFERkZcXHUyMDBDXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QTgyQ1xcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QThGRlxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlCRFxcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZGOUVcXHVGRjlGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODAzW1xcdUREMjQtXFx1REQyN1xcdURFQUJcXHVERUFDXFx1REY0Ni1cXHVERjUwXXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQyQlxcdUREMkQtXFx1REQzNFxcdURENzNcXHVERDgwXFx1REQ4MVxcdUREQjYtXFx1RERCRVxcdUREQzktXFx1RERDQ1xcdUREQ0ZcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERTNFXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQlxcdURGM0NcXHVERjNFXFx1REY0MFxcdURGNTdcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDNUVcXHVEQ0IwXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkRcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERBRlxcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgwNltcXHVEQzJGLVxcdURDMzdcXHVEQzM5XFx1REMzQVxcdUREMzBcXHVERDNCXFx1REQzQ1xcdUREM0VcXHVERDQzXFx1RERENC1cXHVEREQ3XFx1REREQVxcdUREREJcXHVEREUwXFx1REUwMS1cXHVERTBBXFx1REUzMy1cXHVERTM4XFx1REUzQi1cXHVERTNFXFx1REU0N1xcdURFNTEtXFx1REU1NlxcdURFNTktXFx1REU1QlxcdURFOEEtXFx1REU5NlxcdURFOThcXHVERTk5XXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XFx1REQzMS1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ1XFx1REQ0N1xcdUREOTBcXHVERDkxXFx1REQ5NVxcdUREOTdcXHVERUYzXFx1REVGNF18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY0RlxcdURGOEYtXFx1REY5MlxcdURGRTRdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NVxcdURENjctXFx1REQ2OVxcdURENkUtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdUREMzAtXFx1REQzNlxcdURFRUMtXFx1REVFRl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEQjQwW1xcdURDMjAtXFx1REM3RlxcdUREMDAtXFx1RERFRl0pKlxcdTIwMEQkLztcblxudmFyIGVuZHNXaXRoRW1vamlaV0ogPSBzdHIgPT4ge1xuICByZXR1cm4gc3RyLnNlYXJjaChlbmRpbmdFbW9qaVpXSikgIT09IC0xO1xufTtcblxudmFyIGVuZGluZ1JJcyA9IC8oPzpcXHVEODNDW1xcdURERTYtXFx1RERGRl0pKyQvZztcblxudmFyIGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMgPSBzdHIgPT4ge1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goZW5kaW5nUklzKTtcblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gQSBSSSBpcyByZXByZXNlbnRlZCBieSBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgIHZhciBudW1SSXMgPSBtYXRjaFswXS5sZW5ndGggLyAyO1xuICAgIHJldHVybiBudW1SSXMgJSAyID09PSAxO1xuICB9XG59O1xuXG4vKipcclxuICogU2hhcmVkIHRoZSBmdW5jdGlvbiB3aXRoIGlzRWxlbWVudFR5cGUgdXRpbGl0eVxyXG4gKi9cblxudmFyIGlzRWxlbWVudCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgIUVkaXRvci5pc0VkaXRvcih2YWx1ZSk7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cblxudmFyIEVsZW1lbnQgPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgJ0FuY2VzdG9yJyBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzQW5jZXN0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBFbGVtZW50YCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzRWxlbWVudCxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGFycmF5IG9mIGBFbGVtZW50YCBvYmplY3RzLlxyXG4gICAqL1xuICBpc0VsZW1lbnRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBFbGVtZW50LmlzRWxlbWVudCh2YWwpKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHNldCBvZiBwcm9wcyBpcyBhIHBhcnRpYWwgb2YgRWxlbWVudC5cclxuICAgKi9cbiAgaXNFbGVtZW50UHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4gIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBFbGVtZW50YCBpbnRlcmZhY2UgYW5kIGhhcyBlbGVtZW50S2V5IHdpdGggc2VsZWN0ZWQgdmFsdWUuXHJcbiAgICogRGVmYXVsdCBpdCBjaGVjayB0byBgdHlwZWAga2V5IHZhbHVlXHJcbiAgICovXG4gIGlzRWxlbWVudFR5cGU6IGZ1bmN0aW9uIGlzRWxlbWVudFR5cGUodmFsdWUsIGVsZW1lbnRWYWwpIHtcbiAgICB2YXIgZWxlbWVudEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3R5cGUnO1xuICAgIHJldHVybiBpc0VsZW1lbnQodmFsdWUpICYmIHZhbHVlW2VsZW1lbnRLZXldID09PSBlbGVtZW50VmFsO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIGVsZW1lbnQgbWF0Y2hlcyBzZXQgb2YgcHJvcGVydGllcy5cclxuICAgKlxyXG4gICAqIE5vdGU6IHRoaXMgY2hlY2tzIGN1c3RvbSBwcm9wZXJ0aWVzLCBhbmQgaXQgZG9lcyBub3QgZW5zdXJlIHRoYXQgYW55XHJcbiAgICogY2hpbGRyZW4gYXJlIGVxdWl2YWxlbnQuXHJcbiAgICovXG4gIG1hdGNoZXMoZWxlbWVudCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkNCA9IFtcInRleHRcIl0sXG4gICAgX2V4Y2x1ZGVkMiQzID0gW1widGV4dFwiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQ4KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ4KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkOChPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDgoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgSVNfRURJVE9SX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgRWRpdG9yID0ge1xuICAvKipcclxuICAgKiBHZXQgdGhlIGFuY2VzdG9yIGFib3ZlIGEgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICBhYm92ZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCk7XG4gICAgdmFyIHJldmVyc2UgPSBtb2RlID09PSAnbG93ZXN0JztcblxuICAgIGZvciAodmFyIFtuLCBwXSBvZiBFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICB2b2lkcyxcbiAgICAgIG1hdGNoLFxuICAgICAgcmV2ZXJzZVxuICAgIH0pKSB7XG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG4pICYmICFQYXRoLmVxdWFscyhwYXRoLCBwKSkge1xuICAgICAgICByZXR1cm4gW24sIHBdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBBZGQgYSBjdXN0b20gcHJvcGVydHkgdG8gdGhlIGxlYWYgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQsIHRoZSBtYXJrcyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxyXG4gICAqIGBlZGl0b3IubWFya3NgIHByb3BlcnR5IGluc3RlYWQsIGFuZCBhcHBsaWVkIHdoZW4gdGV4dCBpcyBpbnNlcnRlZCBuZXh0LlxyXG4gICAqL1xuICBhZGRNYXJrKGVkaXRvciwga2V5LCB2YWx1ZSkge1xuICAgIGVkaXRvci5hZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYWZ0ZXIgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgYWZ0ZXIoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgYW5jaG9yID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgdmFyIHtcbiAgICAgIGRpc3RhbmNlID0gMVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2VcbiAgICB9KSkpIHtcbiAgICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgIHRhcmdldCA9IHA7XG4gICAgICB9XG5cbiAgICAgIGQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYmVmb3JlIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGJlZm9yZShlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBhbmNob3IgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgdmFyIHtcbiAgICAgIGRpc3RhbmNlID0gMVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSkpKSB7XG4gICAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICB0YXJnZXQgPSBwO1xuICAgICAgfVxuXG4gICAgICBkKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGJhY2t3YXJkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVCYWNrd2FyZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHVuaXQgPSAnY2hhcmFjdGVyJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGZvcndhcmQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlbGV0ZUZvcndhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICBlZGl0b3IuZGVsZXRlRm9yd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgdGhlIGNvbnRlbnQgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVGcmFnbWVudChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVGcmFnbWVudChkaXJlY3Rpb24pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZWRnZXMoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBbRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpLCBFZGl0b3IuZW5kKGVkaXRvciwgYXQpXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBlbmQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ2VuZCdcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGZpcnN0IG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICAgIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZnJhZ21lbnQgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZnJhZ21lbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICB2YXIgZnJhZ21lbnQgPSBOb2RlLmZyYWdtZW50KGVkaXRvciwgcmFuZ2UpO1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgaGFzIGJsb2NrIGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNCbG9ja3MoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBoYXMgaW5saW5lIGFuZCB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNJbmxpbmVzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIGhhcyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNUZXh0cyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5ldmVyeShuID0+IFRleHQuaXNUZXh0KG4pKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBibG9jayBicmVhayBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBzb2Z0IGJyZWFrIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFNvZnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrKCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICAgIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgbm9kZSBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnROb2RlKGVkaXRvciwgbm9kZSkge1xuICAgIGVkaXRvci5pbnNlcnROb2RlKG5vZGUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgZWRpdG9yLmluc2VydFRleHQodGV4dCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGJsb2NrIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgJiYgIWVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBgRWRpdG9yYCBvYmplY3QuXHJcbiAgICovXG4gIGlzRWRpdG9yKHZhbHVlKSB7XG4gICAgdmFyIGNhY2hlZElzRWRpdG9yID0gSVNfRURJVE9SX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoY2FjaGVkSXNFZGl0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZElzRWRpdG9yO1xuICAgIH1cblxuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaXNFZGl0b3IgPSB0eXBlb2YgdmFsdWUuYWRkTWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuYXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUJhY2t3YXJkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVGb3J3YXJkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0QnJlYWsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFNvZnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0RnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzSW5saW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc1ZvaWQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm5vcm1hbGl6ZU5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm9uQ2hhbmdlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5yZW1vdmVNYXJrID09PSAnZnVuY3Rpb24nICYmICh2YWx1ZS5tYXJrcyA9PT0gbnVsbCB8fCBpc1BsYWluT2JqZWN0KHZhbHVlLm1hcmtzKSkgJiYgKHZhbHVlLnNlbGVjdGlvbiA9PT0gbnVsbCB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlLnNlbGVjdGlvbikpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgT3BlcmF0aW9uLmlzT3BlcmF0aW9uTGlzdCh2YWx1ZS5vcGVyYXRpb25zKTtcbiAgICBJU19FRElUT1JfQ0FDSEUuc2V0KHZhbHVlLCBpc0VkaXRvcik7XG4gICAgcmV0dXJuIGlzRWRpdG9yO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBpc0VuZChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIGVuZCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBhbiBlZGdlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzRWRnZShlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkgfHwgRWRpdG9yLmlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGVtcHR5LCBhY2NvdW50aW5nIGZvciB2b2lkIG5vZGVzLlxyXG4gICAqL1xuICBpc0VtcHR5KGVkaXRvciwgZWxlbWVudCkge1xuICAgIHZhciB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBlbGVtZW50O1xuICAgIHZhciBbZmlyc3RdID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQoZmlyc3QpICYmIGZpcnN0LnRleHQgPT09ICcnICYmICFlZGl0b3IuaXNWb2lkKGVsZW1lbnQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaW5saW5lIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzSW5saW5lKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQodmFsdWUpICYmIGVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGVkaXRvciBpcyBjdXJyZW50bHkgbm9ybWFsaXppbmcgYWZ0ZXIgZWFjaCBvcGVyYXRpb24uXHJcbiAgICovXG4gIGlzTm9ybWFsaXppbmcoZWRpdG9yKSB7XG4gICAgdmFyIGlzTm9ybWFsaXppbmcgPSBOT1JNQUxJWklORy5nZXQoZWRpdG9yKTtcbiAgICByZXR1cm4gaXNOb3JtYWxpemluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzTm9ybWFsaXppbmc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyB0aGUgc3RhcnQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIC8vIFBFUkY6IElmIHRoZSBvZmZzZXQgaXNuJ3QgYDBgIHdlIGtub3cgaXQncyBub3QgdGhlIHN0YXJ0LlxuICAgIGlmIChwb2ludC5vZmZzZXQgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhwb2ludCwgc3RhcnQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSB2b2lkIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzVm9pZChlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KHZhbHVlKSAmJiBlZGl0b3IuaXNWb2lkKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxhc3Qgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsYXN0KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsZWFmIHRleHQgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsZWFmKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIHBhdGgpO1xuICAgIHJldHVybiBbbm9kZSwgcGF0aF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgbGV2ZWxzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gICpsZXZlbHMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcblxuICAgIGZvciAodmFyIFtuLCBwXSBvZiBOb2RlLmxldmVscyhlZGl0b3IsIHBhdGgpKSB7XG4gICAgICBpZiAoIW1hdGNoKG4sIHApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXZlbHMucHVzaChbbiwgcF0pO1xuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGV2ZWxzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB5aWVsZCogbGV2ZWxzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWFya3MgdGhhdCB3b3VsZCBiZSBhZGRlZCB0byB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKi9cbiAgbWFya3MoZWRpdG9yKSB7XG4gICAgdmFyIHtcbiAgICAgIG1hcmtzLFxuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobWFya3MpIHtcbiAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICB2YXIgW21hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBbX25vZGVdID0gbWF0Y2g7XG5cbiAgICAgICAgdmFyIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9ub2RlLCBfZXhjbHVkZWQkNCk7XG5cbiAgICAgICAgcmV0dXJuIF9yZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIHZhciB7XG4gICAgICBwYXRoXG4gICAgfSA9IGFuY2hvcjtcbiAgICB2YXIgW25vZGVdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwYXRoKTtcblxuICAgIGlmIChhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgICAgfSk7XG4gICAgICB2YXIgYmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbilcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocHJldiAmJiBibG9jaykge1xuICAgICAgICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBwcmV2O1xuICAgICAgICB2YXIgWywgYmxvY2tQYXRoXSA9IGJsb2NrO1xuXG4gICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoYmxvY2tQYXRoLCBwcmV2UGF0aCkpIHtcbiAgICAgICAgICBub2RlID0gcHJldk5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyJDMpO1xuXG4gICAgcmV0dXJuIHJlc3Q7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBtYXRjaGluZyBub2RlIGluIHRoZSBicmFuY2ggb2YgdGhlIGRvY3VtZW50IGFmdGVyIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIG5leHQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50QWZ0ZXJMb2NhdGlvbiA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCB7XG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIGlmICghcG9pbnRBZnRlckxvY2F0aW9uKSByZXR1cm47XG4gICAgdmFyIFssIHRvXSA9IEVkaXRvci5sYXN0KGVkaXRvciwgW10pO1xuICAgIHZhciBzcGFuID0gW3BvaW50QWZ0ZXJMb2NhdGlvbi5wYXRoLCB0b107XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIFtwYXJlbnRdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KTtcblxuICAgICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBbbmV4dF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogc3BhbixcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBub2RlIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIG5vZGUoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgICByZXR1cm4gW25vZGUsIHBhdGhdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIG5vZGVzIGluIHRoZSBFZGl0b3IuXHJcbiAgICovXG4gICpub2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1vZGUgPSAnYWxsJyxcbiAgICAgIHVuaXZlcnNhbCA9IGZhbHNlLFxuICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJvbTtcbiAgICB2YXIgdG87XG5cbiAgICBpZiAoU3Bhbi5pc1NwYW4oYXQpKSB7XG4gICAgICBmcm9tID0gYXRbMF07XG4gICAgICB0byA9IGF0WzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3QgPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhc3QgPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICAgIGVkZ2U6ICdlbmQnXG4gICAgICB9KTtcbiAgICAgIGZyb20gPSByZXZlcnNlID8gbGFzdCA6IGZpcnN0O1xuICAgICAgdG8gPSByZXZlcnNlID8gZmlyc3QgOiBsYXN0O1xuICAgIH1cblxuICAgIHZhciBub2RlRW50cmllcyA9IE5vZGUubm9kZXMoZWRpdG9yLCB7XG4gICAgICByZXZlcnNlLFxuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgcGFzczogX3JlZiA9PiB7XG4gICAgICAgIHZhciBbbl0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gdm9pZHMgPyBmYWxzZSA6IEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBoaXQ7XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2Ygbm9kZUVudHJpZXMpIHtcbiAgICAgIHZhciBpc0xvd2VyID0gaGl0ICYmIFBhdGguY29tcGFyZShwYXRoLCBoaXRbMV0pID09PSAwOyAvLyBJbiBoaWdoZXN0IG1vZGUgYW55IG5vZGUgbG93ZXIgdGhhbiB0aGUgbGFzdCBoaXQgaXMgbm90IGEgbWF0Y2guXG5cbiAgICAgIGlmIChtb2RlID09PSAnaGlnaGVzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXRjaChub2RlLCBwYXRoKSkge1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhcnJpdmVkIGF0IGEgbGVhZiB0ZXh0IG5vZGUgdGhhdCBpcyBub3QgbG93ZXIgdGhhbiB0aGUgbGFzdFxuICAgICAgICAvLyBoaXQsIHRoZW4gd2UndmUgZm91bmQgYSBicmFuY2ggdGhhdCBkb2Vzbid0IGluY2x1ZGUgYSBtYXRjaCwgd2hpY2hcbiAgICAgICAgLy8gbWVhbnMgdGhlIG1hdGNoIGlzIG5vdCB1bml2ZXJzYWwuXG4gICAgICAgIGlmICh1bml2ZXJzYWwgJiYgIWlzTG93ZXIgJiYgVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgdGhlcmUncyBhIG1hdGNoIGFuZCBpdCdzIGxvd2VyIHRoYW4gdGhlIGxhc3QsIHVwZGF0ZSB0aGUgaGl0LlxuXG5cbiAgICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBpc0xvd2VyKSB7XG4gICAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIEluIGxvd2VzdCBtb2RlIHdlIGVtaXQgdGhlIGxhc3QgaGl0LCBvbmNlIGl0J3MgZ3VhcmFudGVlZCBsb3dlc3QuXG5cblxuICAgICAgdmFyIGVtaXQgPSBtb2RlID09PSAnbG93ZXN0JyA/IGhpdCA6IFtub2RlLCBwYXRoXTtcblxuICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbWl0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBlbWl0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICB9IC8vIFNpbmNlIGxvd2VzdCBpcyBhbHdheXMgZW1pdHRpbmcgb25lIGJlaGluZCwgY2F0Y2ggdXAgYXQgdGhlIGVuZC5cblxuXG4gICAgaWYgKG1vZGUgPT09ICdsb3dlc3QnICYmIGhpdCkge1xuICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goaGl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIGhpdDtcbiAgICAgIH1cbiAgICB9IC8vIFVuaXZlcnNhbCBkZWZlcnMgdG8gZW5zdXJlIHRoYXQgdGhlIG1hdGNoIG9jY3VycyBpbiBldmVyeSBicmFuY2gsIHNvIHdlXG4gICAgLy8geWllbGQgYWxsIG9mIHRoZSBtYXRjaGVzIGFmdGVyIGl0ZXJhdGluZy5cblxuXG4gICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgeWllbGQqIG1hdGNoZXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZSBhbnkgZGlydHkgb2JqZWN0cyBpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBub3JtYWxpemUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBmb3JjZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICB2YXIgZ2V0RGlydHlQYXRocyA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gICAgfTtcblxuICAgIHZhciBnZXREaXJ0eVBhdGhLZXlzID0gZWRpdG9yID0+IHtcbiAgICAgIHJldHVybiBESVJUWV9QQVRIX0tFWVMuZ2V0KGVkaXRvcikgfHwgbmV3IFNldCgpO1xuICAgIH07XG5cbiAgICB2YXIgcG9wRGlydHlQYXRoID0gZWRpdG9yID0+IHtcbiAgICAgIHZhciBwYXRoID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpLnBvcCgpO1xuICAgICAgdmFyIGtleSA9IHBhdGguam9pbignLCcpO1xuICAgICAgZ2V0RGlydHlQYXRoS2V5cyhlZGl0b3IpLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcblxuICAgIGlmICghRWRpdG9yLmlzTm9ybWFsaXppbmcoZWRpdG9yKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmb3JjZSkge1xuICAgICAgdmFyIGFsbFBhdGhzID0gQXJyYXkuZnJvbShOb2RlLm5vZGVzKGVkaXRvciksIF9yZWYyID0+IHtcbiAgICAgICAgdmFyIFssIHBdID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSk7XG4gICAgICB2YXIgYWxsUGF0aEtleXMgPSBuZXcgU2V0KGFsbFBhdGhzLm1hcChwID0+IHAuam9pbignLCcpKSk7XG4gICAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBhbGxQYXRocyk7XG4gICAgICBESVJUWV9QQVRIX0tFWVMuc2V0KGVkaXRvciwgYWxsUGF0aEtleXMpO1xuICAgIH1cblxuICAgIGlmIChnZXREaXJ0eVBhdGhzKGVkaXRvcikubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIC8qXHJcbiAgICAgICAgRml4IGRpcnR5IGVsZW1lbnRzIHdpdGggbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoKSBkb2VzIGZpeCB0aGlzLCBidXQgc29tZSBub3JtYWxpemF0aW9uIGZpeGVzIGFsc28gcmVxdWlyZSBpdCB0byB3b3JrLlxyXG4gICAgICAgIFJ1bm5pbmcgYW4gaW5pdGlhbCBwYXNzIGF2b2lkcyB0aGUgY2F0Y2gtMjIgcmFjZSBjb25kaXRpb24uXHJcbiAgICAgICovXG4gICAgICBmb3IgKHZhciBkaXJ0eVBhdGggb2YgZ2V0RGlydHlQYXRocyhlZGl0b3IpKSB7XG4gICAgICAgIGlmIChOb2RlLmhhcyhlZGl0b3IsIGRpcnR5UGF0aCkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIGRpcnR5UGF0aCk7XG4gICAgICAgICAgdmFyIFtub2RlLCBfXSA9IGVudHJ5O1xuICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIFRoZSBkZWZhdWx0IG5vcm1hbGl6ZXIgaW5zZXJ0cyBhbiBlbXB0eSB0ZXh0IG5vZGUgaW4gdGhpcyBzY2VuYXJpbywgYnV0IGl0IGNhbiBiZSBjdXN0b21pc2VkLlxyXG4gICAgICAgICAgICBTbyB0aGVyZSBpcyBzb21lIHJpc2sgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICAgICBBcyBsb25nIGFzIHRoZSBub3JtYWxpemVyIG9ubHkgaW5zZXJ0cyBjaGlsZCBub2RlcyBmb3IgdGhpcyBjYXNlIGl0IGlzIHNhZmUgdG8gZG8gaW4gYW55IG9yZGVyO1xyXG4gICAgICAgICAgICBieSBkZWZpbml0aW9uIGFkZGluZyBjaGlsZHJlbiB0byBhbiBlbXB0eSBub2RlIGNhbid0IGNhdXNlIG90aGVyIHBhdGhzIHRvIGNoYW5nZS5cclxuICAgICAgICAgICovXG5cbiAgICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG1heCA9IGdldERpcnR5UGF0aHMoZWRpdG9yKS5sZW5ndGggKiA0MjsgLy8gSEFDSzogYmV0dGVyIHdheT9cblxuICAgICAgdmFyIG0gPSAwO1xuXG4gICAgICB3aGlsZSAoZ2V0RGlydHlQYXRocyhlZGl0b3IpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBpZiAobSA+IG1heCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgICAgICAgIENvdWxkIG5vdCBjb21wbGV0ZWx5IG5vcm1hbGl6ZSB0aGUgZWRpdG9yIGFmdGVyIFwiLmNvbmNhdChtYXgsIFwiIGl0ZXJhdGlvbnMhIFRoaXMgaXMgdXN1YWxseSBkdWUgdG8gaW5jb3JyZWN0IG5vcm1hbGl6YXRpb24gbG9naWMgdGhhdCBsZWF2ZXMgYSBub2RlIGluIGFuIGludmFsaWQgc3RhdGUuXFxuICAgICAgICAgIFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2RpcnR5UGF0aCA9IHBvcERpcnR5UGF0aChlZGl0b3IpOyAvLyBJZiB0aGUgbm9kZSBkb2Vzbid0IGV4aXN0IGluIHRoZSB0cmVlLCBpdCBkb2VzIG5vdCBuZWVkIHRvIGJlIG5vcm1hbGl6ZWQuXG5cblxuICAgICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBfZGlydHlQYXRoKSkge1xuICAgICAgICAgIHZhciBfZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIF9kaXJ0eVBhdGgpO1xuXG4gICAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoX2VudHJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG0rKztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhcmVudCBub2RlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBhcmVudChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhcmVudFBhdGgpO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhdGggb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcGF0aChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBkZXB0aCxcbiAgICAgIGVkZ2VcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KTtcbiAgICAgICAgYXQgPSBmaXJzdFBhdGg7XG4gICAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIHZhciBbLCBsYXN0UGF0aF0gPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIGF0ID0gbGFzdFBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBhdCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgYXQgPSBSYW5nZS5lbmQoYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXQgPSBQYXRoLmNvbW1vbihhdC5hbmNob3IucGF0aCwgYXQuZm9jdXMucGF0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICBhdCA9IGF0LnBhdGg7XG4gICAgfVxuXG4gICAgaWYgKGRlcHRoICE9IG51bGwpIHtcbiAgICAgIGF0ID0gYXQuc2xpY2UoMCwgZGVwdGgpO1xuICAgIH1cblxuICAgIHJldHVybiBhdDtcbiAgfSxcblxuICBoYXNQYXRoKGVkaXRvciwgcGF0aCkge1xuICAgIHJldHVybiBOb2RlLmhhcyhlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG11dGFibGUgcmVmIGZvciBhIGBQYXRoYCBvYmplY3QsIHdoaWNoIHdpbGwgc3RheSBpbiBzeW5jIGFzIG5ld1xyXG4gICAqIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcGF0aFJlZihlZGl0b3IsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IHBhdGgsXG4gICAgICBhZmZpbml0eSxcblxuICAgICAgdW5yZWYoKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgY3VycmVudFxuICAgICAgICB9ID0gcmVmO1xuICAgICAgICB2YXIgcGF0aFJlZnMgPSBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKTtcbiAgICAgICAgcGF0aFJlZnMuZGVsZXRlKHJlZik7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIHZhciByZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gICAgcmVmcy5hZGQocmVmKTtcbiAgICByZXR1cm4gcmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSB0cmFja2VkIHBhdGggcmVmcyBvZiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBwYXRoUmVmcyhlZGl0b3IpIHtcbiAgICB2YXIgcmVmcyA9IFBBVEhfUkVGUy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghcmVmcykge1xuICAgICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgIFBBVEhfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmcztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IG9yIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBwb2ludChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBlZGdlID0gJ3N0YXJ0J1xuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgdmFyIHBhdGg7XG5cbiAgICAgIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpO1xuICAgICAgICBwYXRoID0gbGFzdFBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIHBhdGggPSBmaXJzdFBhdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBcIi5jb25jYXQoZWRnZSwgXCIgcG9pbnQgaW4gdGhlIG5vZGUgYXQgcGF0aCBbXCIpLmNvbmNhdChhdCwgXCJdIGJlY2F1c2UgaXQgaGFzIG5vIFwiKS5jb25jYXQoZWRnZSwgXCIgdGV4dCBub2RlLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldDogZWRnZSA9PT0gJ2VuZCcgPyBub2RlLnRleHQubGVuZ3RoIDogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICByZXR1cm4gZWRnZSA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogZW5kO1xuICAgIH1cblxuICAgIHJldHVybiBhdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUG9pbnRgIG9iamVjdCwgd2hpY2ggd2lsbCBzdGF5IGluIHN5bmMgYXMgbmV3XHJcbiAgICogb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBwb2ludFJlZihlZGl0b3IsIHBvaW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBwb2ludCxcbiAgICAgIGFmZmluaXR5LFxuXG4gICAgICB1bnJlZigpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBjdXJyZW50XG4gICAgICAgIH0gPSByZWY7XG4gICAgICAgIHZhciBwb2ludFJlZnMgPSBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcik7XG4gICAgICAgIHBvaW50UmVmcy5kZWxldGUocmVmKTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cblxuICAgIH07XG4gICAgdmFyIHJlZnMgPSBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcik7XG4gICAgcmVmcy5hZGQocmVmKTtcbiAgICByZXR1cm4gcmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSB0cmFja2VkIHBvaW50IHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcG9pbnRSZWZzKGVkaXRvcikge1xuICAgIHZhciByZWZzID0gUE9JTlRfUkVGUy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghcmVmcykge1xuICAgICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgIFBPSU5UX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGFsbCB0aGUgcG9zaXRpb25zIGluIGBhdGAgcmFuZ2Ugd2hlcmUgYSBgUG9pbnRgIGNhbiBiZSBwbGFjZWQuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBtb3ZlcyBmb3J3YXJkIGJ5IGluZGl2aWR1YWwgb2Zmc2V0cyBhdCBhIHRpbWUsIGJ1dFxyXG4gICAqIHRoZSBgdW5pdGAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHRvIG1vdmUgYnkgY2hhcmFjdGVyLCB3b3JkLCBsaW5lLCBvciBibG9jay5cclxuICAgKlxyXG4gICAqIFRoZSBgcmV2ZXJzZWAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSBpdGVyYXRpb24gZGlyZWN0aW9uLlxyXG4gICAqXHJcbiAgICogTm90ZTogQnkgZGVmYXVsdCB2b2lkIG5vZGVzIGFyZSB0cmVhdGVkIGFzIGEgc2luZ2xlIHBvaW50IGFuZCBpdGVyYXRpb25cclxuICAgKiB3aWxsIG5vdCBoYXBwZW4gaW5zaWRlIHRoZWlyIGNvbnRlbnQgdW5sZXNzIHlvdSBwYXNzIGluIHRydWUgZm9yIHRoZVxyXG4gICAqIGB2b2lkc2Agb3B0aW9uLCB0aGVuIGl0ZXJhdGlvbiB3aWxsIG9jY3VyLlxyXG4gICAqL1xuICAqcG9zaXRpb25zKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgdW5pdCA9ICdvZmZzZXQnLFxuICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEFsZ29yaXRobSBub3RlczpcclxuICAgICAqXHJcbiAgICAgKiBFYWNoIHN0ZXAgYGRpc3RhbmNlYCBpcyBkeW5hbWljIGRlcGVuZGluZyBvbiB0aGUgdW5kZXJseWluZyB0ZXh0XHJcbiAgICAgKiBhbmQgdGhlIGB1bml0YCBzcGVjaWZpZWQuICBFYWNoIHN0ZXAsIGUuZy4sIGEgbGluZSBvciB3b3JkLCBtYXlcclxuICAgICAqIHNwYW4gbXVsdGlwbGUgdGV4dCBub2Rlcywgc28gd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSB0ZXh0IGJvdGggb25cclxuICAgICAqIHR3byBsZXZlbHMgaW4gc3RlcC1zeW5jOlxyXG4gICAgICpcclxuICAgICAqIGBsZWFmVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgdGV4dCBsZWFmIGxldmVsLCBhbmQgaXMgYWR2YW5jZWRcclxuICAgICAqIHRocm91Z2ggdXNpbmcgdGhlIGNvdW50ZXJzIGBsZWFmVGV4dE9mZnNldGAgYW5kIGBsZWFmVGV4dFJlbWFpbmluZ2AuXHJcbiAgICAgKlxyXG4gICAgICogYGJsb2NrVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgYmxvY2sgbGV2ZWwsIGFuZCBpcyBzaG9ydGVuZWRcclxuICAgICAqIGJ5IGBkaXN0YW5jZWAgZXZlcnkgdGltZSBpdCBpcyBhZHZhbmNlZC5cclxuICAgICAqXHJcbiAgICAgKiBXZSBvbmx5IG1haW50YWluIGEgd2luZG93IG9mIG9uZSBibG9ja1RleHQgYW5kIG9uZSBsZWFmVGV4dCBiZWNhdXNlXHJcbiAgICAgKiBhIGJsb2NrIG5vZGUgYWx3YXlzIGFwcGVhcnMgYmVmb3JlIGFsbCBvZiBpdHMgbGVhZiBub2Rlcy5cclxuICAgICAqL1xuXG5cbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgZmlyc3QgPSByZXZlcnNlID8gZW5kIDogc3RhcnQ7XG4gICAgdmFyIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICB2YXIgYmxvY2tUZXh0ID0gJyc7XG4gICAgdmFyIGRpc3RhbmNlID0gMDsgLy8gRGlzdGFuY2UgZm9yIGxlYWZUZXh0IHRvIGNhdGNoIHVwIHRvIGJsb2NrVGV4dC5cblxuICAgIHZhciBsZWFmVGV4dFJlbWFpbmluZyA9IDA7XG4gICAgdmFyIGxlYWZUZXh0T2Zmc2V0ID0gMDsgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBub2RlcyBpbiByYW5nZSwgZ3JhYmJpbmcgZW50aXJlIHRleHR1YWwgY29udGVudFxuICAgIC8vIG9mIGJsb2NrIG5vZGVzIGluIGJsb2NrVGV4dCwgYW5kIHRleHQgbm9kZXMgaW4gbGVhZlRleHQuXG4gICAgLy8gRXhwbG9pdHMgdGhlIGZhY3QgdGhhdCBub2RlcyBhcmUgc2VxdWVuY2VkIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBmaXJzdFxuICAgIC8vIGVuY291bnRlciB0aGUgYmxvY2sgbm9kZSwgdGhlbiBhbGwgb2YgaXRzIHRleHQgbm9kZXMsIHNvIHdoZW4gaXRlcmF0aW5nXG4gICAgLy8gdGhyb3VnaCB0aGUgYmxvY2tUZXh0IGFuZCBsZWFmVGV4dCB3ZSBqdXN0IG5lZWQgdG8gcmVtZW1iZXIgYSB3aW5kb3cgb2ZcbiAgICAvLyBvbmUgYmxvY2sgbm9kZSBhbmQgbGVhZiBub2RlLCByZXNwZWN0aXZlbHkuXG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICByZXZlcnNlLFxuICAgICAgdm9pZHNcbiAgICB9KSkge1xuICAgICAgLypcclxuICAgICAgICogRUxFTUVOVCBOT0RFIC0gWWllbGQgcG9zaXRpb24ocykgZm9yIHZvaWRzLCBjb2xsZWN0IGJsb2NrVGV4dCBmb3IgYmxvY2tzXHJcbiAgICAgICAqL1xuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIC8vIFZvaWQgbm9kZXMgYXJlIGEgc3BlY2lhbCBjYXNlLCBzbyBieSBkZWZhdWx0IHdlIHdpbGwgYWx3YXlzXG4gICAgICAgIC8vIHlpZWxkIHRoZWlyIGZpcnN0IHBvaW50LiBJZiB0aGUgYHZvaWRzYCBvcHRpb24gaXMgc2V0IHRvIHRydWUsXG4gICAgICAgIC8vIHRoZW4gd2Ugd2lsbCBpdGVyYXRlIG92ZXIgdGhlaXIgY29udGVudC5cbiAgICAgICAgaWYgKCF2b2lkcyAmJiBlZGl0b3IuaXNWb2lkKG5vZGUpKSB7XG4gICAgICAgICAgeWllbGQgRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSW5saW5lIGVsZW1lbnQgbm9kZXMgYXJlIGlnbm9yZWQgYXMgdGhleSBkb24ndCB0aGVtc2VsdmVzXG4gICAgICAgIC8vIGNvbnRyaWJ1dGUgdG8gYGJsb2NrVGV4dGAgb3IgYGxlYWZUZXh0YCAtIHRoZWlyIHBhcmVudCBhbmRcbiAgICAgICAgLy8gY2hpbGRyZW4gZG8uXG5cblxuICAgICAgICBpZiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpKSBjb250aW51ZTsgLy8gQmxvY2sgZWxlbWVudCBub2RlIC0gc2V0IGBibG9ja1RleHRgIHRvIGl0cyB0ZXh0IGNvbnRlbnQuXG5cbiAgICAgICAgaWYgKEVkaXRvci5oYXNJbmxpbmVzKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICAvLyBXZSBhbHdheXMgZXhoYXVzdCBibG9jayBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGJsb2NrVGV4dCA9PT0gJycsXG4gICAgICAgICAgLy8gICAgIGBibG9ja1RleHQ9JyR7YmxvY2tUZXh0fScgLSBgK1xuICAgICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGJsb2NrIG5vZGVgLCBwYXRoKVxuICAgICAgICAgIC8vIEVuc3VyZSByYW5nZSBjb25zaWRlcmVkIGlzIGNhcHBlZCB0byBgcmFuZ2VgLCBpbiB0aGVcbiAgICAgICAgICAvLyBzdGFydC9lbmQgZWRnZSBjYXNlcyB3aGVyZSBibG9jayBleHRlbmRzIGJleW9uZCByYW5nZS5cbiAgICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHRoaXMsIGJ1dCBwcmVzdW1hYmx5IG1vcmUgcGVyZm9ybWFudDpcbiAgICAgICAgICAvLyAgIGJsb2NrUmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCAuLi5FZGl0b3IuZWRnZXMoZWRpdG9yLCBwYXRoKSlcbiAgICAgICAgICAvLyAgIGJsb2NrUmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UsIGJsb2NrUmFuZ2UpIC8vIGludGVyc2VjdFxuICAgICAgICAgIC8vICAgYmxvY2tUZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIGJsb2NrUmFuZ2UsIHsgdm9pZHMgfSlcbiAgICAgICAgICB2YXIgZSA9IFBhdGguaXNBbmNlc3RvcihwYXRoLCBlbmQucGF0aCkgPyBlbmQgOiBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgdmFyIHMgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgc3RhcnQucGF0aCkgPyBzdGFydCA6IEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCB7XG4gICAgICAgICAgICBhbmNob3I6IHMsXG4gICAgICAgICAgICBmb2N1czogZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaXNOZXdCbG9jayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qXHJcbiAgICAgICAqIFRFWFQgTEVBRiBOT0RFIC0gSXRlcmF0ZSB0aHJvdWdoIHRleHQgY29udGVudCwgeWllbGRpbmdcclxuICAgICAgICogcG9zaXRpb25zIGV2ZXJ5IGBkaXN0YW5jZWAgb2Zmc2V0IGFjY29yZGluZyB0byBgdW5pdGAuXHJcbiAgICAgICAqL1xuXG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICB2YXIgaXNGaXJzdCA9IFBhdGguZXF1YWxzKHBhdGgsIGZpcnN0LnBhdGgpOyAvLyBQcm9vZiB0aGF0IHdlIGFsd2F5cyBleGhhdXN0IHRleHQgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAgIC8vICAgY29uc29sZS5hc3NlcnQobGVhZlRleHRSZW1haW5pbmcgPD0gMCxcbiAgICAgICAgLy8gICAgIGBsZWFmVGV4dFJlbWFpbmluZz0ke2xlYWZUZXh0UmVtYWluaW5nfSAtIGArXG4gICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGxlYWYgdGV4dCBub2RlYCwgcGF0aClcbiAgICAgICAgLy8gUmVzZXQgYGxlYWZUZXh0YCBjb3VudGVycyBmb3IgbmV3IHRleHQgbm9kZS5cblxuICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gcmV2ZXJzZSA/IGZpcnN0Lm9mZnNldCA6IG5vZGUudGV4dC5sZW5ndGggLSBmaXJzdC5vZmZzZXQ7XG4gICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSBmaXJzdC5vZmZzZXQ7IC8vIFdvcmtzIGZvciByZXZlcnNlIHRvby5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IG5vZGUudGV4dC5sZW5ndGg7XG4gICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSByZXZlcnNlID8gbGVhZlRleHRSZW1haW5pbmcgOiAwO1xuICAgICAgICB9IC8vIFlpZWxkIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiBub2RlIChwb3RlbnRpYWxseSkuXG5cblxuICAgICAgICBpZiAoaXNGaXJzdCB8fCBpc05ld0Jsb2NrIHx8IHVuaXQgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG9mZnNldDogbGVhZlRleHRPZmZzZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgfSAvLyBZaWVsZCBwb3NpdGlvbnMgZXZlcnkgKGR5bmFtaWNhbGx5IGNhbGN1bGF0ZWQpIGBkaXN0YW5jZWAgb2Zmc2V0LlxuXG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAvLyBJZiBgbGVhZlRleHRgIGhhcyBjYXVnaHQgdXAgd2l0aCBgYmxvY2tUZXh0YCAoZGlzdGFuY2U9MCksXG4gICAgICAgICAgLy8gYW5kIGlmIGJsb2NrVGV4dCBpcyBleGhhdXN0ZWQsIGJyZWFrIHRvIGdldCBhbm90aGVyIGJsb2NrIG5vZGUsXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGFkdmFuY2UgYmxvY2tUZXh0IGZvcndhcmQgYnkgdGhlIG5ldyBgZGlzdGFuY2VgLlxuICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGJsb2NrVGV4dCA9PT0gJycpIGJyZWFrO1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBjYWxjRGlzdGFuY2UoYmxvY2tUZXh0LCB1bml0LCByZXZlcnNlKTsgLy8gU3BsaXQgdGhlIHN0cmluZyBhdCB0aGUgcHJldmlvdXNseSBmb3VuZCBkaXN0YW5jZSBhbmQgdXNlIHRoZVxuICAgICAgICAgICAgLy8gcmVtYWluaW5nIHN0cmluZyBmb3IgdGhlIG5leHQgaXRlcmF0aW9uLlxuXG4gICAgICAgICAgICBibG9ja1RleHQgPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UoYmxvY2tUZXh0LCBkaXN0YW5jZSwgcmV2ZXJzZSlbMV07XG4gICAgICAgICAgfSAvLyBBZHZhbmNlIGBsZWFmVGV4dGAgYnkgdGhlIGN1cnJlbnQgYGRpc3RhbmNlYC5cblxuXG4gICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSByZXZlcnNlID8gbGVhZlRleHRPZmZzZXQgLSBkaXN0YW5jZSA6IGxlYWZUZXh0T2Zmc2V0ICsgZGlzdGFuY2U7XG4gICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSBsZWFmVGV4dFJlbWFpbmluZyAtIGRpc3RhbmNlOyAvLyBJZiBgbGVhZlRleHRgIGlzIGV4aGF1c3RlZCwgYnJlYWsgdG8gZ2V0IGEgbmV3IGxlYWYgbm9kZVxuICAgICAgICAgIC8vIGFuZCBzZXQgZGlzdGFuY2UgdG8gdGhlIG92ZXJmbG93IGFtb3VudCwgc28gd2UnbGwgKG1heWJlKVxuICAgICAgICAgIC8vIGNhdGNoIHVwIHRvIGJsb2NrVGV4dCBpbiB0aGUgbmV4dCBsZWFmIHRleHQgbm9kZS5cblxuICAgICAgICAgIGlmIChsZWFmVGV4dFJlbWFpbmluZyA8IDApIHtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gLWxlYWZUZXh0UmVtYWluaW5nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSAvLyBTdWNjZXNzZnVsbHkgd2Fsa2VkIGBkaXN0YW5jZWAgb2Zmc2V0cyB0aHJvdWdoIGBsZWFmVGV4dGBcbiAgICAgICAgICAvLyB0byBjYXRjaCB1cCB3aXRoIGBibG9ja1RleHRgLCBzbyB3ZSBjYW4gcmVzZXQgYGRpc3RhbmNlYFxuICAgICAgICAgIC8vIGFuZCB5aWVsZCB0aGlzIHBvc2l0aW9uIGluIHRoaXMgbm9kZS5cblxuXG4gICAgICAgICAgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gUHJvb2YgdGhhdCB1cG9uIGNvbXBsZXRpb24sIHdlJ3ZlIGV4YWh1c3RlZCBib3RoIGxlYWYgYW5kIGJsb2NrIHRleHQ6XG4gICAgLy8gICBjb25zb2xlLmFzc2VydChsZWFmVGV4dFJlbWFpbmluZyA8PSAwLCBcImxlYWZUZXh0IHdhc24ndCBleGhhdXN0ZWRcIilcbiAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGJsb2NrVGV4dCA9PT0gJycsIFwiYmxvY2tUZXh0IHdhc24ndCBleGhhdXN0ZWRcIilcbiAgICAvLyBIZWxwZXI6XG4gICAgLy8gUmV0dXJuIHRoZSBkaXN0YW5jZSBpbiBvZmZzZXRzIGZvciBhIHN0ZXAgb2Ygc2l6ZSBgdW5pdGAgb24gZ2l2ZW4gc3RyaW5nLlxuXG5cbiAgICBmdW5jdGlvbiBjYWxjRGlzdGFuY2UodGV4dCwgdW5pdCwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHVuaXQgPT09ICdjaGFyYWN0ZXInKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCByZXZlcnNlKTtcbiAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3dvcmQnKSB7XG4gICAgICAgIHJldHVybiBnZXRXb3JkRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICdsaW5lJyB8fCB1bml0ID09PSAnYmxvY2snKSB7XG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWF0Y2hpbmcgbm9kZSBpbiB0aGUgYnJhbmNoIG9mIHRoZSBkb2N1bWVudCBiZWZvcmUgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcHJldmlvdXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50QmVmb3JlTG9jYXRpb24gPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIHtcbiAgICAgIHZvaWRzXG4gICAgfSk7XG5cbiAgICBpZiAoIXBvaW50QmVmb3JlTG9jYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgWywgdG9dID0gRWRpdG9yLmZpcnN0KGVkaXRvciwgW10pOyAvLyBUaGUgc2VhcmNoIGxvY2F0aW9uIGlzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudCB0byB0aGUgcGF0aCBvZlxuICAgIC8vIHRoZSBwb2ludCBiZWZvcmUgdGhlIGxvY2F0aW9uIHBhc3NlZCBpblxuXG4gICAgdmFyIHNwYW4gPSBbcG9pbnRCZWZvcmVMb2NhdGlvbi5wYXRoLCB0b107XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgW3ByZXZpb3VzXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICBhdDogc3BhbixcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHJhbmdlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHJhbmdlKGVkaXRvciwgYXQsIHRvKSB7XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmICF0bykge1xuICAgICAgcmV0dXJuIGF0O1xuICAgIH1cblxuICAgIHZhciBzdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIHRvIHx8IGF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG11dGFibGUgcmVmIGZvciBhIGBSYW5nZWAgb2JqZWN0LCB3aGljaCB3aWxsIHN0YXkgaW4gc3luYyBhcyBuZXdcclxuICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHJhbmdlUmVmKGVkaXRvciwgcmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IHJhbmdlLFxuICAgICAgYWZmaW5pdHksXG5cbiAgICAgIHVucmVmKCkge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgfSA9IHJlZjtcbiAgICAgICAgdmFyIHJhbmdlUmVmcyA9IEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKTtcbiAgICAgICAgcmFuZ2VSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuXG4gICAgfTtcbiAgICB2YXIgcmVmcyA9IEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKTtcbiAgICByZWZzLmFkZChyZWYpO1xuICAgIHJldHVybiByZWY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IHRyYWNrZWQgcmFuZ2UgcmVmcyBvZiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICByYW5nZVJlZnMoZWRpdG9yKSB7XG4gICAgdmFyIHJlZnMgPSBSQU5HRV9SRUZTLmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCFyZWZzKSB7XG4gICAgICByZWZzID0gbmV3IFNldCgpO1xuICAgICAgUkFOR0VfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmcztcbiAgfSxcblxuICAvKipcclxuICAgKiBSZW1vdmUgYSBjdXN0b20gcHJvcGVydHkgZnJvbSBhbGwgb2YgdGhlIGxlYWYgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudFxyXG4gICAqIHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGNvbGxhcHNlZCwgdGhlIHJlbW92YWwgd2lsbCBiZSBzdG9yZWQgb25cclxuICAgKiBgZWRpdG9yLm1hcmtzYCBhbmQgYXBwbGllZCB0byB0aGUgdGV4dCBpbnNlcnRlZCBuZXh0LlxyXG4gICAqL1xuICByZW1vdmVNYXJrKGVkaXRvciwga2V5KSB7XG4gICAgZWRpdG9yLnJlbW92ZU1hcmsoa2V5KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNYW51YWxseSBzZXQgaWYgdGhlIGVkaXRvciBzaG91bGQgY3VycmVudGx5IGJlIG5vcm1hbGl6aW5nLlxyXG4gICAqXHJcbiAgICogTm90ZTogVXNpbmcgdGhpcyBpbmNvcnJlY3RseSBjYW4gbGVhdmUgdGhlIGVkaXRvciBpbiBhbiBpbnZhbGlkIHN0YXRlLlxyXG4gICAqXHJcbiAgICovXG4gIHNldE5vcm1hbGl6aW5nKGVkaXRvciwgaXNOb3JtYWxpemluZykge1xuICAgIE5PUk1BTElaSU5HLnNldChlZGl0b3IsIGlzTm9ybWFsaXppbmcpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgc3RhcnQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgdGV4dCBzdHJpbmcgY29udGVudCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqXHJcbiAgICogTm90ZTogYnkgZGVmYXVsdCB0aGUgdGV4dCBvZiB2b2lkIG5vZGVzIGlzIGNvbnNpZGVyZWQgdG8gYmUgYW4gZW1wdHlcclxuICAgKiBzdHJpbmcsIHJlZ2FyZGxlc3Mgb2YgY29udGVudCwgdW5sZXNzIHlvdSBwYXNzIGluIHRydWUgZm9yIHRoZSB2b2lkcyBvcHRpb25cclxuICAgKi9cbiAgc3RyaW5nKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgdGV4dCA9ICcnO1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZSxcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIHZhciB0ID0gbm9kZS50ZXh0O1xuXG4gICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgIHQgPSB0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgICAgdCA9IHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdGV4dCArPSB0O1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYSByYW5nZSBpbnRvIGEgbm9uLWhhbmdpbmcgb25lLlxyXG4gICAqL1xuICB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTsgLy8gUEVSRjogZXhpdCBlYXJseSBpZiB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlIGlzbid0IGhhbmdpbmcuXG5cbiAgICBpZiAoc3RhcnQub2Zmc2V0ICE9PSAwIHx8IGVuZC5vZmZzZXQgIT09IDAgfHwgUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuXG4gICAgdmFyIGVuZEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgYXQ6IGVuZCxcbiAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbilcbiAgICB9KTtcbiAgICB2YXIgYmxvY2tQYXRoID0gZW5kQmxvY2sgPyBlbmRCbG9ja1sxXSA6IFtdO1xuICAgIHZhciBmaXJzdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHN0YXJ0KTtcbiAgICB2YXIgYmVmb3JlID0ge1xuICAgICAgYW5jaG9yOiBmaXJzdCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICAgIHZhciBza2lwID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogYmVmb3JlLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnRleHQgIT09ICcnIHx8IFBhdGguaXNCZWZvcmUocGF0aCwgYmxvY2tQYXRoKSkge1xuICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IG5vZGUudGV4dC5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaCBhIHZvaWQgbm9kZSBpbiB0aGUgY3VycmVudCBicmFuY2ggb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgdm9pZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIEVkaXRvci5hYm92ZShlZGl0b3IsIF9vYmplY3RTcHJlYWQkOChfb2JqZWN0U3ByZWFkJDgoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pXG4gICAgfSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENhbGwgYSBmdW5jdGlvbiwgZGVmZXJyaW5nIG5vcm1hbGl6YXRpb24gdW50aWwgYWZ0ZXIgaXQgY29tcGxldGVzLlxyXG4gICAqL1xuICB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIHZhciB2YWx1ZSA9IEVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcik7XG4gICAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgZmFsc2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7XG4gIH1cblxufTtcblxudmFyIExvY2F0aW9uID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0xvY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlKSB8fCBQb2ludC5pc1BvaW50KHZhbHVlKSB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlKTtcbiAgfVxuXG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTcGFuID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBTcGFuYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzU3Bhbih2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdmFsdWUuZXZlcnkoUGF0aC5pc1BhdGgpO1xuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcImNoaWxkcmVuXCJdLFxuICAgIF9leGNsdWRlZDIkMiA9IFtcInRleHRcIl07XG52YXIgSVNfTk9ERV9MSVNUX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgTm9kZSA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aCwgYXNzZXJ0aW5nIHRoYXQgaXQncyBhbiBhbmNlc3RvciBub2RlLlxyXG4gICAqL1xuICBhbmNlc3Rvcihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgYW5jZXN0b3Igbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgdGV4dCBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgYW5jZXN0b3Igbm9kZXMgYWJvdmUgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCB0aGUgb3JkZXIgaXMgdG9wLWRvd24sIGZyb20gaGlnaGVzdCB0byBsb3dlc3QgYW5jZXN0b3IgaW5cclxuICAgKiB0aGUgdHJlZSwgYnV0IHlvdSBjYW4gcGFzcyB0aGUgYHJldmVyc2U6IHRydWVgIG9wdGlvbiB0byBnbyBib3R0b20tdXAuXHJcbiAgICovXG4gICphbmNlc3RvcnMocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGZvciAodmFyIHAgb2YgUGF0aC5hbmNlc3RvcnMocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgIHZhciBuID0gTm9kZS5hbmNlc3Rvcihyb290LCBwKTtcbiAgICAgIHZhciBlbnRyeSA9IFtuLCBwXTtcbiAgICAgIHlpZWxkIGVudHJ5O1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNoaWxkIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIGluZGV4LlxyXG4gICAqL1xuICBjaGlsZChyb290LCBpbmRleCkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgY2hpbGQgb2YgYSB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHJvb3QuY2hpbGRyZW5baW5kZXhdO1xuXG4gICAgaWYgKGMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBjaGlsZCBhdCBpbmRleCBgXCIuY29uY2F0KGluZGV4LCBcImAgaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIG92ZXIgdGhlIGNoaWxkcmVuIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gICpjaGlsZHJlbihyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgYW5jZXN0b3IgPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHBhdGgpO1xuICAgIHZhciB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBhbmNlc3RvcjtcbiAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG5cbiAgICB3aGlsZSAocmV2ZXJzZSA/IGluZGV4ID49IDAgOiBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gTm9kZS5jaGlsZChhbmNlc3RvciwgaW5kZXgpO1xuICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgIHlpZWxkIFtjaGlsZCwgY2hpbGRQYXRoXTtcbiAgICAgIGluZGV4ID0gcmV2ZXJzZSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGFuIGVudHJ5IGZvciB0aGUgY29tbW9uIGFuY2VzZXRvciBub2RlIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uKHJvb3QsIHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgcCA9IFBhdGguY29tbW9uKHBhdGgsIGFub3RoZXIpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBhc3NlcnRpbmcgdGhhdCBpdCdzIGEgZGVzY2VuZGFudCBub2RlLlxyXG4gICAqL1xuICBkZXNjZW5kYW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuXG4gICAgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgZGVzY2VuZGFudCBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gdGhlIHJvb3QgZWRpdG9yIG5vZGUgaW5zdGVhZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBkZXNjZW5kYW50IG5vZGUgZW50cmllcyBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gICpkZXNjZW5kYW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNvZXJjZSBoZXJlIGJlY2F1c2UgY2hlY2tpbmcgdGhlIHBhdGgncyBsZW5ndGggZG9lc1xuICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgbm9kZWAgaXMgbm90IGEgYEVkaXRvcmAsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdy5cbiAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBlbGVtZW50IG5vZGVzIGluc2lkZSBhIHJvb3Qgbm9kZS4gRWFjaCBpdGVyYXRpb25cclxuICAgKiB3aWxsIHJldHVybiBhbiBgRWxlbWVudEVudHJ5YCB0dXBsZSBjb25zaXN0aW5nIG9mIGBbRWxlbWVudCwgUGF0aF1gLiBJZiB0aGVcclxuICAgKiByb290IG5vZGUgaXMgYW4gZWxlbWVudCBpdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBpdGVyYXRpb24gYXMgd2VsbC5cclxuICAgKi9cbiAgKmVsZW1lbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRXh0cmFjdCBwcm9wcyBmcm9tIGEgTm9kZS5cclxuICAgKi9cbiAgZXh0cmFjdFByb3BzKG5vZGUpIHtcbiAgICBpZiAoRWxlbWVudC5pc0FuY2VzdG9yKG5vZGUpKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQkMyk7XG5cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyJDIpO1xuXG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBmaXJzdCBub2RlIGVudHJ5IGluIGEgcm9vdCBub2RlIGZyb20gYSBwYXRoLlxyXG4gICAqL1xuICBmaXJzdChyb290LCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNsaWNlKCk7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcblxuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5jaGlsZHJlblswXTtcbiAgICAgICAgcC5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbiwgcF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzbGljZWQgZnJhZ21lbnQgcmVwcmVzZW50ZWQgYnkgYSByYW5nZSBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gIGZyYWdtZW50KHJvb3QsIHJhbmdlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGEgZnJhZ21lbnQgc3RhcnRpbmcgZnJvbSBhIHJvb3QgdGV4dCBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1Jvb3QgPSBwcm9kdWNlKHtcbiAgICAgIGNoaWxkcmVuOiByb290LmNoaWxkcmVuXG4gICAgfSwgciA9PiB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgICAgdmFyIG5vZGVFbnRyaWVzID0gTm9kZS5ub2RlcyhyLCB7XG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHBhc3M6IF9yZWYgPT4ge1xuICAgICAgICAgIHZhciBbLCBwYXRoXSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuICFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBbLCBwYXRoXSBvZiBub2RlRW50cmllcykge1xuICAgICAgICBpZiAoIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKSkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChyLCBwYXRoKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgdmFyIGxlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG4gICAgICAgICAgbGVhZi50ZXh0ID0gbGVhZi50ZXh0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgICAgdmFyIF9sZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuXG4gICAgICAgICAgX2xlYWYudGV4dCA9IF9sZWFmLnRleHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKHIpKSB7XG4gICAgICAgIHIuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Um9vdC5jaGlsZHJlbjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSByZWZlcnJlZCB0byBieSBhIHNwZWNpZmljIHBhdGguIElmIHRoZSBwYXRoIGlzIGFuXHJcbiAgICogZW1wdHkgYXJyYXksIGl0IHJlZmVycyB0byB0aGUgcm9vdCBub2RlIGl0c2VsZi5cclxuICAgKi9cbiAgZ2V0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGVzY2VuZGFudCBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgZGVzY2VuZGFudCBub2RlIGV4aXN0cyBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gIGhhcyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYE5vZGVgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbHVlKSB8fCBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgfHwgRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBgTm9kZWAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNOb2RlTGlzdCh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVkUmVzdWx0ID0gSVNfTk9ERV9MSVNUX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoY2FjaGVkUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGlzTm9kZUxpc3QgPSB2YWx1ZS5ldmVyeSh2YWwgPT4gTm9kZS5pc05vZGUodmFsKSk7XG4gICAgSVNfTk9ERV9MSVNUX0NBQ0hFLnNldCh2YWx1ZSwgaXNOb2RlTGlzdCk7XG4gICAgcmV0dXJuIGlzTm9kZUxpc3Q7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsYXN0IG5vZGUgZW50cnkgaW4gYSByb290IG5vZGUgZnJvbSBhIHBhdGguXHJcbiAgICovXG4gIGxhc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG5cbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pIHx8IG4uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSBuLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIG4gPSBuLmNoaWxkcmVuW2ldO1xuICAgICAgICBwLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBlbnN1cmluZyBpdCdzIGEgbGVhZiB0ZXh0IG5vZGUuXHJcbiAgICovXG4gIGxlYWYocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBsZWFmIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIG5vbi1sZWFmIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIHRoZSBpbiBhIGJyYW5jaCBvZiB0aGUgdHJlZSwgZnJvbSBhIHNwZWNpZmljIHBhdGguXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0IHRoZSBvcmRlciBpcyB0b3AtZG93biwgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBub2RlIGluIHRoZSB0cmVlLFxyXG4gICAqIGJ1dCB5b3UgY2FuIHBhc3MgdGhlIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gdG8gZ28gYm90dG9tLXVwLlxyXG4gICAqL1xuICAqbGV2ZWxzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBmb3IgKHZhciBwIG9mIFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgeWllbGQgW24sIHBdO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgbWF0Y2hlcyBhIHNldCBvZiBwcm9wcy5cclxuICAgKi9cbiAgbWF0Y2hlcyhub2RlLCBwcm9wcykge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudFByb3BzKHByb3BzKSAmJiBFbGVtZW50Lm1hdGNoZXMobm9kZSwgcHJvcHMpIHx8IFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0UHJvcHMocHJvcHMpICYmIFRleHQubWF0Y2hlcyhub2RlLCBwcm9wcyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgbm9kZSBlbnRyaWVzIG9mIGEgcm9vdCBub2RlLiBFYWNoIGVudHJ5IGlzXHJcbiAgICogcmV0dXJuZWQgYXMgYSBgW05vZGUsIFBhdGhdYCB0dXBsZSwgd2l0aCB0aGUgcGF0aCByZWZlcnJpbmcgdG8gdGhlIG5vZGUnc1xyXG4gICAqIHBvc2l0aW9uIGluc2lkZSB0aGUgcm9vdCBub2RlLlxyXG4gICAqL1xuICAqbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcGFzcyxcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBmcm9tID0gW10sXG4gICAgICB0b1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIG4gPSByb290O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikpIHtcbiAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBhbGxvd2VkIHRvIGdvIGRvd253YXJkIGFuZCB3ZSBoYXZlbid0IGRlc2NlbmRlZCB5ZXQsIGRvLlxuXG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSByZXZlcnNlID8gbi5jaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGZyb20pKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5jb25jYXQobmV4dEluZGV4KTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgd2UncmUgYXQgdGhlIHJvb3QgYW5kIHdlIGNhbid0IGdvIGRvd24sIHdlJ3JlIGRvbmUuXG5cblxuICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBmb3J3YXJkLi4uXG5cblxuICAgICAgaWYgKCFyZXZlcnNlKSB7XG4gICAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHApO1xuXG4gICAgICAgIGlmIChOb2RlLmhhcyhyb290LCBuZXdQYXRoKSkge1xuICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBiYWNrd2FyZC4uLlxuXG5cbiAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICB2YXIgX25ld1BhdGggPSBQYXRoLnByZXZpb3VzKHApO1xuXG4gICAgICAgIHAgPSBfbmV3UGF0aDtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlJ3JlIGdvaW5nIHVwd2FyZC4uLlxuXG5cbiAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG4pO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhcmVudCBvZiBhIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqL1xuICBwYXJlbnQocm9vdCwgcGF0aCkge1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIHAgPSBOb2RlLmdldChyb290LCBwYXJlbnRQYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IG9mIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm9vdC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29uY2F0ZW5hdGVkIHRleHQgc3RyaW5nIG9mIGEgbm9kZSdzIGNvbnRlbnQuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBpbmNsdWRlIHNwYWNlcyBvciBsaW5lIGJyZWFrcyBiZXR3ZWVuIGJsb2NrIG5vZGVzLlxyXG4gICAqIEl0IGlzIG5vdCBhIHVzZXItZmFjaW5nIHN0cmluZywgYnV0IGEgc3RyaW5nIGZvciBwZXJmb3JtaW5nIG9mZnNldC1yZWxhdGVkXHJcbiAgICogY29tcHV0YXRpb25zIGZvciBhIG5vZGUuXHJcbiAgICovXG4gIHN0cmluZyhub2RlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoTm9kZS5zdHJpbmcpLmpvaW4oJycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIGxlYWYgdGV4dCBub2RlcyBpbiBhIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgKnRleHRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ3KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ3KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDcoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBPcGVyYXRpb24gPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIG9mIGEgdmFsdWUgaXMgYSBgTm9kZU9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc05vZGVPcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfbm9kZScpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIG9mIGEgdmFsdWUgaXMgYW4gYE9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc09wZXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgUGF0aC5pc1BhdGgodmFsdWUubmV3UGF0aCk7XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUubmV3UHJvcGVydGllcykgfHwgdmFsdWUubmV3UHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLnByb3BlcnRpZXMpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYE9wZXJhdGlvbmAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNPcGVyYXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgb2YgYSB2YWx1ZSBpcyBhIGBTZWxlY3Rpb25PcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNTZWxlY3Rpb25PcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfc2VsZWN0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgb2YgYSB2YWx1ZSBpcyBhIGBUZXh0T3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzVGV4dE9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ190ZXh0Jyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW52ZXJ0IGFuIG9wZXJhdGlvbiwgcmV0dXJuaW5nIGEgbmV3IG9wZXJhdGlvbiB0aGF0IHdpbGwgZXhhY3RseSB1bmRvIHRoZVxyXG4gICAqIG9yaWdpbmFsIHdoZW4gYXBwbGllZC5cclxuICAgKi9cbiAgaW52ZXJzZShvcCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgucHJldmlvdXMob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIG5ld1BhdGgsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfSA9IG9wOyAvLyBQRVJGOiBpbiB0aGlzIGNhc2UgdGhlIG1vdmUgb3BlcmF0aW9uIGlzIGEgbm8tb3AgYW55d2F5cy5cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgaGFwcGVucyBjb21wbGV0ZWx5IHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgdGhlIHBhdGggYW5kXG4gICAgICAgICAgLy8gbmV3UGF0aCBhcmUgc3RhYmxlIHdpdGggcmVzcGVjdCB0byBlYWNoIG90aGVyLlxuXG5cbiAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocGF0aCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgZG9lcyBub3QgaGFwcGVuIHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgaXQgaXMgcG9zc2libGVcbiAgICAgICAgICAvLyBmb3IgdGhlIG1vdmUgdG8gaW1wYWN0IHRoZSB0cnVlIHBhdGggdG8gdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBub2RlXG4gICAgICAgICAgLy8gd2FzIHJlbW92ZWQgZnJvbSBhbmQgd2hlcmUgaXQgd2FzIGluc2VydGVkLiBXZSBoYXZlIHRvIGFkanVzdCBmb3IgdGhpc1xuICAgICAgICAgIC8vIGFuZCBmaW5kIHRoZSBvcmlnaW5hbCBwYXRoLiBXZSBjYW4gYWNjb21wbGlzaCB0aGlzIChvbmx5IGluIG5vbi1zaWJsaW5nKVxuICAgICAgICAgIC8vIG1vdmVzIGJ5IGxvb2tpbmcgYXQgdGhlIGltcGFjdCBvZiB0aGUgbW92ZSBvcGVyYXRpb24gb24gdGhlIG5vZGVcbiAgICAgICAgICAvLyBhZnRlciB0aGUgb3JpZ2luYWwgbW92ZSBwYXRoLlxuXG5cbiAgICAgICAgICB2YXIgaW52ZXJzZVBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgdmFyIGludmVyc2VOZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0oUGF0aC5uZXh0KHBhdGgpLCBvcCk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHBhdGg6IGludmVyc2VQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aDogaW52ZXJzZU5ld1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBuZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IF9wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX3Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLm5leHQob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG52YXIgUGF0aCA9IHtcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBhbmNlc3RvciBwYXRocyBmb3IgYSBnaXZlbiBwYXRoLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QgYW5jZXN0b3IuIEhvd2V2ZXIsIGlmIHRoZVxyXG4gICAqIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgYW5jZXN0b3JzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBwYXRocyA9IFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMCwgLTEpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRocztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNvbW1vbiBhbmNlc3RvciBwYXRoIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgY29tbW9uID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoICYmIGkgPCBhbm90aGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcblxuICAgICAgaWYgKGF2ICE9PSBidikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29tbW9uLnB1c2goYXYpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tb247XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHBhdGggdG8gYW5vdGhlciwgcmV0dXJuaW5nIGFuIGludGVnZXIgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYXRoXHJcbiAgICogd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKlxyXG4gICAqIE5vdGU6IFR3byBwYXRocyBvZiB1bmVxdWFsIGxlbmd0aCBjYW4gc3RpbGwgcmVjZWl2ZSBhIGAwYCByZXN1bHQgaWYgb25lIGlzXHJcbiAgICogZGlyZWN0bHkgYWJvdmUgb3IgYmVsb3cgdGhlIG90aGVyLiBJZiB5b3Ugd2FudCBleGFjdCBtYXRjaGluZywgdXNlXHJcbiAgICogW1tQYXRoLmVxdWFsc11dIGluc3RlYWQuXHJcbiAgICovXG4gIGNvbXBhcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihwYXRoLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gPCBhbm90aGVyW2ldKSByZXR1cm4gLTE7XG4gICAgICBpZiAocGF0aFtpXSA+IGFub3RoZXJbaV0pIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBlbmRzIGFmdGVyIG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPiBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBhdCBvbmUgb2YgdGhlIGluZGV4ZXMgaW4gYW5vdGhlci5cclxuICAgKi9cbiAgZW5kc0F0KHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBiZWZvcmUgb25lIG9mIHRoZSBpbmRleGVzIGluIGFub3RoZXIuXHJcbiAgICovXG4gIGVuZHNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPCBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHMocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggJiYgcGF0aC5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYW5vdGhlcltpXSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHBhdGggb2YgcHJldmlvdXMgc2libGluZyBub2RlIGV4aXN0c1xyXG4gICAqL1xuICBoYXNQcmV2aW91cyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA+IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFmdGVyIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQW5jZXN0b3IocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYSBjaGlsZCBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0NoaWxkKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICsgMSAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGVxdWFsIHRvIG9yIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQ29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPD0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIGRlc2NlbmRhbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNEZXNjZW5kYW50KHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIHRoZSBwYXJlbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNQYXJlbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCArIDEgPT09IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpcyBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBQYXRoYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUGF0aCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIHNpYmxpbmcgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNTaWJsaW5nKHBhdGgsIGFub3RoZXIpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGFsID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHZhciBibCA9IGFub3RoZXJbYW5vdGhlci5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gYWwgIT09IGJsICYmIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBwYXRocyBhdCBldmVyeSBsZXZlbCBkb3duIHRvIGEgcGF0aC4gTm90ZTogdGhpcyBpcyB0aGUgc2FtZVxyXG4gICAqIGFzIGBQYXRoLmFuY2VzdG9yc2AsIGJ1dCBpbmNsdWRpbmcgdGhlIHBhdGggaXRzZWxmLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QuIEhvd2V2ZXIsIGlmIHRoZSBgcmV2ZXJzZTpcclxuICAgKiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgbGV2ZWxzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBsaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LnB1c2gocGF0aC5zbGljZSgwLCBpKSk7XG4gICAgfVxuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxpc3QucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdpdmVuIGEgcGF0aCwgZ2V0IHRoZSBwYXRoIHRvIHRoZSBuZXh0IHNpYmxpbmcgbm9kZS5cclxuICAgKi9cbiAgbmV4dChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIG5leHQgaW5kZXguXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgKyAxKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvcGVyYXRpb24gY2FuIGFmZmVjdCBwYXRocyBvciBub3QuIFVzZWQgYXMgYW5cclxuICAgKiBvcHRpbWl6YXRpb24gd2hlbiB1cGRhdGluZyBkaXJ0eSBwYXRocyBkdXJpbmcgbm9ybWFsaXphdGlvblxyXG4gICAqXHJcbiAgICogTk9URTogVGhpcyAqbXVzdCogYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIGltcGxlbWVudGF0aW9uIG9mICd0cmFuc2Zvcm0nXHJcbiAgICogYmVsb3dcclxuICAgKi9cbiAgb3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcGVyYXRpb24pIHtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBwYXRoLCByZXR1cm4gYSBuZXcgcGF0aCByZWZlcnJpbmcgdG8gdGhlIHBhcmVudCBub2RlIGFib3ZlIGl0LlxyXG4gICAqL1xuICBwYXJlbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IHBhdGggb2YgdGhlIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXS5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHaXZlbiBhIHBhdGgsIGdldCB0aGUgcGF0aCB0byB0aGUgcHJldmlvdXMgc2libGluZyBub2RlLlxyXG4gICAqL1xuICBwcmV2aW91cyhwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBwcmV2aW91cyBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3QgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIGZpcnN0IGNoaWxkIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBuZWdhdGl2ZSBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCAtIDEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHBhdGggcmVsYXRpdmUgdG8gYW4gYW5jZXN0b3IuXHJcbiAgICovXG4gIHJlbGF0aXZlKHBhdGgsIGFuY2VzdG9yKSB7XG4gICAgaWYgKCFQYXRoLmlzQW5jZXN0b3IoYW5jZXN0b3IsIHBhdGgpICYmICFQYXRoLmVxdWFscyhwYXRoLCBhbmNlc3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHJlbGF0aXZlIHBhdGggb2YgW1wiLmNvbmNhdChwYXRoLCBcIl0gaW5zaWRlIGFuY2VzdG9yIFtcIikuY29uY2F0KGFuY2VzdG9yLCBcIl0sIGJlY2F1c2UgaXQgaXMgbm90IGFib3ZlIG9yIGVxdWFsIHRvIHRoZSBwYXRoLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoYW5jZXN0b3IubGVuZ3RoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwYXRoIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHBhdGgsIG9wZXJhdGlvbikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gcHJvZHVjZShwYXRoLCBwID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgICB9ID0gb3B0aW9uczsgLy8gUEVSRjogRXhpdCBlYXJseSBpZiB0aGUgb3BlcmF0aW9uIGlzIGd1YXJhbnRlZWQgbm90IHRvIGhhdmUgYW4gZWZmZWN0LlxuXG4gICAgICBpZiAoIXBhdGggfHwgKHBhdGggPT09IG51bGwgfHwgcGF0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF0aC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IG9wXG4gICAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AsIHApIHx8IFBhdGguZW5kc0JlZm9yZShvcCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9wLCBwKSkge1xuICAgICAgICAgICAgICBwW29wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgcGF0aDogX29wXG4gICAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3IoX29wLCBwKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3AubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9vcDIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wMiwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKF9vcDIsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMiwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICAgIHBbX29wMi5sZW5ndGhdICs9IHBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgcGF0aDogX29wMyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IF9wb3NpdGlvblxuICAgICAgICAgICAgfSA9IG9wZXJhdGlvbjtcblxuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDMsIHApKSB7XG4gICAgICAgICAgICAgIGlmIChhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICAgICAgcFtwLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdiYWNrd2FyZCcpIDsgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDMsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMywgcCkgJiYgcGF0aFtfb3AzLmxlbmd0aF0gPj0gX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgICBwW19vcDMubGVuZ3RoXSAtPSBfcG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9vcDQsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IG9ucFxuICAgICAgICAgICAgfSA9IG9wZXJhdGlvbjsgLy8gSWYgdGhlIG9sZCBhbmQgbmV3IHBhdGggYXJlIHRoZSBzYW1lLCBpdCdzIGEgbm8tb3AuXG5cbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3A0LCBvbnApKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3A0LCBwKSB8fCBQYXRoLmVxdWFscyhfb3A0LCBwKSkge1xuICAgICAgICAgICAgICB2YXIgY29weSA9IG9ucC5zbGljZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgb25wKSAmJiBfb3A0Lmxlbmd0aCA8IG9ucC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb3B5W19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBjb3B5LmNvbmNhdChwLnNsaWNlKF9vcDQubGVuZ3RoKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNTaWJsaW5nKF9vcDQsIG9ucCkgJiYgKFBhdGguaXNBbmNlc3RvcihvbnAsIHApIHx8IFBhdGguZXF1YWxzKG9ucCwgcCkpKSB7XG4gICAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvbnAsIHApKSB7XG4gICAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob25wLCBwKSkge1xuICAgICAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn07XG5cbnZhciBQYXRoUmVmID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIHBhdGggcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBQYXRoLnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBhdGg7XG5cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ2KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ2KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDYoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBQb2ludCA9IHtcbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHBvaW50IHRvIGFub3RoZXIsIHJldHVybmluZyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgd2hldGhlciB0aGVcclxuICAgKiBwb2ludCB3YXMgYmVmb3JlLCBhdCwgb3IgYWZ0ZXIgdGhlIG90aGVyLlxyXG4gICAqL1xuICBjb21wYXJlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFBhdGguY29tcGFyZShwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA8IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gLTE7XG4gICAgICBpZiAocG9pbnQub2Zmc2V0ID4gYW5vdGhlci5vZmZzZXQpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGFmdGVyIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQWZ0ZXIocG9pbnQsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuY29tcGFyZShwb2ludCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBiZWZvcmUgYW5vdGhlci5cclxuICAgKi9cbiAgaXNCZWZvcmUocG9pbnQsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuY29tcGFyZShwb2ludCwgYW5vdGhlcikgPT09IC0xO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHMocG9pbnQsIGFub3RoZXIpIHtcbiAgICAvLyBQRVJGOiBlbnN1cmUgdGhlIG9mZnNldHMgYXJlIGVxdWFsIGZpcnN0IHNpbmNlIHRoZXkgYXJlIGNoZWFwZXIgdG8gY2hlY2suXG4gICAgcmV0dXJuIHBvaW50Lm9mZnNldCA9PT0gYW5vdGhlci5vZmZzZXQgJiYgUGF0aC5lcXVhbHMocG9pbnQucGF0aCwgYW5vdGhlci5wYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBQb2ludGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1BvaW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5vZmZzZXQgPT09ICdudW1iZXInICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIHBvaW50IGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHBvaW50LCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gcHJvZHVjZShwb2ludCwgcCA9PiB7XG4gICAgICBpZiAocCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gcDtcblxuICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiAob3Aub2Zmc2V0IDwgb2Zmc2V0IHx8IG9wLm9mZnNldCA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpKSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0ICs9IG9wLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0ICs9IG9wLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiBvcC5vZmZzZXQgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0IC09IE1hdGgubWluKG9mZnNldCAtIG9wLm9mZnNldCwgb3AudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgaWYgKG9wLnBvc2l0aW9uID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wLnBvc2l0aW9uIDwgb2Zmc2V0IHx8IG9wLnBvc2l0aW9uID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICAgIHAub2Zmc2V0IC09IG9wLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgIGFmZmluaXR5OiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn07XG5cbnZhciBQb2ludFJlZiA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBwb2ludCByZWYncyBjdXJyZW50IHZhbHVlIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGFmZmluaXR5XG4gICAgfSA9IHJlZjtcblxuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnQgPSBQb2ludC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwb2ludDtcblxuICAgIGlmIChwb2ludCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cblxufTtcblxudmFyIF9leGNsdWRlZCQyID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkNShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDUoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ1KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgUmFuZ2UgPSB7XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgb2YgYSByYW5nZSwgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyXHJcbiAgICogaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICBlZGdlcyhyYW5nZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcmV2ZXJzZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKSA9PT0gcmV2ZXJzZSA/IFthbmNob3IsIGZvY3VzXSA6IFtmb2N1cywgYW5jaG9yXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZCBwb2ludCBvZiBhIHJhbmdlLlxyXG4gICAqL1xuICBlbmQocmFuZ2UpIHtcbiAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICByZXR1cm4gZW5kO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHMocmFuZ2UsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKHJhbmdlLmFuY2hvciwgYW5vdGhlci5hbmNob3IpICYmIFBvaW50LmVxdWFscyhyYW5nZS5mb2N1cywgYW5vdGhlci5mb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpbmNsdWRlcyBhIHBhdGgsIGEgcG9pbnQgb3IgcGFydCBvZiBhbm90aGVyIHJhbmdlLlxyXG4gICAqL1xuICBpbmNsdWRlcyhyYW5nZSwgdGFyZ2V0KSB7XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UodGFyZ2V0KSkge1xuICAgICAgaWYgKFJhbmdlLmluY2x1ZGVzKHJhbmdlLCB0YXJnZXQuYW5jaG9yKSB8fCBSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmZvY3VzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIFtycywgcmVdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgICAgdmFyIFt0cywgdGVdID0gUmFuZ2UuZWRnZXModGFyZ2V0KTtcbiAgICAgIHJldHVybiBQb2ludC5pc0JlZm9yZShycywgdHMpICYmIFBvaW50LmlzQWZ0ZXIocmUsIHRlKTtcbiAgICB9XG5cbiAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciBpc0FmdGVyU3RhcnQgPSBmYWxzZTtcbiAgICB2YXIgaXNCZWZvcmVFbmQgPSBmYWxzZTtcblxuICAgIGlmIChQb2ludC5pc1BvaW50KHRhcmdldCkpIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBzdGFydCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUG9pbnQuY29tcGFyZSh0YXJnZXQsIGVuZCkgPD0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBZnRlclN0YXJ0ID0gUGF0aC5jb21wYXJlKHRhcmdldCwgc3RhcnQucGF0aCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUGF0aC5jb21wYXJlKHRhcmdldCwgZW5kLnBhdGgpIDw9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzQWZ0ZXJTdGFydCAmJiBpc0JlZm9yZUVuZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGludGVyc2VjdGlvbiBvZiBhIHJhbmdlIHdpdGggYW5vdGhlci5cclxuICAgKi9cbiAgaW50ZXJzZWN0aW9uKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmFuZ2UsIF9leGNsdWRlZCQyKTtcblxuICAgIHZhciBbczEsIGUxXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgW3MyLCBlMl0gPSBSYW5nZS5lZGdlcyhhbm90aGVyKTtcbiAgICB2YXIgc3RhcnQgPSBQb2ludC5pc0JlZm9yZShzMSwgczIpID8gczIgOiBzMTtcbiAgICB2YXIgZW5kID0gUG9pbnQuaXNCZWZvcmUoZTEsIGUyKSA/IGUxIDogZTI7XG5cbiAgICBpZiAoUG9pbnQuaXNCZWZvcmUoZW5kLCBzdGFydCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ1KHtcbiAgICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgICAgZm9jdXM6IGVuZFxuICAgICAgfSwgcmVzdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgYmFja3dhcmQsIG1lYW5pbmcgdGhhdCBpdHMgYW5jaG9yIHBvaW50IGFwcGVhcnMgaW4gdGhlXHJcbiAgICogZG9jdW1lbnQgX2FmdGVyXyBpdHMgZm9jdXMgcG9pbnQuXHJcbiAgICovXG4gIGlzQmFja3dhcmQocmFuZ2UpIHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIFBvaW50LmlzQWZ0ZXIoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBjb2xsYXBzZWQsIG1lYW5pbmcgdGhhdCBib3RoIGl0cyBhbmNob3IgYW5kIGZvY3VzXHJcbiAgICogcG9pbnRzIHJlZmVyIHRvIHRoZSBleGFjdCBzYW1lIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgaXNDb2xsYXBzZWQocmFuZ2UpIHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhhbmNob3IsIGZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGV4cGFuZGVkLlxyXG4gICAqXHJcbiAgICogVGhpcyBpcyB0aGUgb3Bwb3NpdGUgb2YgW1tSYW5nZS5pc0NvbGxhcHNlZF1dIGFuZCBpcyBwcm92aWRlZCBmb3IgbGVnaWJpbGl0eS5cclxuICAgKi9cbiAgaXNFeHBhbmRlZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgZm9yd2FyZC5cclxuICAgKlxyXG4gICAqIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIFtbUmFuZ2UuaXNCYWNrd2FyZF1dIGFuZCBpcyBwcm92aWRlZCBmb3IgbGVnaWJpbGl0eS5cclxuICAgKi9cbiAgaXNGb3J3YXJkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIFtbUmFuZ2VdXSBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUmFuZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgUG9pbnQuaXNQb2ludCh2YWx1ZS5hbmNob3IpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIHBvaW50IGVudHJpZXMgaW4gYSByYW5nZS5cclxuICAgKi9cbiAgKnBvaW50cyhyYW5nZSkge1xuICAgIHlpZWxkIFtyYW5nZS5hbmNob3IsICdhbmNob3InXTtcbiAgICB5aWVsZCBbcmFuZ2UuZm9jdXMsICdmb2N1cyddO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgcG9pbnQgb2YgYSByYW5nZS5cclxuICAgKi9cbiAgc3RhcnQocmFuZ2UpIHtcbiAgICB2YXIgW3N0YXJ0XSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICByZXR1cm4gc3RhcnQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIGEgcmFuZ2UgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0ocmFuZ2UsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBwcm9kdWNlKHJhbmdlLCByID0+IHtcbiAgICAgIGlmIChyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICBhZmZpbml0eSA9ICdpbndhcmQnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciBhZmZpbml0eUFuY2hvcjtcbiAgICAgIHZhciBhZmZpbml0eUZvY3VzO1xuXG4gICAgICBpZiAoYWZmaW5pdHkgPT09ICdpbndhcmQnKSB7XG4gICAgICAgIC8vIElmIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQsIG1ha2Ugc3VyZSB0byB1c2UgdGhlIHNhbWUgYWZmaW5pdHkgdG9cbiAgICAgICAgLy8gYXZvaWQgdGhlIHR3byBwb2ludHMgcGFzc2luZyBlYWNoIG90aGVyIGFuZCBleHBhbmRpbmcgaW4gdGhlIG9wcG9zaXRlXG4gICAgICAgIC8vIGRpcmVjdGlvblxuICAgICAgICB2YXIgaXNDb2xsYXBzZWQgPSBSYW5nZS5pc0NvbGxhcHNlZChyKTtcblxuICAgICAgICBpZiAoUmFuZ2UuaXNGb3J3YXJkKHIpKSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGlzQ29sbGFwc2VkID8gYWZmaW5pdHlBbmNob3IgOiAnYmFja3dhcmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gaXNDb2xsYXBzZWQgPyBhZmZpbml0eUFuY2hvciA6ICdmb3J3YXJkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhZmZpbml0eSA9PT0gJ291dHdhcmQnKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0ZvcndhcmQocikpIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdiYWNrd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdmb3J3YXJkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdmb3J3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2JhY2t3YXJkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWZmaW5pdHlBbmNob3IgPSBhZmZpbml0eTtcbiAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGFmZmluaXR5O1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5jaG9yID0gUG9pbnQudHJhbnNmb3JtKHIuYW5jaG9yLCBvcCwge1xuICAgICAgICBhZmZpbml0eTogYWZmaW5pdHlBbmNob3JcbiAgICAgIH0pO1xuICAgICAgdmFyIGZvY3VzID0gUG9pbnQudHJhbnNmb3JtKHIuZm9jdXMsIG9wLCB7XG4gICAgICAgIGFmZmluaXR5OiBhZmZpbml0eUZvY3VzXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFhbmNob3IgfHwgIWZvY3VzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgIHIuZm9jdXMgPSBmb2N1cztcbiAgICB9KTtcbiAgfVxuXG59O1xuXG52YXIgUmFuZ2VSZWYgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgcmFuZ2UgcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBSYW5nZS50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuXG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBfc2NydWJiZXIgPSB1bmRlZmluZWQ7XG4vKipcclxuICogVGhpcyBpbnRlcmZhY2UgaW1wbGVtZW50cyBhIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLCB3aGljaCBpcyB1c2VkIGJ5IFNsYXRlXHJcbiAqIGludGVybmFsbHkgd2hlbiBnZW5lcmF0aW5nIGV4Y2VwdGlvbnMgY29udGFpbmluZyBlbmQgdXNlciBkYXRhLiBEZXZlbG9wZXJzXHJcbiAqIHVzaW5nIFNsYXRlIG1heSBjYWxsIFNjcnViYmVyLnNldFNjcnViYmVyKCkgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHRoaXNcclxuICogc3RyaW5naWZ5KCkgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlLCB0byBwcmV2ZW50IHRoZSBjbGVhcnRleHQgbG9nZ2luZyBvZiAndGV4dCcgZmllbGRzIHdpdGhpbiBOb2RlczpcclxuICpcclxuICogICAgaW1wb3J0IHsgU2NydWJiZXIgfSBmcm9tICdzbGF0ZSc7XHJcbiAqICAgIFNjcnViYmVyLnNldFNjcnViYmVyKChrZXksIHZhbCkgPT4ge1xyXG4gKiAgICAgIGlmIChrZXkgPT09ICd0ZXh0JykgcmV0dXJuICcuLi5zY3J1YmJlZC4uLidcclxuICogICAgICByZXR1cm4gdmFsXHJcbiAqICAgIH0pO1xyXG4gKlxyXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxudmFyIFNjcnViYmVyID0ge1xuICBzZXRTY3J1YmJlcihzY3J1YmJlcikge1xuICAgIF9zY3J1YmJlciA9IHNjcnViYmVyO1xuICB9LFxuXG4gIHN0cmluZ2lmeSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgX3NjcnViYmVyKTtcbiAgfVxuXG59O1xuXG4vKlxyXG4gIEN1c3RvbSBkZWVwIGVxdWFsIGNvbXBhcmlzb24gZm9yIFNsYXRlIG5vZGVzLlxyXG5cbiAgV2UgZG9uJ3QgbmVlZCBnZW5lcmFsIHB1cnBvc2UgZGVlcCBlcXVhbGl0eTtcclxuICBTbGF0ZSBvbmx5IHN1cHBvcnRzIHBsYWluIHZhbHVlcywgQXJyYXlzLCBhbmQgbmVzdGVkIG9iamVjdHMuXHJcbiAgQ29tcGxleCB2YWx1ZXMgbmVzdGVkIGluc2lkZSBBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcblxuICBTbGF0ZSBvYmplY3RzIGFyZSBkZXNpZ25lZCB0byBiZSBzZXJpYWxpc2VkLCBzb1xyXG4gIG1pc3Npbmcga2V5cyBhcmUgZGVsaWJlcmF0ZWx5IG5vcm1hbGlzZWQgdG8gdW5kZWZpbmVkLlxyXG4gKi9cblxudmFyIGlzRGVlcEVxdWFsID0gKG5vZGUsIGFub3RoZXIpID0+IHtcbiAgZm9yICh2YXIga2V5IGluIG5vZGUpIHtcbiAgICB2YXIgYSA9IG5vZGVba2V5XTtcbiAgICB2YXIgYiA9IGFub3RoZXJba2V5XTtcblxuICAgIGlmIChpc1BsYWluT2JqZWN0KGEpICYmIGlzUGxhaW5PYmplY3QoYikpIHtcbiAgICAgIGlmICghaXNEZWVwRXF1YWwoYSwgYikpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGEgIT09IGIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLypcclxuICAgIERlZXAgb2JqZWN0IGVxdWFsaXR5IGlzIG9ubHkgbmVjZXNzYXJ5IGluIG9uZSBkaXJlY3Rpb247IGluIHRoZSByZXZlcnNlIGRpcmVjdGlvblxyXG4gICAgd2UgYXJlIG9ubHkgbG9va2luZyBmb3Iga2V5cyB0aGF0IGFyZSBtaXNzaW5nLlxyXG4gICAgQXMgYWJvdmUsIHVuZGVmaW5lZCBrZXlzIGFyZSBub3JtYWxpc2VkIHRvIG1pc3NpbmcuXHJcbiAgKi9cblxuXG4gIGZvciAodmFyIF9rZXkgaW4gYW5vdGhlcikge1xuICAgIGlmIChub2RlW19rZXldID09PSB1bmRlZmluZWQgJiYgYW5vdGhlcltfa2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJ0ZXh0XCJdLFxuICAgIF9leGNsdWRlZDIkMSA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDQob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ0KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNChPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFRleHQgPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHR3byB0ZXh0IG5vZGVzIGFyZSBlcXVhbC5cclxuICAgKlxyXG4gICAqIFdoZW4gbG9vc2UgaXMgc2V0LCB0aGUgdGV4dCBpcyBub3QgY29tcGFyZWQuIFRoaXMgaXNcclxuICAgKiB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgc2libGluZyB0ZXh0IG5vZGVzIGNhbiBiZSBtZXJnZWQuXHJcbiAgICovXG4gIGVxdWFscyh0ZXh0LCBhbm90aGVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBsb29zZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBmdW5jdGlvbiBvbWl0VGV4dChvYmopIHtcbiAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwgX2V4Y2x1ZGVkJDEpO1xuXG4gICAgICByZXR1cm4gcmVzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNEZWVwRXF1YWwobG9vc2UgPyBvbWl0VGV4dCh0ZXh0KSA6IHRleHQsIGxvb3NlID8gb21pdFRleHQoYW5vdGhlcikgOiBhbm90aGVyKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBUZXh0YCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzVGV4dCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZyc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYFRleHRgIG9iamVjdHMuXHJcbiAgICovXG4gIGlzVGV4dExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkodmFsID0+IFRleHQuaXNUZXh0KHZhbCkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHNvbWUgcHJvcHMgYXJlIGEgcGFydGlhbCBvZiBUZXh0LlxyXG4gICAqL1xuICBpc1RleHRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0ICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gdGV4dCBtYXRjaGVzIHNldCBvZiBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogTm90ZTogdGhpcyBpcyBmb3IgbWF0Y2hpbmcgY3VzdG9tIHByb3BlcnRpZXMsIGFuZCBpdCBkb2VzIG5vdCBlbnN1cmUgdGhhdFxyXG4gICAqIHRoZSBgdGV4dGAgcHJvcGVydHkgYXJlIHR3byBub2RlcyBlcXVhbC5cclxuICAgKi9cbiAgbWF0Y2hlcyh0ZXh0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRleHQuaGFzT3duUHJvcGVydHkoa2V5KSB8fCB0ZXh0W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbGVhdmVzIGZvciBhIHRleHQgbm9kZSBnaXZlbiBkZWNvcmF0aW9ucy5cclxuICAgKi9cbiAgZGVjb3JhdGlvbnMobm9kZSwgZGVjb3JhdGlvbnMpIHtcbiAgICB2YXIgbGVhdmVzID0gW19vYmplY3RTcHJlYWQkNCh7fSwgbm9kZSldO1xuXG4gICAgZm9yICh2YXIgZGVjIG9mIGRlY29yYXRpb25zKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhkZWMsIF9leGNsdWRlZDIkMSk7XG5cbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhkZWMpO1xuICAgICAgdmFyIG5leHQgPSBbXTtcbiAgICAgIHZhciBsZWFmRW5kID0gMDtcbiAgICAgIHZhciBkZWNvcmF0aW9uU3RhcnQgPSBzdGFydC5vZmZzZXQ7XG4gICAgICB2YXIgZGVjb3JhdGlvbkVuZCA9IGVuZC5vZmZzZXQ7XG5cbiAgICAgIGZvciAodmFyIGxlYWYgb2YgbGVhdmVzKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbGVuZ3RoXG4gICAgICAgIH0gPSBsZWFmLnRleHQ7XG4gICAgICAgIHZhciBsZWFmU3RhcnQgPSBsZWFmRW5kO1xuICAgICAgICBsZWFmRW5kICs9IGxlbmd0aDsgLy8gSWYgdGhlIHJhbmdlIGVuY29tcGFzc2VzIHRoZSBlbnRpcmUgbGVhZiwgYWRkIHRoZSByYW5nZS5cblxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0IDw9IGxlYWZTdGFydCAmJiBsZWFmRW5kIDw9IGRlY29yYXRpb25FbmQpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGxlYWYsIHJlc3QpO1xuICAgICAgICAgIG5leHQucHVzaChsZWFmKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBJZiB0aGUgcmFuZ2UgZXhwYW5kZWQgYW5kIG1hdGNoIHRoZSBsZWFmLCBvciBzdGFydHMgYWZ0ZXIsIG9yIGVuZHMgYmVmb3JlIGl0LCBjb250aW51ZS5cblxuXG4gICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgIT09IGRlY29yYXRpb25FbmQgJiYgKGRlY29yYXRpb25TdGFydCA9PT0gbGVhZkVuZCB8fCBkZWNvcmF0aW9uRW5kID09PSBsZWFmU3RhcnQpIHx8IGRlY29yYXRpb25TdGFydCA+IGxlYWZFbmQgfHwgZGVjb3JhdGlvbkVuZCA8IGxlYWZTdGFydCB8fCBkZWNvcmF0aW9uRW5kID09PSBsZWFmU3RhcnQgJiYgbGVhZlN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGxlYWYpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIHNwbGl0IHRoZSBsZWFmLCBhdCB0aGUgc3RhcnQsIGVuZCwgb3IgYm90aCxcbiAgICAgICAgLy8gYW5kIGFkZCB0aGUgcmFuZ2UgdG8gdGhlIG1pZGRsZSBpbnRlcnNlY3Rpbmcgc2VjdGlvbi4gRG8gdGhlIGVuZFxuICAgICAgICAvLyBzcGxpdCBmaXJzdCBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgb2Zmc2V0IHRoYXQgd2F5LlxuXG5cbiAgICAgICAgdmFyIG1pZGRsZSA9IGxlYWY7XG4gICAgICAgIHZhciBiZWZvcmUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBhZnRlciA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoZGVjb3JhdGlvbkVuZCA8IGxlYWZFbmQpIHtcbiAgICAgICAgICB2YXIgb2ZmID0gZGVjb3JhdGlvbkVuZCAtIGxlYWZTdGFydDtcbiAgICAgICAgICBhZnRlciA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZShvZmYpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWlkZGxlID0gX29iamVjdFNwcmVhZCQ0KF9vYmplY3RTcHJlYWQkNCh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKDAsIG9mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgPiBsZWFmU3RhcnQpIHtcbiAgICAgICAgICB2YXIgX29mZiA9IGRlY29yYXRpb25TdGFydCAtIGxlYWZTdGFydDtcblxuICAgICAgICAgIGJlZm9yZSA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZSgwLCBfb2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZShfb2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtaWRkbGUsIHJlc3QpO1xuXG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICBuZXh0LnB1c2goYmVmb3JlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQucHVzaChtaWRkbGUpO1xuXG4gICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgIG5leHQucHVzaChhZnRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGVhdmVzID0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVhdmVzO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMyh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgYXBwbHlUb0RyYWZ0ID0gKGVkaXRvciwgc2VsZWN0aW9uLCBvcCkgPT4ge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBub2RlXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIHBhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoaW5kZXggPiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIFxcXCJpbnNlcnRfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBub2RlLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBub2RlKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW3BvaW50LCBrZXldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25ba2V5XSA9IFBvaW50LnRyYW5zZm9ybShwb2ludCwgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSBicmVhaztcblxuICAgICAgICB2YXIgX25vZGUgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aCk7XG5cbiAgICAgICAgdmFyIGJlZm9yZSA9IF9ub2RlLnRleHQuc2xpY2UoMCwgb2Zmc2V0KTtcblxuICAgICAgICB2YXIgYWZ0ZXIgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgX25vZGUudGV4dCA9IGJlZm9yZSArIHRleHQgKyBhZnRlcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludCwgX2tleV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoMlxuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgdmFyIF9ub2RlMiA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgyKTtcblxuICAgICAgICB2YXIgcHJldlBhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMik7XG4gICAgICAgIHZhciBwcmV2ID0gTm9kZS5nZXQoZWRpdG9yLCBwcmV2UGF0aCk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoMik7XG5cbiAgICAgICAgdmFyIF9pbmRleCA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlMikgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICBwcmV2LnRleHQgKz0gX25vZGUyLnRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIVRleHQuaXNUZXh0KF9ub2RlMikgJiYgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgcHJldi5jaGlsZHJlbi5wdXNoKC4uLl9ub2RlMi5jaGlsZHJlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcIm1lcmdlX25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGgyLCBcIl0gdG8gbm9kZXMgb2YgZGlmZmVyZW50IGludGVyZmFjZXM6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KF9ub2RlMiksIFwiIFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHByZXYpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBfcGFyZW50LmNoaWxkcmVuLnNwbGljZShfaW5kZXgsIDEpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50MiwgX2tleTJdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleTJdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDIsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgzLFxuICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX3BhdGgzLCBuZXdQYXRoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb3ZlIGEgcGF0aCBbXCIuY29uY2F0KF9wYXRoMywgXCJdIHRvIG5ldyBwYXRoIFtcIikuY29uY2F0KG5ld1BhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBpbnNpZGUgaXRzZWxmLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25vZGUzID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDMpO1xuXG4gICAgICAgIHZhciBfcGFyZW50MiA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgzKTtcblxuICAgICAgICB2YXIgX2luZGV4MiA9IF9wYXRoM1tfcGF0aDMubGVuZ3RoIC0gMV07IC8vIFRoaXMgaXMgdHJpY2t5LCBidXQgc2luY2UgdGhlIGBwYXRoYCBhbmQgYG5ld1BhdGhgIGJvdGggcmVmZXIgdG9cbiAgICAgICAgLy8gdGhlIHNhbWUgc25hcHNob3QgaW4gdGltZSwgdGhlcmUncyBhIG1pc21hdGNoLiBBZnRlciBlaXRoZXJcbiAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIG9yaWdpbmFsIHBvc2l0aW9uLCB0aGUgc2Vjb25kIHN0ZXAncyBwYXRoIGNhbiBiZSBvdXRcbiAgICAgICAgLy8gb2YgZGF0ZS4gU28gaW5zdGVhZCBvZiB1c2luZyB0aGUgYG9wLm5ld1BhdGhgIGRpcmVjdGx5LCB3ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gYG9wLnBhdGhgIHRvIGFzY2VydGFpbiB3aGF0IHRoZSBgbmV3UGF0aGAgd291bGQgYmUgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIG9wZXJhdGlvbiB3YXMgYXBwbGllZC5cblxuICAgICAgICBfcGFyZW50Mi5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MiwgMSk7XG5cbiAgICAgICAgdmFyIHRydWVQYXRoID0gUGF0aC50cmFuc2Zvcm0oX3BhdGgzLCBvcCk7XG4gICAgICAgIHZhciBuZXdQYXJlbnQgPSBOb2RlLmdldChlZGl0b3IsIFBhdGgucGFyZW50KHRydWVQYXRoKSk7XG4gICAgICAgIHZhciBuZXdJbmRleCA9IHRydWVQYXRoW3RydWVQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBuZXdQYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG5ld0luZGV4LCAwLCBfbm9kZTMpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50MywgX2tleTNdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleTNdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDMsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDRcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgX2luZGV4MyA9IF9wYXRoNFtfcGF0aDQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgdmFyIF9wYXJlbnQzID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDQpO1xuXG4gICAgICAgIF9wYXJlbnQzLmNoaWxkcmVuLnNwbGljZShfaW5kZXgzLCAxKTsgLy8gVHJhbnNmb3JtIGFsbCBvZiB0aGUgcG9pbnRzIGluIHRoZSB2YWx1ZSwgYnV0IGlmIHRoZSBwb2ludCB3YXMgaW4gdGhlXG4gICAgICAgIC8vIG5vZGUgdGhhdCB3YXMgcmVtb3ZlZCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmFuZ2Ugb3IgcmVtb3ZlIGl0LlxuXG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ0LCBfa2V5NF0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NCwgb3ApO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwgJiYgcmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk0XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfcHJldiA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBbbiwgcF0gb2YgTm9kZS50ZXh0cyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFBhdGguY29tcGFyZShwLCBfcGF0aDQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgX3ByZXYgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5leHQgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcHJlZmVyTmV4dCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmIChfcHJldiAmJiBuZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG5leHRbMV0sIF9wYXRoNCkpIHtcbiAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSAhUGF0aC5oYXNQcmV2aW91cyhuZXh0WzFdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJlZmVyTmV4dCA9IFBhdGguY29tbW9uKF9wcmV2WzFdLCBfcGF0aDQpLmxlbmd0aCA8IFBhdGguY29tbW9uKG5leHRbMV0sIF9wYXRoNCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChfcHJldiAmJiAhcHJlZmVyTmV4dCkge1xuICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IF9wcmV2WzFdO1xuICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gX3ByZXZbMF0udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IG5leHRbMV07XG4gICAgICAgICAgICAgICAgX3BvaW50NC5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDUsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIF9ub2RlNCA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoNSk7XG5cbiAgICAgICAgdmFyIF9iZWZvcmUgPSBfbm9kZTQudGV4dC5zbGljZSgwLCBfb2Zmc2V0KTtcblxuICAgICAgICB2YXIgX2FmdGVyID0gX25vZGU0LnRleHQuc2xpY2UoX29mZnNldCArIF90ZXh0Lmxlbmd0aCk7XG5cbiAgICAgICAgX25vZGU0LnRleHQgPSBfYmVmb3JlICsgX2FmdGVyO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50NSwgX2tleTVdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleTVdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDUsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDYsXG4gICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICBpZiAoX3BhdGg2Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcHJvcGVydGllcyBvbiB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbm9kZTUgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNik7XG5cbiAgICAgICAgZm9yICh2YXIgX2tleTYgaW4gbmV3UHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChfa2V5NiA9PT0gJ2NoaWxkcmVuJyB8fCBfa2V5NiA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBcXFwiXCIuY29uY2F0KF9rZXk2LCBcIlxcXCIgcHJvcGVydHkgb2Ygbm9kZXMhXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdQcm9wZXJ0aWVzW19rZXk2XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgX25vZGU1W19rZXk2XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX25vZGU1W19rZXk2XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRlZmluZWQsIGJ1dCBhcmUgbm93IG1pc3NpbmcsIG11c3QgYmUgZGVsZXRlZFxuXG5cbiAgICAgICAgZm9yICh2YXIgX2tleTcgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgIGlmICghbmV3UHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShfa2V5NykpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfbm9kZTVbX2tleTddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChfbmV3UHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgc2VsZWN0aW9uID0gX25ld1Byb3BlcnRpZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIVJhbmdlLmlzUmFuZ2UoX25ld1Byb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhbiBpbmNvbXBsZXRlIFxcXCJzZXRfc2VsZWN0aW9uXFxcIiBvcGVyYXRpb24gcHJvcGVydGllcyBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KF9uZXdQcm9wZXJ0aWVzKSwgXCIgd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50IHNlbGVjdGlvbi5cIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBfb2JqZWN0U3ByZWFkJDMoe30sIF9uZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBfa2V5OCBpbiBfbmV3UHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIF92YWx1ZSA9IF9uZXdQcm9wZXJ0aWVzW19rZXk4XTtcblxuICAgICAgICAgICAgaWYgKF92YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChfa2V5OCA9PT0gJ2FuY2hvcicgfHwgX2tleTggPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVtb3ZlIHRoZSBcXFwiXCIuY29uY2F0KF9rZXk4LCBcIlxcXCIgc2VsZWN0aW9uIHByb3BlcnR5XCIpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlbGV0ZSBzZWxlY3Rpb25bX2tleThdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk4XSA9IF92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNyxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgaWYgKF9wYXRoNy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYSBcXFwic3BsaXRfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChfcGF0aDcsIFwiXSBiZWNhdXNlIHRoZSByb290IG5vZGUgY2Fubm90IGJlIHNwbGl0LlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25vZGU2ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDcpO1xuXG4gICAgICAgIHZhciBfcGFyZW50NCA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGg3KTtcblxuICAgICAgICB2YXIgX2luZGV4NCA9IF9wYXRoN1tfcGF0aDcubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuZXdOb2RlO1xuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTYpKSB7XG4gICAgICAgICAgdmFyIF9iZWZvcmUyID0gX25vZGU2LnRleHQuc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgdmFyIF9hZnRlcjIgPSBfbm9kZTYudGV4dC5zbGljZShwb3NpdGlvbik7XG5cbiAgICAgICAgICBfbm9kZTYudGV4dCA9IF9iZWZvcmUyO1xuICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJDMoX29iamVjdFNwcmVhZCQzKHt9LCBfcHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBfYWZ0ZXIyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9iZWZvcmUzID0gX25vZGU2LmNoaWxkcmVuLnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgICAgICAgIHZhciBfYWZ0ZXIzID0gX25vZGU2LmNoaWxkcmVuLnNsaWNlKHBvc2l0aW9uKTtcblxuICAgICAgICAgIF9ub2RlNi5jaGlsZHJlbiA9IF9iZWZvcmUzO1xuICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJDMoX29iamVjdFNwcmVhZCQzKHt9LCBfcHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogX2FmdGVyM1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BhcmVudDQuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDQgKyAxLCAwLCBuZXdOb2RlKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDYsIF9rZXk5XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ2LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5cbnZhciBHZW5lcmFsVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBlZGl0b3IgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0oZWRpdG9yLCBvcCkge1xuICAgIGVkaXRvci5jaGlsZHJlbiA9IGNyZWF0ZURyYWZ0KGVkaXRvci5jaGlsZHJlbik7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24gJiYgY3JlYXRlRHJhZnQoZWRpdG9yLnNlbGVjdGlvbik7XG5cbiAgICB0cnkge1xuICAgICAgc2VsZWN0aW9uID0gYXBwbHlUb0RyYWZ0KGVkaXRvciwgc2VsZWN0aW9uLCBvcCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVkaXRvci5jaGlsZHJlbiA9IGZpbmlzaERyYWZ0KGVkaXRvci5jaGlsZHJlbik7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IGlzRHJhZnQoc2VsZWN0aW9uKSA/IGZpbmlzaERyYWZ0KHNlbGVjdGlvbikgOiBzZWxlY3Rpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxudmFyIF9leGNsdWRlZCA9IFtcInRleHRcIl0sXG4gICAgX2V4Y2x1ZGVkMiA9IFtcImNoaWxkcmVuXCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIE5vZGVUcmFuc2Zvcm1zID0ge1xuICAvKipcclxuICAgKiBJbnNlcnQgbm9kZXMgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnROb2RlcyhlZGl0b3IsIG5vZGVzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0J1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHNlbGVjdFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmIChOb2RlLmlzTm9kZShub2RlcykpIHtcbiAgICAgICAgbm9kZXMgPSBbbm9kZXNdO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIFtub2RlXSA9IG5vZGVzOyAvLyBCeSBkZWZhdWx0LCB1c2UgdGhlIHNlbGVjdGlvbiBhcyB0aGUgdGFyZ2V0IGxvY2F0aW9uLiBCdXQgaWYgdGhlcmUgaXNcbiAgICAgIC8vIG5vIHNlbGVjdGlvbiwgaW5zZXJ0IGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50IHNpbmNlIHRoYXQgaXMgc3VjaCBhXG4gICAgICAvLyBjb21tb24gdXNlIGNhc2Ugd2hlbiBpbnNlcnRpbmcgZnJvbSBhIG5vbi1zZWxlY3RlZCBzdGF0ZS5cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdCA9IFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3QgPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3QgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gbiA9PiBUZXh0LmlzVGV4dChuKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgW2VudHJ5XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQucGF0aCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBbLCBfbWF0Y2hQYXRoXSA9IGVudHJ5O1xuICAgICAgICAgIHZhciBwYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICB2YXIgaXNBdEVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdCxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgICAgYXQgPSBpc0F0RW5kID8gUGF0aC5uZXh0KHBhdGgpIDogcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChhdCk7XG4gICAgICB2YXIgaW5kZXggPSBhdFthdC5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhcmVudFBhdGhcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX25vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgdmFyIF9wYXRoID0gcGFyZW50UGF0aC5jb25jYXQoaW5kZXgpO1xuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJyxcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBub2RlOiBfbm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBQYXRoLm5leHQoYXQpO1xuICAgICAgfVxuXG4gICAgICBhdCA9IFBhdGgucHJldmlvdXMoYXQpO1xuXG4gICAgICBpZiAoc2VsZWN0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBMaWZ0IG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gdXB3YXJkcyBpbiB0aGUgZG9jdW1lbnQgdHJlZSwgc3BsaXR0aW5nXHJcbiAgICogdGhlaXIgcGFyZW50IGluIHR3byBpZiBuZWNlc3NhcnkuXHJcbiAgICovXG4gIGxpZnROb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIF9yZWYgPT4ge1xuICAgICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbGlmdCBub2RlIGF0IGEgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGhhcyBhIGRlcHRoIG9mIGxlc3MgdGhhbiBgMmAuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnROb2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIFBhdGgucGFyZW50KHBhdGgpKTtcbiAgICAgICAgdmFyIFtwYXJlbnQsIHBhcmVudFBhdGhdID0gcGFyZW50Tm9kZUVudHJ5O1xuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbGVuZ3RoXG4gICAgICAgIH0gPSBwYXJlbnQuY2hpbGRyZW47XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciB0b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgIHRvOiB0b1BhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IHBhcmVudFBhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIF90b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzcGxpdFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG5cbiAgICAgICAgICB2YXIgX3RvUGF0aDIgPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogc3BsaXRQYXRoLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgyLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1lcmdlIGEgbm9kZSBhdCBhIGxvY2F0aW9uIHdpdGggdGhlIHByZXZpb3VzIG5vZGUgb2YgdGhlIHNhbWUgZGVwdGgsXHJcbiAgICogcmVtb3ZpbmcgYW55IGVtcHR5IGNvbnRhaW5pbmcgbm9kZXMgYWZ0ZXIgdGhlIG1lcmdlIGlmIG5lY2Vzc2FyeS5cclxuICAgKi9cbiAgbWVyZ2VOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFtjdXJyZW50XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICB2b2lkcyxcbiAgICAgICAgbW9kZVxuICAgICAgfSk7XG4gICAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICB2b2lkcyxcbiAgICAgICAgbW9kZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghY3VycmVudCB8fCAhcHJldikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBbbm9kZSwgcGF0aF0gPSBjdXJyZW50O1xuICAgICAgdmFyIFtwcmV2Tm9kZSwgcHJldlBhdGhdID0gcHJldjtcblxuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwIHx8IHByZXZQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHByZXZQYXRoKTtcbiAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5jb21tb24ocGF0aCwgcHJldlBhdGgpO1xuICAgICAgdmFyIGlzUHJldmlvdXNTaWJsaW5nID0gUGF0aC5pc1NpYmxpbmcocGF0aCwgcHJldlBhdGgpO1xuICAgICAgdmFyIGxldmVscyA9IEFycmF5LmZyb20oRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGhcbiAgICAgIH0pLCBfcmVmMiA9PiB7XG4gICAgICAgIHZhciBbbl0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9KS5zbGljZShjb21tb25QYXRoLmxlbmd0aCkuc2xpY2UoMCwgLTEpOyAvLyBEZXRlcm1pbmUgaWYgdGhlIG1lcmdlIHdpbGwgbGVhdmUgYW4gYW5jZXN0b3Igb2YgdGhlIHBhdGggZW1wdHkgYXMgYVxuICAgICAgLy8gcmVzdWx0LCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gcmVtb3ZlIGl0IGFmdGVyIG1lcmdpbmcuXG5cbiAgICAgIHZhciBlbXB0eUFuY2VzdG9yID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICBtYXRjaDogbiA9PiBsZXZlbHMuaW5jbHVkZXMobikgJiYgaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgbilcbiAgICAgIH0pO1xuICAgICAgdmFyIGVtcHR5UmVmID0gZW1wdHlBbmNlc3RvciAmJiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGVtcHR5QW5jZXN0b3JbMV0pO1xuICAgICAgdmFyIHByb3BlcnRpZXM7XG4gICAgICB2YXIgcG9zaXRpb247IC8vIEVuc3VyZSB0aGF0IHRoZSBub2RlcyBhcmUgZXF1aXZhbGVudCwgYW5kIGZpZ3VyZSBvdXQgd2hhdCB0aGUgcG9zaXRpb25cbiAgICAgIC8vIGFuZCBleHRyYSBwcm9wZXJ0aWVzIG9mIHRoZSBtZXJnZSB3aWxsIGJlLlxuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHQocHJldk5vZGUpKSB7XG4gICAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZCk7XG5cbiAgICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSkge1xuICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyKTtcblxuICAgICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgdGhlIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSB3aXRoIHRoZSBwcmV2aW91cyBzaWJsaW5nIGJlY2F1c2UgaXQgaXMgbm90IHRoZSBzYW1lIGtpbmQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2Tm9kZSkpKTtcbiAgICAgIH0gLy8gSWYgdGhlIG5vZGUgaXNuJ3QgYWxyZWFkeSB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBwcmV2aW91cyBub2RlLCBtb3ZlXG4gICAgICAvLyBpdCBzbyB0aGF0IGl0IGlzIGJlZm9yZSBtZXJnaW5nLlxuXG5cbiAgICAgIGlmICghaXNQcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IG5ld1BhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIElmIHRoZXJlIHdhcyBnb2luZyB0byBiZSBhbiBlbXB0eSBhbmNlc3RvciBvZiB0aGUgbm9kZSB0aGF0IHdhcyBtZXJnZWQsXG4gICAgICAvLyB3ZSByZW1vdmUgaXQgZnJvbSB0aGUgdHJlZS5cblxuXG4gICAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW1wdHlSZWYuY3VycmVudCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gSWYgdGhlIHRhcmdldCBub2RlIHRoYXQgd2UncmUgbWVyZ2luZyB3aXRoIGlzIGVtcHR5LCByZW1vdmUgaXQgaW5zdGVhZFxuICAgICAgLy8gb2YgbWVyZ2luZyB0aGUgdHdvLiBUaGlzIGlzIGEgY29tbW9uIHJpY2ggdGV4dCBlZGl0b3IgYmVoYXZpb3IgdG9cbiAgICAgIC8vIHByZXZlbnQgbG9zaW5nIGZvcm1hdHRpbmcgd2hlbiBkZWxldGluZyBlbnRpcmUgbm9kZXMgd2hlbiB5b3UgaGF2ZSBhXG4gICAgICAvLyBoYW5naW5nIHNlbGVjdGlvbi5cbiAgICAgIC8vIGlmIHByZXZOb2RlIGlzIGZpcnN0IGNoaWxkIGluIHBhcmVudCxkb24ndCByZW1vdmUgaXQuXG5cblxuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSAmJiBFZGl0b3IuaXNFbXB0eShlZGl0b3IsIHByZXZOb2RlKSB8fCBUZXh0LmlzVGV4dChwcmV2Tm9kZSkgJiYgcHJldk5vZGUudGV4dCA9PT0gJycgJiYgcHJldlBhdGhbcHJldlBhdGgubGVuZ3RoIC0gMV0gIT09IDApIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcHJldlBhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdtZXJnZV9ub2RlJyxcbiAgICAgICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbXB0eVJlZikge1xuICAgICAgICBlbXB0eVJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24gdG8gYSBuZXcgbG9jYXRpb24uXHJcbiAgICovXG4gIG1vdmVOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgdG8sXG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9SZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHRvKTtcbiAgICAgIHZhciB0YXJnZXRzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20odGFyZ2V0cywgX3JlZjMgPT4ge1xuICAgICAgICB2YXIgWywgcF0gPSBfcmVmMztcbiAgICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgICAgdmFyIG5ld1BhdGggPSB0b1JlZi5jdXJyZW50O1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAnbW92ZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9SZWYuY3VycmVudCAmJiBQYXRoLmlzU2libGluZyhuZXdQYXRoLCBwYXRoKSAmJiBQYXRoLmlzQWZ0ZXIobmV3UGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAvLyBXaGVuIHBlcmZvcm1pbmcgYSBzaWJsaW5nIG1vdmUgdG8gYSBsYXRlciBpbmRleCwgdGhlIHBhdGggYXQgdGhlIGRlc3RpbmF0aW9uIGlzIHNoaWZ0ZWRcbiAgICAgICAgICAvLyB0byBiZWZvcmUgdGhlIGluc2VydGlvbiBwb2ludCBpbnN0ZWFkIG9mIGFmdGVyLiBUbyBlbnN1cmUgb3VyIGdyb3VwIG9mIG5vZGVzIGFyZSBpbnNlcnRlZFxuICAgICAgICAgIC8vIGluIHRoZSBjb3JyZWN0IG9yZGVyIHdlIGluY3JlbWVudCB0b1JlZiB0byBhY2NvdW50IGZvciB0aGF0XG4gICAgICAgICAgdG9SZWYuY3VycmVudCA9IFBhdGgubmV4dCh0b1JlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b1JlZi51bnJlZigpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgbm9kZXMgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIHJlbW92ZU5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVwdGhzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20oZGVwdGhzLCBfcmVmNCA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY0O1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgbm9kZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2V0IG5ldyBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBzZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBjb21wYXJlLFxuICAgICAgICBtZXJnZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgICAgc3BsaXQgPSBmYWxzZSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSAmJiBFZGl0b3IubGVhZihlZGl0b3IsIGF0LmFuY2hvcilbMF0udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCBpbiBhIG5vbi1lbXB0eSBub2RlIGFuZCAnc3BsaXQnIGlzIHRydWUsIHRoZXJlJ3Mgbm90aGluZyB0b1xuICAgICAgICAgIC8vIHNldCB0aGF0IHdvbid0IGdldCBub3JtYWxpemVkIGF3YXlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHNwbGl0TW9kZSA9IG1vZGUgPT09ICdsb3dlc3QnID8gJ2xvd2VzdCcgOiAnaGlnaGVzdCc7XG4gICAgICAgIHZhciBlbmRBdEVuZE9mTm9kZSA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGVuZCwgZW5kLnBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhZW5kQXRFbmRPZk5vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdGFydEF0U3RhcnRPZk5vZGUgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHN0YXJ0LCBzdGFydC5wYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhc3RhcnRBdFN0YXJ0T2ZOb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY29tcGFyZSkge1xuICAgICAgICBjb21wYXJlID0gKHByb3AsIG5vZGVQcm9wKSA9PiBwcm9wICE9PSBub2RlUHJvcDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgdmFyIG5ld1Byb3BlcnRpZXMgPSB7fTsgLy8gWW91IGNhbid0IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSBlZGl0b3Igbm9kZS5cblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXNDaGFuZ2VzID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgICAgIGlmIChrID09PSAnY2hpbGRyZW4nIHx8IGsgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbXBhcmUocHJvcHNba10sIG5vZGVba10pKSB7XG4gICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTsgLy8gT21pdCBuZXcgcHJvcGVydGllcyBmcm9tIHRoZSBvbGQgcHJvcGVydGllcyBsaXN0XG5cbiAgICAgICAgICAgIGlmIChub2RlLmhhc093blByb3BlcnR5KGspKSBwcm9wZXJ0aWVzW2tdID0gbm9kZVtrXTsgLy8gT21pdCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbmV3IHByb3BlcnRpZXMgbGlzdFxuXG4gICAgICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBtZXJnZShub2RlW2tdLCBwcm9wc1trXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IHByb3BzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdzZXRfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNwbGl0IHRoZSBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxyXG4gICAqL1xuICBzcGxpdE5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGFsd2F5cyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IGRlbGV0ZVJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfSAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgcGF0aCwgdGhlIGRlZmF1bHQgaGVpZ2h0LXNraXBwaW5nIGFuZCBwb3NpdGlvblxuICAgICAgLy8gY291bnRlcnMgbmVlZCB0byBhY2NvdW50IGZvciB1cyBwb3RlbnRpYWxseSBzcGxpdHRpbmcgYXQgYSBub24tbGVhZi5cblxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBwYXRoID0gYXQ7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgbWF0Y2ggPSBuID0+IG4gPT09IHBhcmVudDtcblxuICAgICAgICBoZWlnaHQgPSBwb2ludC5wYXRoLmxlbmd0aCAtIHBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgYXQgPSBwb2ludDtcbiAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBiZWZvcmVSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgICAgfSk7XG4gICAgICB2YXIgYWZ0ZXJSZWY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBbaGlnaGVzdF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWhpZ2hlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdm9pZE1hdGNoID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbnVkZ2UgPSAwO1xuXG4gICAgICAgIGlmICghdm9pZHMgJiYgdm9pZE1hdGNoKSB7XG4gICAgICAgICAgdmFyIFt2b2lkTm9kZSwgdm9pZFBhdGhdID0gdm9pZE1hdGNoO1xuXG4gICAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHZvaWROb2RlKSAmJiBlZGl0b3IuaXNJbmxpbmUodm9pZE5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCB2b2lkUGF0aCk7XG5cbiAgICAgICAgICAgIGlmICghYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIGFmdGVyUGF0aCA9IFBhdGgubmV4dCh2b2lkUGF0aCk7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB0ZXh0LCB7XG4gICAgICAgICAgICAgICAgYXQ6IGFmdGVyUGF0aCxcbiAgICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhZnRlclBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2libGluZ0hlaWdodCA9IGF0LnBhdGgubGVuZ3RoIC0gdm9pZFBhdGgubGVuZ3RoO1xuICAgICAgICAgIGhlaWdodCA9IHNpYmxpbmdIZWlnaHQgKyAxO1xuICAgICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBhZnRlclJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0KTtcbiAgICAgICAgdmFyIGRlcHRoID0gYXQucGF0aC5sZW5ndGggLSBoZWlnaHQ7XG4gICAgICAgIHZhciBbLCBoaWdoZXN0UGF0aF0gPSBoaWdoZXN0O1xuICAgICAgICB2YXIgbG93ZXN0UGF0aCA9IGF0LnBhdGguc2xpY2UoMCwgZGVwdGgpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBoZWlnaHQgPT09IDAgPyBhdC5vZmZzZXQgOiBhdC5wYXRoW2RlcHRoXSArIG51ZGdlO1xuXG4gICAgICAgIGZvciAodmFyIFtub2RlLCBfcGF0aDJdIG9mIEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGxvd2VzdFBhdGgsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKF9wYXRoMi5sZW5ndGggPCBoaWdoZXN0UGF0aC5sZW5ndGggfHwgX3BhdGgyLmxlbmd0aCA9PT0gMCB8fCAhdm9pZHMgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3BvaW50ID0gYmVmb3JlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgX3BvaW50LCBfcGF0aDIpO1xuXG4gICAgICAgICAgaWYgKGFsd2F5cyB8fCAhYmVmb3JlUmVmIHx8ICFFZGl0b3IuaXNFZGdlKGVkaXRvciwgX3BvaW50LCBfcGF0aDIpKSB7XG4gICAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IE5vZGUuZXh0cmFjdFByb3BzKG5vZGUpO1xuICAgICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgICBwYXRoOiBfcGF0aDIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3NpdGlvbiA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV0gKyAoc3BsaXQgfHwgaXNFbmQgPyAxIDogMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9wb2ludDIgPSBhZnRlclJlZi5jdXJyZW50IHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9wb2ludDIpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB2YXIgX2FmdGVyUmVmO1xuXG4gICAgICAgIGJlZm9yZVJlZi51bnJlZigpO1xuICAgICAgICAoX2FmdGVyUmVmID0gYWZ0ZXJSZWYpID09PSBudWxsIHx8IF9hZnRlclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FmdGVyUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5zZXQgcHJvcGVydGllcyBvbiB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgdW5zZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgcHJvcHMgPSBbcHJvcHNdO1xuICAgIH1cblxuICAgIHZhciBvYmogPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBvZiBwcm9wcykge1xuICAgICAgb2JqW2tleV0gPSBudWxsO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBvYmosIG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVud3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBmcm9tIGEgcGFyZW50IG5vZGUsIHNwbGl0dGluZyB0aGUgcGFyZW50IGlmXHJcbiAgICogbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGNvbnRlbnQgaW4gdGhlIHJhbmdlIGlzIHVud3JhcHBlZC5cclxuICAgKi9cbiAgdW53cmFwTm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlUmVmID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCkgOiBudWxsO1xuICAgICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBfcmVmNSA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY1O1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0gLy8gdW53cmFwTm9kZSB3aWxsIGNhbGwgbGlmdE5vZGUgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBzcGxpdHRpbmcgdGhlIG5vZGUgd2hlbiBuZXN0ZWQuXG4gICAgICAvLyBJZiB3ZSBkbyBub3QgcmV2ZXJzZSB0aGUgb3JkZXIgYW5kIGNhbGwgaXQgZnJvbSB0b3AgdG8gdGhlIGJvdHRvbSwgaXQgd2lsbCByZW1vdmUgYWxsIGJsb2Nrc1xuICAgICAgLy8gdGhhdCB3cmFwIHRhcmdldCBub2RlLiBTbyB3ZSByZXZlcnNlIHRoZSBvcmRlci5cbiAgICAgICkucmV2ZXJzZSgpO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwYXRoUmVmKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHNwbGl0ICYmIHJhbmdlUmVmKSB7XG4gICAgICAgICAgcmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2VSZWYuY3VycmVudCwgcmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5saWZ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSAmJiBub2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgICBfbG9vcChwYXRoUmVmKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhbmdlUmVmKSB7XG4gICAgICAgIHJhbmdlUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogV3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBpbiBhIG5ldyBjb250YWluZXIgbm9kZSwgc3BsaXR0aW5nIHRoZSBlZGdlc1xyXG4gICAqIG9mIHRoZSByYW5nZSBmaXJzdCB0byBlbnN1cmUgdGhhdCBvbmx5IHRoZSBjb250ZW50IGluIHRoZSByYW5nZSBpcyB3cmFwcGVkLlxyXG4gICAqL1xuICB3cmFwTm9kZXMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoZWRpdG9yLCBhdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pIHx8IFRleHQuaXNUZXh0KG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJvb3RzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaDogZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpID8gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogbiA9PiBFZGl0b3IuaXNFZGl0b3IobiksXG4gICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpO1xuXG4gICAgICBmb3IgKHZhciBbLCByb290UGF0aF0gb2Ygcm9vdHMpIHtcbiAgICAgICAgdmFyIGEgPSBSYW5nZS5pc1JhbmdlKGF0KSA/IFJhbmdlLmludGVyc2VjdGlvbihhdCwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcm9vdFBhdGgpKSA6IGF0O1xuXG4gICAgICAgIGlmICghYSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYSxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgW2ZpcnN0XSA9IG1hdGNoZXM7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gZmlyc3Q7XG4gICAgICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gbGFzdDtcblxuICAgICAgICAgICAgaWYgKGZpcnN0UGF0aC5sZW5ndGggPT09IDAgJiYgbGFzdFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgcGFyZW50IC0gdXN1YWxseSBtZWFucyB0aGUgbm9kZSBpcyBhbiBlZGl0b3IgLSBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguZXF1YWxzKGZpcnN0UGF0aCwgbGFzdFBhdGgpID8gUGF0aC5wYXJlbnQoZmlyc3RQYXRoKSA6IFBhdGguY29tbW9uKGZpcnN0UGF0aCwgbGFzdFBhdGgpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgICB2YXIgY29tbW9uTm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBjb21tb25QYXRoKTtcbiAgICAgICAgICAgIHZhciBbY29tbW9uTm9kZV0gPSBjb21tb25Ob2RlRW50cnk7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSBjb21tb25QYXRoLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB2YXIgd3JhcHBlclBhdGggPSBQYXRoLm5leHQobGFzdFBhdGguc2xpY2UoMCwgZGVwdGgpKTtcblxuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBlbGVtZW50KSwge30sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHdyYXBwZXIsIHtcbiAgICAgICAgICAgICAgYXQ6IHdyYXBwZXJQYXRoLFxuICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzQW5jZXN0b3IoY29tbW9uTm9kZSkgJiYgY29tbW9uTm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKSxcbiAgICAgICAgICAgICAgdG86IHdyYXBwZXJQYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufTtcblxudmFyIGhhc1NpbmdsZUNoaWxkTmVzdCA9IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuXG4gICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbi8qKlxyXG4gKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIHBvaW50IGJ5IGRlbGV0aW5nIGl0J3MgY29udGVudC5cclxuICovXG5cblxudmFyIGRlbGV0ZVJhbmdlID0gKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiByYW5nZS5hbmNob3I7XG4gIH0gZWxzZSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludFJlZi51bnJlZigpO1xuICB9XG59O1xuXG52YXIgbWF0Y2hQYXRoID0gKGVkaXRvciwgcGF0aCkgPT4ge1xuICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgcmV0dXJuIG4gPT4gbiA9PT0gbm9kZTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgU2VsZWN0aW9uVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogQ29sbGFwc2UgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgY29sbGFwc2UoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBlZGdlID0gJ2FuY2hvcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmZvY3VzKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIHZhciBbc3RhcnRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc3RhcnQpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgZW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5zZXQgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgZGVzZWxlY3QoZWRpdG9yKSB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIHNlbGVjdGlvbidzIHBvaW50IGZvcndhcmQgb3IgYmFja3dhcmQuXHJcbiAgICovXG4gIG1vdmUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciB7XG4gICAgICBkaXN0YW5jZSA9IDEsXG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgZWRnZSA9IG51bGxcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBkaXN0YW5jZSxcbiAgICAgIHVuaXRcbiAgICB9O1xuICAgIHZhciBwcm9wcyA9IHt9O1xuXG4gICAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhbmNob3IsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYW5jaG9yLCBvcHRzKTtcblxuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIHByb3BzLmFuY2hvciA9IHBvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlZGdlID09IG51bGwgfHwgZWRnZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgdmFyIF9wb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgZm9jdXMsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgZm9jdXMsIG9wdHMpO1xuXG4gICAgICBpZiAoX3BvaW50KSB7XG4gICAgICAgIHByb3BzLmZvY3VzID0gX3BvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc2VsZWN0aW9uIHRvIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xuICBzZWxlY3QoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB0YXJnZXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGBudWxsYCB5b3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IGFuIGBhbmNob3JgIGFuZCBgZm9jdXNgLCBidXQgeW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeSh0YXJnZXQpKSk7XG4gICAgfVxuXG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgIG5ld1Byb3BlcnRpZXM6IHRhcmdldFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiBvbmUgb2YgdGhlIHNlbGVjdGlvbidzIHBvaW50cy5cclxuICAgKi9cbiAgc2V0UG9pbnQoZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIge1xuICAgICAgZWRnZSA9ICdib3RoJ1xuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICB2YXIgcG9pbnQgPSBlZGdlID09PSAnYW5jaG9yJyA/IGFuY2hvciA6IGZvY3VzO1xuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgW2VkZ2UgPT09ICdhbmNob3InID8gJ2FuY2hvcicgOiAnZm9jdXMnXTogX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgcG9pbnQpLCBwcm9wcylcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIgb2xkUHJvcHMgPSB7fTtcbiAgICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgaWYgKGsgPT09ICdhbmNob3InICYmIHByb3BzLmFuY2hvciAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuYW5jaG9yLCBzZWxlY3Rpb24uYW5jaG9yKSB8fCBrID09PSAnZm9jdXMnICYmIHByb3BzLmZvY3VzICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5mb2N1cywgc2VsZWN0aW9uLmZvY3VzKSB8fCBrICE9PSAnYW5jaG9yJyAmJiBrICE9PSAnZm9jdXMnICYmIHByb3BzW2tdICE9PSBzZWxlY3Rpb25ba10pIHtcbiAgICAgICAgb2xkUHJvcHNba10gPSBzZWxlY3Rpb25ba107XG4gICAgICAgIG5ld1Byb3BzW2tdID0gcHJvcHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKG9sZFByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICAgIHByb3BlcnRpZXM6IG9sZFByb3BzLFxuICAgICAgICBuZXdQcm9wZXJ0aWVzOiBuZXdQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBUZXh0VHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogRGVsZXRlIGNvbnRlbnQgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgZGVsZXRlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgICAgIGRpc3RhbmNlID0gMSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDb2xsYXBzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmIFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBpc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgdmFyIGZ1cnRoZXN0Vm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0LFxuICAgICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXZvaWRzICYmIGZ1cnRoZXN0Vm9pZCkge1xuICAgICAgICAgIHZhciBbLCB2b2lkUGF0aF0gPSBmdXJ0aGVzdFZvaWQ7XG4gICAgICAgICAgYXQgPSB2b2lkUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICAgIGF0ID0ge1xuICAgICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICAgIGZvY3VzOiB0YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGhhbmdpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgIHZhciBbLCBfZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIGVuZE9mRG9jID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcblxuICAgICAgICBpZiAoIVBvaW50LmVxdWFscyhfZW5kLCBlbmRPZkRvYykpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgc3RhcnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBpc0Fjcm9zc0Jsb2NrcyA9IHN0YXJ0QmxvY2sgJiYgZW5kQmxvY2sgJiYgIVBhdGguZXF1YWxzKHN0YXJ0QmxvY2tbMV0sIGVuZEJsb2NrWzFdKTtcbiAgICAgIHZhciBpc1NpbmdsZVRleHQgPSBQYXRoLmVxdWFscyhzdGFydC5wYXRoLCBlbmQucGF0aCk7XG4gICAgICB2YXIgc3RhcnRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTtcbiAgICAgIHZhciBlbmRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7IC8vIElmIHRoZSBzdGFydCBvciBlbmQgcG9pbnRzIGFyZSBpbnNpZGUgYW4gaW5saW5lIHZvaWQsIG51ZGdlIHRoZW0gb3V0LlxuXG4gICAgICBpZiAoc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChiZWZvcmUgJiYgc3RhcnRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3Ioc3RhcnRCbG9ja1sxXSwgYmVmb3JlLnBhdGgpKSB7XG4gICAgICAgICAgc3RhcnQgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgZW5kKTtcblxuICAgICAgICBpZiAoYWZ0ZXIgJiYgZW5kQmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKGVuZEJsb2NrWzFdLCBhZnRlci5wYXRoKSkge1xuICAgICAgICAgIGVuZCA9IGFmdGVyO1xuICAgICAgICB9XG4gICAgICB9IC8vIEdldCB0aGUgaGlnaGVzdCBub2RlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmFuZ2UsIGFzIHdlbGwgYXNcbiAgICAgIC8vIHRoZSBzdGFydCBhbmQgZW5kIG5vZGVzLlxuXG5cbiAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICB2YXIgbGFzdFBhdGg7XG5cbiAgICAgIGZvciAodmFyIGVudHJ5IG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7XG5cbiAgICAgICAgaWYgKGxhc3RQYXRoICYmIFBhdGguY29tcGFyZShwYXRoLCBsYXN0UGF0aCkgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8ICFQYXRoLmlzQ29tbW9uKHBhdGgsIHN0YXJ0LnBhdGgpICYmICFQYXRoLmlzQ29tbW9uKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgbGFzdFBhdGggPSBwYXRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgX3JlZiA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgIHZhciByZW1vdmVkVGV4dCA9ICcnO1xuXG4gICAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgW19ub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50KTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aFxuICAgICAgICB9ID0gX3BvaW50O1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG9mZnNldFxuICAgICAgICB9ID0gc3RhcnQ7XG5cbiAgICAgICAgdmFyIHRleHQgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVtb3ZlZFRleHQgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgICAgdmFyIF9wYXRoMiA9IHBhdGhSZWYudW5yZWYoKTtcblxuICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBfcGF0aDIsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZW5kVm9pZCkge1xuICAgICAgICB2YXIgX3BvaW50MiA9IGVuZFJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgW19ub2RlMl0gPSBFZGl0b3IubGVhZihlZGl0b3IsIF9wb2ludDIpO1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoM1xuICAgICAgICB9ID0gX3BvaW50MjtcblxuICAgICAgICB2YXIgX29mZnNldCA9IGlzU2luZ2xlVGV4dCA/IHN0YXJ0Lm9mZnNldCA6IDA7XG5cbiAgICAgICAgdmFyIF90ZXh0ID0gX25vZGUyLnRleHQuc2xpY2UoX29mZnNldCwgZW5kLm9mZnNldCk7XG5cbiAgICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoMyxcbiAgICAgICAgICAgIG9mZnNldDogX29mZnNldCxcbiAgICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVtb3ZlZFRleHQgPSBfdGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiBpc0Fjcm9zc0Jsb2NrcyAmJiBlbmRSZWYuY3VycmVudCAmJiBzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICAgICAgaGFuZ2luZzogdHJ1ZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gRm9yIFRoYWkgc2NyaXB0LCBkZWxldGluZyBOIGNoYXJhY3RlcihzKSBiYWNrd2FyZCBzaG91bGQgZGVsZXRlXG4gICAgICAvLyBOIGNvZGUgcG9pbnQocykgaW5zdGVhZCBvZiBhbiBlbnRpcmUgZ3JhcGhlbWUgY2x1c3Rlci5cbiAgICAgIC8vIFRoZXJlZm9yZSwgdGhlIHJlbWFpbmluZyBjb2RlIHBvaW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQgYmFjay5cblxuXG4gICAgICBpZiAoaXNDb2xsYXBzZWQgJiYgcmV2ZXJzZSAmJiB1bml0ID09PSAnY2hhcmFjdGVyJyAmJiByZW1vdmVkVGV4dC5sZW5ndGggPiAxICYmIHJlbW92ZWRUZXh0Lm1hdGNoKC9bXFx1MEUwMC1cXHUwRTdGXSsvKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCByZW1vdmVkVGV4dC5zbGljZSgwLCByZW1vdmVkVGV4dC5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRVbnJlZiA9IHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICB2YXIgZW5kVW5yZWYgPSBlbmRSZWYudW5yZWYoKTtcbiAgICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyBzdGFydFVucmVmIHx8IGVuZFVucmVmIDogZW5kVW5yZWYgfHwgc3RhcnRVbnJlZjtcblxuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCAmJiBwb2ludCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBmcmFnbWVudCBhdCBhIHNwZWNpZmljIGxvY2F0aW9uIGluIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWZyYWdtZW50Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcblxuICAgICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogZW5kXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBJZiB0aGUgaW5zZXJ0IHBvaW50IGlzIGF0IHRoZSBlZGdlIG9mIGFuIGlubGluZSBub2RlLCBtb3ZlIGl0IG91dHNpZGVcbiAgICAgIC8vIGluc3RlYWQgc2luY2UgaXQgd2lsbCBuZWVkIHRvIGJlIHNwbGl0IG90aGVyd2lzZS5cblxuXG4gICAgICB2YXIgaW5saW5lRWxlbWVudE1hdGNoID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5saW5lRWxlbWVudE1hdGNoKSB7XG4gICAgICAgIHZhciBbLCBfaW5saW5lUGF0aF0gPSBpbmxpbmVFbGVtZW50TWF0Y2g7XG5cbiAgICAgICAgaWYgKEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgICAgYXQgPSBhZnRlcjtcbiAgICAgICAgfSBlbHNlIGlmIChFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIF9pbmxpbmVQYXRoKTtcbiAgICAgICAgICBhdCA9IGJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmxvY2tNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgYXQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBbLCBibG9ja1BhdGhdID0gYmxvY2tNYXRjaDtcbiAgICAgIHZhciBpc0Jsb2NrU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBibG9ja1BhdGgpO1xuICAgICAgdmFyIGlzQmxvY2tFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICAgIHZhciBpc0Jsb2NrRW1wdHkgPSBpc0Jsb2NrU3RhcnQgJiYgaXNCbG9ja0VuZDtcbiAgICAgIHZhciBtZXJnZVN0YXJ0ID0gIWlzQmxvY2tTdGFydCB8fCBpc0Jsb2NrU3RhcnQgJiYgaXNCbG9ja0VuZDtcbiAgICAgIHZhciBtZXJnZUVuZCA9ICFpc0Jsb2NrRW5kO1xuICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBOb2RlLmZpcnN0KHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCBbXSk7XG4gICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCBbXSk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gICAgICB2YXIgbWF0Y2hlciA9IF9yZWYyID0+IHtcbiAgICAgICAgdmFyIFtuLCBwXSA9IF9yZWYyO1xuICAgICAgICB2YXIgaXNSb290ID0gcC5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0Jsb2NrRW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXJnZVN0YXJ0ICYmIFBhdGguaXNBbmNlc3RvcihwLCBmaXJzdFBhdGgpICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmICFlZGl0b3IuaXNWb2lkKG4pICYmICFlZGl0b3IuaXNJbmxpbmUobikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2VFbmQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGxhc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBlbnRyeSBvZiBOb2RlLm5vZGVzKHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCB7XG4gICAgICAgIHBhc3M6IG1hdGNoZXJcbiAgICAgIH0pKSB7XG4gICAgICAgIGlmIChtYXRjaGVyKGVudHJ5KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0cyA9IFtdO1xuICAgICAgdmFyIG1pZGRsZXMgPSBbXTtcbiAgICAgIHZhciBlbmRzID0gW107XG4gICAgICB2YXIgc3RhcnRpbmcgPSB0cnVlO1xuICAgICAgdmFyIGhhc0Jsb2NrcyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBbbm9kZV0gb2YgbWF0Y2hlcykge1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgIHN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgaGFzQmxvY2tzID0gdHJ1ZTtcbiAgICAgICAgICBtaWRkbGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRpbmcpIHtcbiAgICAgICAgICBzdGFydHMucHVzaChub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFtpbmxpbmVNYXRjaF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgWywgaW5saW5lUGF0aF0gPSBpbmxpbmVNYXRjaDtcbiAgICAgIHZhciBpc0lubGluZVN0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgICB2YXIgaXNJbmxpbmVFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgICB2YXIgbWlkZGxlUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBpc0Jsb2NrRW5kICYmICFlbmRzLmxlbmd0aCA/IFBhdGgubmV4dChibG9ja1BhdGgpIDogYmxvY2tQYXRoKTtcbiAgICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGlzSW5saW5lRW5kID8gUGF0aC5uZXh0KGlubGluZVBhdGgpIDogaW5saW5lUGF0aCk7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaDogbiA9PiBoYXNCbG9ja3MgPyBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6IGhhc0Jsb2NrcyA/ICdsb3dlc3QnIDogJ2hpZ2hlc3QnLFxuICAgICAgICBhbHdheXM6IGhhc0Jsb2NrcyAmJiAoIWlzQmxvY2tTdGFydCB8fCBzdGFydHMubGVuZ3RoID4gMCkgJiYgKCFpc0Jsb2NrRW5kIHx8IGVuZHMubGVuZ3RoID4gMCksXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgIWlzSW5saW5lU3RhcnQgfHwgaXNJbmxpbmVTdGFydCAmJiBpc0lubGluZUVuZCA/IFBhdGgubmV4dChpbmxpbmVQYXRoKSA6IGlubGluZVBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHN0YXJ0cywge1xuICAgICAgICBhdDogc3RhcnRSZWYuY3VycmVudCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNCbG9ja0VtcHR5ICYmICFzdGFydHMubGVuZ3RoICYmIG1pZGRsZXMubGVuZ3RoICYmICFlbmRzLmxlbmd0aCkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYmxvY2tQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbWlkZGxlcywge1xuICAgICAgICBhdDogbWlkZGxlUmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZW5kcywge1xuICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFvcHRpb25zLmF0KSB7XG4gICAgICAgIHZhciBwYXRoO1xuXG4gICAgICAgIGlmIChlbmRzLmxlbmd0aCA+IDAgJiYgZW5kUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhlbmRSZWYuY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWlkZGxlcy5sZW5ndGggPiAwICYmIG1pZGRsZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMobWlkZGxlUmVmLmN1cnJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhzdGFydFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgdmFyIF9lbmQyID0gRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfZW5kMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgIG1pZGRsZVJlZi51bnJlZigpO1xuICAgICAgZW5kUmVmLnVucmVmKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgc3RyaW5nIG9mIHRleHQgaW4gdGhlIEVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVuZCA9IFJhbmdlLmVuZChhdCk7XG5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVuZFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gUmFuZ2Uuc3RhcnQoYXQpO1xuICAgICAgICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIHN0YXJ0KTtcbiAgICAgICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0LFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICAgICAgdmFyIGVuZFBvaW50ID0gZW5kUmVmLnVucmVmKCk7XG4gICAgICAgICAgYXQgPSBzdGFydFBvaW50IHx8IGVuZFBvaW50O1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICAgIGZvY3VzOiBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IGF0O1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ2luc2VydF90ZXh0JyxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICB0ZXh0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgVHJhbnNmb3JtcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIEdlbmVyYWxUcmFuc2Zvcm1zKSwgTm9kZVRyYW5zZm9ybXMpLCBTZWxlY3Rpb25UcmFuc2Zvcm1zKSwgVGV4dFRyYW5zZm9ybXMpO1xuXG5leHBvcnQgeyBFZGl0b3IsIEVsZW1lbnQsIExvY2F0aW9uLCBOb2RlLCBPcGVyYXRpb24sIFBhdGgsIFBhdGhSZWYsIFBvaW50LCBQb2ludFJlZiwgUmFuZ2UsIFJhbmdlUmVmLCBTY3J1YmJlciwgU3BhbiwgVGV4dCwgVHJhbnNmb3JtcywgY3JlYXRlRWRpdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/slate@0.82.0/node_modules/slate/dist/index.es.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/.pnpm/slate@0.82.0/node_modules/slate/dist/index.es.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/.pnpm/slate@0.82.0/node_modules/slate/dist/index.es.js ***!
  \*****************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Editor: () => (/* binding */ Editor),\n/* harmony export */   Element: () => (/* binding */ Element),\n/* harmony export */   Location: () => (/* binding */ Location),\n/* harmony export */   Node: () => (/* binding */ Node),\n/* harmony export */   Operation: () => (/* binding */ Operation),\n/* harmony export */   Path: () => (/* binding */ Path),\n/* harmony export */   PathRef: () => (/* binding */ PathRef),\n/* harmony export */   Point: () => (/* binding */ Point),\n/* harmony export */   PointRef: () => (/* binding */ PointRef),\n/* harmony export */   Range: () => (/* binding */ Range),\n/* harmony export */   RangeRef: () => (/* binding */ RangeRef),\n/* harmony export */   Scrubber: () => (/* binding */ Scrubber),\n/* harmony export */   Span: () => (/* binding */ Span),\n/* harmony export */   Text: () => (/* binding */ Text),\n/* harmony export */   Transforms: () => (/* binding */ Transforms),\n/* harmony export */   createEditor: () => (/* binding */ createEditor)\n/* harmony export */ });\n/* harmony import */ var is_plain_object__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! is-plain-object */ \"(ssr)/./node_modules/.pnpm/is-plain-object@5.0.0/node_modules/is-plain-object/dist/is-plain-object.mjs\");\n/* harmony import */ var immer__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! immer */ \"(ssr)/./node_modules/.pnpm/immer@9.0.21/node_modules/immer/dist/immer.esm.mjs\");\n\n\n\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nvar DIRTY_PATHS = new WeakMap();\nvar DIRTY_PATH_KEYS = new WeakMap();\nvar FLUSHING = new WeakMap();\nvar NORMALIZING = new WeakMap();\nvar PATH_REFS = new WeakMap();\nvar POINT_REFS = new WeakMap();\nvar RANGE_REFS = new WeakMap();\n\nfunction ownKeys$9(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$9(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$9(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$9(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n/**\r\n * Create a new Slate `Editor` object.\r\n */\n\nvar createEditor = () => {\n  var editor = {\n    children: [],\n    operations: [],\n    selection: null,\n    marks: null,\n    isInline: () => false,\n    isVoid: () => false,\n    onChange: () => {},\n    apply: op => {\n      for (var ref of Editor.pathRefs(editor)) {\n        PathRef.transform(ref, op);\n      }\n\n      for (var _ref of Editor.pointRefs(editor)) {\n        PointRef.transform(_ref, op);\n      }\n\n      for (var _ref2 of Editor.rangeRefs(editor)) {\n        RangeRef.transform(_ref2, op);\n      }\n\n      var oldDirtyPaths = DIRTY_PATHS.get(editor) || [];\n      var oldDirtyPathKeys = DIRTY_PATH_KEYS.get(editor) || new Set();\n      var dirtyPaths;\n      var dirtyPathKeys;\n\n      var add = path => {\n        if (path) {\n          var key = path.join(',');\n\n          if (!dirtyPathKeys.has(key)) {\n            dirtyPathKeys.add(key);\n            dirtyPaths.push(path);\n          }\n        }\n      };\n\n      if (Path.operationCanTransformPath(op)) {\n        dirtyPaths = [];\n        dirtyPathKeys = new Set();\n\n        for (var path of oldDirtyPaths) {\n          var newPath = Path.transform(path, op);\n          add(newPath);\n        }\n      } else {\n        dirtyPaths = oldDirtyPaths;\n        dirtyPathKeys = oldDirtyPathKeys;\n      }\n\n      var newDirtyPaths = getDirtyPaths(op);\n\n      for (var _path of newDirtyPaths) {\n        add(_path);\n      }\n\n      DIRTY_PATHS.set(editor, dirtyPaths);\n      DIRTY_PATH_KEYS.set(editor, dirtyPathKeys);\n      Transforms.transform(editor, op);\n      editor.operations.push(op);\n      Editor.normalize(editor); // Clear any formats applied to the cursor if the selection changes.\n\n      if (op.type === 'set_selection') {\n        editor.marks = null;\n      }\n\n      if (!FLUSHING.get(editor)) {\n        FLUSHING.set(editor, true);\n        Promise.resolve().then(() => {\n          FLUSHING.set(editor, false);\n          editor.onChange();\n          editor.operations = [];\n        });\n      }\n    },\n    addMark: (key, value) => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.setNodes(editor, {\n            [key]: value\n          }, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread$9(_objectSpread$9({}, Editor.marks(editor) || {}), {}, {\n            [key]: value\n          });\n\n          editor.marks = marks;\n\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    },\n    deleteBackward: unit => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit,\n          reverse: true\n        });\n      }\n    },\n    deleteForward: unit => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && Range.isCollapsed(selection)) {\n        Transforms.delete(editor, {\n          unit\n        });\n      }\n    },\n    deleteFragment: direction => {\n      var {\n        selection\n      } = editor;\n\n      if (selection && Range.isExpanded(selection)) {\n        Transforms.delete(editor, {\n          reverse: direction === 'backward'\n        });\n      }\n    },\n    getFragment: () => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        return Node.fragment(editor, selection);\n      }\n\n      return [];\n    },\n    insertBreak: () => {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertSoftBreak: () => {\n      Transforms.splitNodes(editor, {\n        always: true\n      });\n    },\n    insertFragment: fragment => {\n      Transforms.insertFragment(editor, fragment);\n    },\n    insertNode: node => {\n      Transforms.insertNodes(editor, node);\n    },\n    insertText: text => {\n      var {\n        selection,\n        marks\n      } = editor;\n\n      if (selection) {\n        if (marks) {\n          var node = _objectSpread$9({\n            text\n          }, marks);\n\n          Transforms.insertNodes(editor, node);\n        } else {\n          Transforms.insertText(editor, text);\n        }\n\n        editor.marks = null;\n      }\n    },\n    normalizeNode: entry => {\n      var [node, path] = entry; // There are no core normalizations for text nodes.\n\n      if (Text.isText(node)) {\n        return;\n      } // Ensure that block and inline nodes have at least one text child.\n\n\n      if (Element.isElement(node) && node.children.length === 0) {\n        var child = {\n          text: ''\n        };\n        Transforms.insertNodes(editor, child, {\n          at: path.concat(0),\n          voids: true\n        });\n        return;\n      } // Determine whether the node should have block or inline children.\n\n\n      var shouldHaveInlines = Editor.isEditor(node) ? false : Element.isElement(node) && (editor.isInline(node) || node.children.length === 0 || Text.isText(node.children[0]) || editor.isInline(node.children[0])); // Since we'll be applying operations while iterating, keep track of an\n      // index that accounts for any added/removed nodes.\n\n      var n = 0;\n\n      for (var i = 0; i < node.children.length; i++, n++) {\n        var currentNode = Node.get(editor, path);\n        if (Text.isText(currentNode)) continue;\n        var _child = node.children[i];\n        var prev = currentNode.children[n - 1];\n        var isLast = i === node.children.length - 1;\n        var isInlineOrText = Text.isText(_child) || Element.isElement(_child) && editor.isInline(_child); // Only allow block nodes in the top-level children and parent blocks\n        // that only contain block nodes. Similarly, only allow inline nodes in\n        // other inline nodes, or parent blocks that only contain inlines and\n        // text.\n\n        if (isInlineOrText !== shouldHaveInlines) {\n          Transforms.removeNodes(editor, {\n            at: path.concat(n),\n            voids: true\n          });\n          n--;\n        } else if (Element.isElement(_child)) {\n          // Ensure that inline nodes are surrounded by text nodes.\n          if (editor.isInline(_child)) {\n            if (prev == null || !Text.isText(prev)) {\n              var newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, newChild, {\n                at: path.concat(n),\n                voids: true\n              });\n              n++;\n            } else if (isLast) {\n              var _newChild = {\n                text: ''\n              };\n              Transforms.insertNodes(editor, _newChild, {\n                at: path.concat(n + 1),\n                voids: true\n              });\n              n++;\n            }\n          }\n        } else {\n          // Merge adjacent text nodes that are empty or match.\n          if (prev != null && Text.isText(prev)) {\n            if (Text.equals(_child, prev, {\n              loose: true\n            })) {\n              Transforms.mergeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            } else if (prev.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n - 1),\n                voids: true\n              });\n              n--;\n            } else if (_child.text === '') {\n              Transforms.removeNodes(editor, {\n                at: path.concat(n),\n                voids: true\n              });\n              n--;\n            }\n          }\n        }\n      }\n    },\n    removeMark: key => {\n      var {\n        selection\n      } = editor;\n\n      if (selection) {\n        if (Range.isExpanded(selection)) {\n          Transforms.unsetNodes(editor, key, {\n            match: Text.isText,\n            split: true\n          });\n        } else {\n          var marks = _objectSpread$9({}, Editor.marks(editor) || {});\n\n          delete marks[key];\n          editor.marks = marks;\n\n          if (!FLUSHING.get(editor)) {\n            editor.onChange();\n          }\n        }\n      }\n    }\n  };\n  return editor;\n};\n/**\r\n * Get the \"dirty\" paths generated from an operation.\r\n */\n\nvar getDirtyPaths = op => {\n  switch (op.type) {\n    case 'insert_text':\n    case 'remove_text':\n    case 'set_node':\n      {\n        var {\n          path\n        } = op;\n        return Path.levels(path);\n      }\n\n    case 'insert_node':\n      {\n        var {\n          node,\n          path: _path2\n        } = op;\n        var levels = Path.levels(_path2);\n        var descendants = Text.isText(node) ? [] : Array.from(Node.nodes(node), _ref3 => {\n          var [, p] = _ref3;\n          return _path2.concat(p);\n        });\n        return [...levels, ...descendants];\n      }\n\n    case 'merge_node':\n      {\n        var {\n          path: _path3\n        } = op;\n        var ancestors = Path.ancestors(_path3);\n        var previousPath = Path.previous(_path3);\n        return [...ancestors, previousPath];\n      }\n\n    case 'move_node':\n      {\n        var {\n          path: _path4,\n          newPath\n        } = op;\n\n        if (Path.equals(_path4, newPath)) {\n          return [];\n        }\n\n        var oldAncestors = [];\n        var newAncestors = [];\n\n        for (var ancestor of Path.ancestors(_path4)) {\n          var p = Path.transform(ancestor, op);\n          oldAncestors.push(p);\n        }\n\n        for (var _ancestor of Path.ancestors(newPath)) {\n          var _p = Path.transform(_ancestor, op);\n\n          newAncestors.push(_p);\n        }\n\n        var newParent = newAncestors[newAncestors.length - 1];\n        var newIndex = newPath[newPath.length - 1];\n        var resultPath = newParent.concat(newIndex);\n        return [...oldAncestors, ...newAncestors, resultPath];\n      }\n\n    case 'remove_node':\n      {\n        var {\n          path: _path5\n        } = op;\n\n        var _ancestors = Path.ancestors(_path5);\n\n        return [..._ancestors];\n      }\n\n    case 'split_node':\n      {\n        var {\n          path: _path6\n        } = op;\n\n        var _levels = Path.levels(_path6);\n\n        var nextPath = Path.next(_path6);\n        return [..._levels, nextPath];\n      }\n\n    default:\n      {\n        return [];\n      }\n  }\n};\n\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n  if (source == null) return {};\n  var target = {};\n  var sourceKeys = Object.keys(source);\n  var key, i;\n\n  for (i = 0; i < sourceKeys.length; i++) {\n    key = sourceKeys[i];\n    if (excluded.indexOf(key) >= 0) continue;\n    target[key] = source[key];\n  }\n\n  return target;\n}\n\nfunction _objectWithoutProperties(source, excluded) {\n  if (source == null) return {};\n  var target = _objectWithoutPropertiesLoose(source, excluded);\n  var key, i;\n\n  if (Object.getOwnPropertySymbols) {\n    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n\n    for (i = 0; i < sourceSymbolKeys.length; i++) {\n      key = sourceSymbolKeys[i];\n      if (excluded.indexOf(key) >= 0) continue;\n      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n      target[key] = source[key];\n    }\n  }\n\n  return target;\n}\n\n// Character (grapheme cluster) boundaries are determined according to\n// the default grapheme cluster boundary specification, extended grapheme clusters variant[1].\n//\n// References:\n//\n// [1] https://www.unicode.org/reports/tr29/#Default_Grapheme_Cluster_Table\n// [2] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakProperty.txt\n// [3] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.html\n// [4] https://www.unicode.org/Public/UCD/latest/ucd/auxiliary/GraphemeBreakTest.txt\n\n/**\r\n * Get the distance to the end of the first character in a string of text.\r\n */\nvar getCharacterDistance = function getCharacterDistance(str) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var isLTR = !isRTL;\n  var codepoints = isRTL ? codepointsIteratorRTL(str) : str;\n  var left = CodepointType.None;\n  var right = CodepointType.None;\n  var distance = 0; // Evaluation of these conditions are deferred.\n\n  var gb11 = null; // Is GB11 applicable?\n\n  var gb12Or13 = null; // Is GB12 or GB13 applicable?\n\n  for (var char of codepoints) {\n    var code = char.codePointAt(0);\n    if (!code) break;\n    var type = getCodepointType(char, code);\n    [left, right] = isLTR ? [right, type] : [type, left];\n\n    if (intersects(left, CodepointType.ZWJ) && intersects(right, CodepointType.ExtPict)) {\n      if (isLTR) {\n        gb11 = endsWithEmojiZWJ(str.substring(0, distance));\n      } else {\n        gb11 = endsWithEmojiZWJ(str.substring(0, str.length - distance));\n      }\n\n      if (!gb11) break;\n    }\n\n    if (intersects(left, CodepointType.RI) && intersects(right, CodepointType.RI)) {\n      if (gb12Or13 !== null) {\n        gb12Or13 = !gb12Or13;\n      } else {\n        if (isLTR) {\n          gb12Or13 = true;\n        } else {\n          gb12Or13 = endsWithOddNumberOfRIs(str.substring(0, str.length - distance));\n        }\n      }\n\n      if (!gb12Or13) break;\n    }\n\n    if (left !== CodepointType.None && right !== CodepointType.None && isBoundaryPair(left, right)) {\n      break;\n    }\n\n    distance += char.length;\n  }\n\n  return distance || 1;\n};\nvar SPACE = /\\s/;\nvar PUNCTUATION = /[\\u0021-\\u0023\\u0025-\\u002A\\u002C-\\u002F\\u003A\\u003B\\u003F\\u0040\\u005B-\\u005D\\u005F\\u007B\\u007D\\u00A1\\u00A7\\u00AB\\u00B6\\u00B7\\u00BB\\u00BF\\u037E\\u0387\\u055A-\\u055F\\u0589\\u058A\\u05BE\\u05C0\\u05C3\\u05C6\\u05F3\\u05F4\\u0609\\u060A\\u060C\\u060D\\u061B\\u061E\\u061F\\u066A-\\u066D\\u06D4\\u0700-\\u070D\\u07F7-\\u07F9\\u0830-\\u083E\\u085E\\u0964\\u0965\\u0970\\u0AF0\\u0DF4\\u0E4F\\u0E5A\\u0E5B\\u0F04-\\u0F12\\u0F14\\u0F3A-\\u0F3D\\u0F85\\u0FD0-\\u0FD4\\u0FD9\\u0FDA\\u104A-\\u104F\\u10FB\\u1360-\\u1368\\u1400\\u166D\\u166E\\u169B\\u169C\\u16EB-\\u16ED\\u1735\\u1736\\u17D4-\\u17D6\\u17D8-\\u17DA\\u1800-\\u180A\\u1944\\u1945\\u1A1E\\u1A1F\\u1AA0-\\u1AA6\\u1AA8-\\u1AAD\\u1B5A-\\u1B60\\u1BFC-\\u1BFF\\u1C3B-\\u1C3F\\u1C7E\\u1C7F\\u1CC0-\\u1CC7\\u1CD3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205E\\u207D\\u207E\\u208D\\u208E\\u2329\\u232A\\u2768-\\u2775\\u27C5\\u27C6\\u27E6-\\u27EF\\u2983-\\u2998\\u29D8-\\u29DB\\u29FC\\u29FD\\u2CF9-\\u2CFC\\u2CFE\\u2CFF\\u2D70\\u2E00-\\u2E2E\\u2E30-\\u2E3B\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301F\\u3030\\u303D\\u30A0\\u30FB\\uA4FE\\uA4FF\\uA60D-\\uA60F\\uA673\\uA67E\\uA6F2-\\uA6F7\\uA874-\\uA877\\uA8CE\\uA8CF\\uA8F8-\\uA8FA\\uA92E\\uA92F\\uA95F\\uA9C1-\\uA9CD\\uA9DE\\uA9DF\\uAA5C-\\uAA5F\\uAADE\\uAADF\\uAAF0\\uAAF1\\uABEB\\uFD3E\\uFD3F\\uFE10-\\uFE19\\uFE30-\\uFE52\\uFE54-\\uFE61\\uFE63\\uFE68\\uFE6A\\uFE6B\\uFF01-\\uFF03\\uFF05-\\uFF0A\\uFF0C-\\uFF0F\\uFF1A\\uFF1B\\uFF1F\\uFF20\\uFF3B-\\uFF3D\\uFF3F\\uFF5B\\uFF5D\\uFF5F-\\uFF65]/;\nvar CHAMELEON = /['\\u2018\\u2019]/;\n/**\r\n * Get the distance to the end of the first word in a string of text.\r\n */\n\nvar getWordDistance = function getWordDistance(text) {\n  var isRTL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var dist = 0;\n  var started = false;\n\n  while (text.length > 0) {\n    var charDist = getCharacterDistance(text, isRTL);\n    var [char, remaining] = splitByCharacterDistance(text, charDist, isRTL);\n\n    if (isWordCharacter(char, remaining, isRTL)) {\n      started = true;\n      dist += charDist;\n    } else if (!started) {\n      dist += charDist;\n    } else {\n      break;\n    }\n\n    text = remaining;\n  }\n\n  return dist;\n};\n/**\r\n * Split a string in two parts at a given distance starting from the end when\r\n * `isRTL` is set to `true`.\r\n */\n\nvar splitByCharacterDistance = (str, dist, isRTL) => {\n  if (isRTL) {\n    var at = str.length - dist;\n    return [str.slice(at, str.length), str.slice(0, at)];\n  }\n\n  return [str.slice(0, dist), str.slice(dist)];\n};\n/**\r\n * Check if a character is a word character. The `remaining` argument is used\r\n * because sometimes you must read subsequent characters to truly determine it.\r\n */\n\nvar isWordCharacter = function isWordCharacter(char, remaining) {\n  var isRTL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n\n  if (SPACE.test(char)) {\n    return false;\n  } // Chameleons count as word characters as long as they're in a word, so\n  // recurse to see if the next one is a word character or not.\n\n\n  if (CHAMELEON.test(char)) {\n    var charDist = getCharacterDistance(remaining, isRTL);\n    var [nextChar, nextRemaining] = splitByCharacterDistance(remaining, charDist, isRTL);\n\n    if (isWordCharacter(nextChar, nextRemaining, isRTL)) {\n      return true;\n    }\n  }\n\n  if (PUNCTUATION.test(char)) {\n    return false;\n  }\n\n  return true;\n};\n/**\r\n * Iterate on codepoints from right to left.\r\n */\n\n\nvar codepointsIteratorRTL = function* codepointsIteratorRTL(str) {\n  var end = str.length - 1;\n\n  for (var i = 0; i < str.length; i++) {\n    var char1 = str.charAt(end - i);\n\n    if (isLowSurrogate(char1.charCodeAt(0))) {\n      var char2 = str.charAt(end - i - 1);\n\n      if (isHighSurrogate(char2.charCodeAt(0))) {\n        yield char2 + char1;\n        i++;\n        continue;\n      }\n    }\n\n    yield char1;\n  }\n};\n/**\r\n * Is `charCode` a high surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */\n\nvar isHighSurrogate = charCode => {\n  return charCode >= 0xd800 && charCode <= 0xdbff;\n};\n/**\r\n * Is `charCode` a low surrogate.\r\n *\r\n * https://en.wikipedia.org/wiki/Universal_Character_Set_characters#Surrogates\r\n */\n\n\nvar isLowSurrogate = charCode => {\n  return charCode >= 0xdc00 && charCode <= 0xdfff;\n};\n\nvar CodepointType;\n\n(function (CodepointType) {\n  CodepointType[CodepointType[\"None\"] = 0] = \"None\";\n  CodepointType[CodepointType[\"Extend\"] = 1] = \"Extend\";\n  CodepointType[CodepointType[\"ZWJ\"] = 2] = \"ZWJ\";\n  CodepointType[CodepointType[\"RI\"] = 4] = \"RI\";\n  CodepointType[CodepointType[\"Prepend\"] = 8] = \"Prepend\";\n  CodepointType[CodepointType[\"SpacingMark\"] = 16] = \"SpacingMark\";\n  CodepointType[CodepointType[\"L\"] = 32] = \"L\";\n  CodepointType[CodepointType[\"V\"] = 64] = \"V\";\n  CodepointType[CodepointType[\"T\"] = 128] = \"T\";\n  CodepointType[CodepointType[\"LV\"] = 256] = \"LV\";\n  CodepointType[CodepointType[\"LVT\"] = 512] = \"LVT\";\n  CodepointType[CodepointType[\"ExtPict\"] = 1024] = \"ExtPict\";\n  CodepointType[CodepointType[\"Any\"] = 2048] = \"Any\";\n})(CodepointType || (CodepointType = {}));\n\nvar reExtend = /^(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])$/;\nvar rePrepend = /^(?:[\\u0600-\\u0605\\u06DD\\u070F\\u0890\\u0891\\u08E2\\u0D4E]|\\uD804[\\uDCBD\\uDCCD\\uDDC2\\uDDC3]|\\uD806[\\uDD3F\\uDD41\\uDE3A\\uDE84-\\uDE89]|\\uD807\\uDD46)$/;\nvar reSpacingMark = /^(?:[\\u0903\\u093B\\u093E-\\u0940\\u0949-\\u094C\\u094E\\u094F\\u0982\\u0983\\u09BF\\u09C0\\u09C7\\u09C8\\u09CB\\u09CC\\u0A03\\u0A3E-\\u0A40\\u0A83\\u0ABE-\\u0AC0\\u0AC9\\u0ACB\\u0ACC\\u0B02\\u0B03\\u0B40\\u0B47\\u0B48\\u0B4B\\u0B4C\\u0BBF\\u0BC1\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCC\\u0C01-\\u0C03\\u0C41-\\u0C44\\u0C82\\u0C83\\u0CBE\\u0CC0\\u0CC1\\u0CC3\\u0CC4\\u0CC7\\u0CC8\\u0CCA\\u0CCB\\u0D02\\u0D03\\u0D3F\\u0D40\\u0D46-\\u0D48\\u0D4A-\\u0D4C\\u0D82\\u0D83\\u0DD0\\u0DD1\\u0DD8-\\u0DDE\\u0DF2\\u0DF3\\u0E33\\u0EB3\\u0F3E\\u0F3F\\u0F7F\\u1031\\u103B\\u103C\\u1056\\u1057\\u1084\\u1715\\u1734\\u17B6\\u17BE-\\u17C5\\u17C7\\u17C8\\u1923-\\u1926\\u1929-\\u192B\\u1930\\u1931\\u1933-\\u1938\\u1A19\\u1A1A\\u1A55\\u1A57\\u1A6D-\\u1A72\\u1B04\\u1B3B\\u1B3D-\\u1B41\\u1B43\\u1B44\\u1B82\\u1BA1\\u1BA6\\u1BA7\\u1BAA\\u1BE7\\u1BEA-\\u1BEC\\u1BEE\\u1BF2\\u1BF3\\u1C24-\\u1C2B\\u1C34\\u1C35\\u1CE1\\u1CF7\\uA823\\uA824\\uA827\\uA880\\uA881\\uA8B4-\\uA8C3\\uA952\\uA953\\uA983\\uA9B4\\uA9B5\\uA9BA\\uA9BB\\uA9BE-\\uA9C0\\uAA2F\\uAA30\\uAA33\\uAA34\\uAA4D\\uAAEB\\uAAEE\\uAAEF\\uAAF5\\uABE3\\uABE4\\uABE6\\uABE7\\uABE9\\uABEA\\uABEC]|\\uD804[\\uDC00\\uDC02\\uDC82\\uDCB0-\\uDCB2\\uDCB7\\uDCB8\\uDD2C\\uDD45\\uDD46\\uDD82\\uDDB3-\\uDDB5\\uDDBF\\uDDC0\\uDDCE\\uDE2C-\\uDE2E\\uDE32\\uDE33\\uDE35\\uDEE0-\\uDEE2\\uDF02\\uDF03\\uDF3F\\uDF41-\\uDF44\\uDF47\\uDF48\\uDF4B-\\uDF4D\\uDF62\\uDF63]|\\uD805[\\uDC35-\\uDC37\\uDC40\\uDC41\\uDC45\\uDCB1\\uDCB2\\uDCB9\\uDCBB\\uDCBC\\uDCBE\\uDCC1\\uDDB0\\uDDB1\\uDDB8-\\uDDBB\\uDDBE\\uDE30-\\uDE32\\uDE3B\\uDE3C\\uDE3E\\uDEAC\\uDEAE\\uDEAF\\uDEB6\\uDF26]|\\uD806[\\uDC2C-\\uDC2E\\uDC38\\uDD31-\\uDD35\\uDD37\\uDD38\\uDD3D\\uDD40\\uDD42\\uDDD1-\\uDDD3\\uDDDC-\\uDDDF\\uDDE4\\uDE39\\uDE57\\uDE58\\uDE97]|\\uD807[\\uDC2F\\uDC3E\\uDCA9\\uDCB1\\uDCB4\\uDD8A-\\uDD8E\\uDD93\\uDD94\\uDD96\\uDEF5\\uDEF6]|\\uD81B[\\uDF51-\\uDF87\\uDFF0\\uDFF1]|\\uD834[\\uDD66\\uDD6D])$/;\nvar reL = /^[\\u1100-\\u115F\\uA960-\\uA97C]$/;\nvar reV = /^[\\u1160-\\u11A7\\uD7B0-\\uD7C6]$/;\nvar reT = /^[\\u11A8-\\u11FF\\uD7CB-\\uD7FB]$/;\nvar reLV = /^[\\uAC00\\uAC1C\\uAC38\\uAC54\\uAC70\\uAC8C\\uACA8\\uACC4\\uACE0\\uACFC\\uAD18\\uAD34\\uAD50\\uAD6C\\uAD88\\uADA4\\uADC0\\uADDC\\uADF8\\uAE14\\uAE30\\uAE4C\\uAE68\\uAE84\\uAEA0\\uAEBC\\uAED8\\uAEF4\\uAF10\\uAF2C\\uAF48\\uAF64\\uAF80\\uAF9C\\uAFB8\\uAFD4\\uAFF0\\uB00C\\uB028\\uB044\\uB060\\uB07C\\uB098\\uB0B4\\uB0D0\\uB0EC\\uB108\\uB124\\uB140\\uB15C\\uB178\\uB194\\uB1B0\\uB1CC\\uB1E8\\uB204\\uB220\\uB23C\\uB258\\uB274\\uB290\\uB2AC\\uB2C8\\uB2E4\\uB300\\uB31C\\uB338\\uB354\\uB370\\uB38C\\uB3A8\\uB3C4\\uB3E0\\uB3FC\\uB418\\uB434\\uB450\\uB46C\\uB488\\uB4A4\\uB4C0\\uB4DC\\uB4F8\\uB514\\uB530\\uB54C\\uB568\\uB584\\uB5A0\\uB5BC\\uB5D8\\uB5F4\\uB610\\uB62C\\uB648\\uB664\\uB680\\uB69C\\uB6B8\\uB6D4\\uB6F0\\uB70C\\uB728\\uB744\\uB760\\uB77C\\uB798\\uB7B4\\uB7D0\\uB7EC\\uB808\\uB824\\uB840\\uB85C\\uB878\\uB894\\uB8B0\\uB8CC\\uB8E8\\uB904\\uB920\\uB93C\\uB958\\uB974\\uB990\\uB9AC\\uB9C8\\uB9E4\\uBA00\\uBA1C\\uBA38\\uBA54\\uBA70\\uBA8C\\uBAA8\\uBAC4\\uBAE0\\uBAFC\\uBB18\\uBB34\\uBB50\\uBB6C\\uBB88\\uBBA4\\uBBC0\\uBBDC\\uBBF8\\uBC14\\uBC30\\uBC4C\\uBC68\\uBC84\\uBCA0\\uBCBC\\uBCD8\\uBCF4\\uBD10\\uBD2C\\uBD48\\uBD64\\uBD80\\uBD9C\\uBDB8\\uBDD4\\uBDF0\\uBE0C\\uBE28\\uBE44\\uBE60\\uBE7C\\uBE98\\uBEB4\\uBED0\\uBEEC\\uBF08\\uBF24\\uBF40\\uBF5C\\uBF78\\uBF94\\uBFB0\\uBFCC\\uBFE8\\uC004\\uC020\\uC03C\\uC058\\uC074\\uC090\\uC0AC\\uC0C8\\uC0E4\\uC100\\uC11C\\uC138\\uC154\\uC170\\uC18C\\uC1A8\\uC1C4\\uC1E0\\uC1FC\\uC218\\uC234\\uC250\\uC26C\\uC288\\uC2A4\\uC2C0\\uC2DC\\uC2F8\\uC314\\uC330\\uC34C\\uC368\\uC384\\uC3A0\\uC3BC\\uC3D8\\uC3F4\\uC410\\uC42C\\uC448\\uC464\\uC480\\uC49C\\uC4B8\\uC4D4\\uC4F0\\uC50C\\uC528\\uC544\\uC560\\uC57C\\uC598\\uC5B4\\uC5D0\\uC5EC\\uC608\\uC624\\uC640\\uC65C\\uC678\\uC694\\uC6B0\\uC6CC\\uC6E8\\uC704\\uC720\\uC73C\\uC758\\uC774\\uC790\\uC7AC\\uC7C8\\uC7E4\\uC800\\uC81C\\uC838\\uC854\\uC870\\uC88C\\uC8A8\\uC8C4\\uC8E0\\uC8FC\\uC918\\uC934\\uC950\\uC96C\\uC988\\uC9A4\\uC9C0\\uC9DC\\uC9F8\\uCA14\\uCA30\\uCA4C\\uCA68\\uCA84\\uCAA0\\uCABC\\uCAD8\\uCAF4\\uCB10\\uCB2C\\uCB48\\uCB64\\uCB80\\uCB9C\\uCBB8\\uCBD4\\uCBF0\\uCC0C\\uCC28\\uCC44\\uCC60\\uCC7C\\uCC98\\uCCB4\\uCCD0\\uCCEC\\uCD08\\uCD24\\uCD40\\uCD5C\\uCD78\\uCD94\\uCDB0\\uCDCC\\uCDE8\\uCE04\\uCE20\\uCE3C\\uCE58\\uCE74\\uCE90\\uCEAC\\uCEC8\\uCEE4\\uCF00\\uCF1C\\uCF38\\uCF54\\uCF70\\uCF8C\\uCFA8\\uCFC4\\uCFE0\\uCFFC\\uD018\\uD034\\uD050\\uD06C\\uD088\\uD0A4\\uD0C0\\uD0DC\\uD0F8\\uD114\\uD130\\uD14C\\uD168\\uD184\\uD1A0\\uD1BC\\uD1D8\\uD1F4\\uD210\\uD22C\\uD248\\uD264\\uD280\\uD29C\\uD2B8\\uD2D4\\uD2F0\\uD30C\\uD328\\uD344\\uD360\\uD37C\\uD398\\uD3B4\\uD3D0\\uD3EC\\uD408\\uD424\\uD440\\uD45C\\uD478\\uD494\\uD4B0\\uD4CC\\uD4E8\\uD504\\uD520\\uD53C\\uD558\\uD574\\uD590\\uD5AC\\uD5C8\\uD5E4\\uD600\\uD61C\\uD638\\uD654\\uD670\\uD68C\\uD6A8\\uD6C4\\uD6E0\\uD6FC\\uD718\\uD734\\uD750\\uD76C\\uD788]$/;\nvar reLVT = /^[\\uAC01-\\uAC1B\\uAC1D-\\uAC37\\uAC39-\\uAC53\\uAC55-\\uAC6F\\uAC71-\\uAC8B\\uAC8D-\\uACA7\\uACA9-\\uACC3\\uACC5-\\uACDF\\uACE1-\\uACFB\\uACFD-\\uAD17\\uAD19-\\uAD33\\uAD35-\\uAD4F\\uAD51-\\uAD6B\\uAD6D-\\uAD87\\uAD89-\\uADA3\\uADA5-\\uADBF\\uADC1-\\uADDB\\uADDD-\\uADF7\\uADF9-\\uAE13\\uAE15-\\uAE2F\\uAE31-\\uAE4B\\uAE4D-\\uAE67\\uAE69-\\uAE83\\uAE85-\\uAE9F\\uAEA1-\\uAEBB\\uAEBD-\\uAED7\\uAED9-\\uAEF3\\uAEF5-\\uAF0F\\uAF11-\\uAF2B\\uAF2D-\\uAF47\\uAF49-\\uAF63\\uAF65-\\uAF7F\\uAF81-\\uAF9B\\uAF9D-\\uAFB7\\uAFB9-\\uAFD3\\uAFD5-\\uAFEF\\uAFF1-\\uB00B\\uB00D-\\uB027\\uB029-\\uB043\\uB045-\\uB05F\\uB061-\\uB07B\\uB07D-\\uB097\\uB099-\\uB0B3\\uB0B5-\\uB0CF\\uB0D1-\\uB0EB\\uB0ED-\\uB107\\uB109-\\uB123\\uB125-\\uB13F\\uB141-\\uB15B\\uB15D-\\uB177\\uB179-\\uB193\\uB195-\\uB1AF\\uB1B1-\\uB1CB\\uB1CD-\\uB1E7\\uB1E9-\\uB203\\uB205-\\uB21F\\uB221-\\uB23B\\uB23D-\\uB257\\uB259-\\uB273\\uB275-\\uB28F\\uB291-\\uB2AB\\uB2AD-\\uB2C7\\uB2C9-\\uB2E3\\uB2E5-\\uB2FF\\uB301-\\uB31B\\uB31D-\\uB337\\uB339-\\uB353\\uB355-\\uB36F\\uB371-\\uB38B\\uB38D-\\uB3A7\\uB3A9-\\uB3C3\\uB3C5-\\uB3DF\\uB3E1-\\uB3FB\\uB3FD-\\uB417\\uB419-\\uB433\\uB435-\\uB44F\\uB451-\\uB46B\\uB46D-\\uB487\\uB489-\\uB4A3\\uB4A5-\\uB4BF\\uB4C1-\\uB4DB\\uB4DD-\\uB4F7\\uB4F9-\\uB513\\uB515-\\uB52F\\uB531-\\uB54B\\uB54D-\\uB567\\uB569-\\uB583\\uB585-\\uB59F\\uB5A1-\\uB5BB\\uB5BD-\\uB5D7\\uB5D9-\\uB5F3\\uB5F5-\\uB60F\\uB611-\\uB62B\\uB62D-\\uB647\\uB649-\\uB663\\uB665-\\uB67F\\uB681-\\uB69B\\uB69D-\\uB6B7\\uB6B9-\\uB6D3\\uB6D5-\\uB6EF\\uB6F1-\\uB70B\\uB70D-\\uB727\\uB729-\\uB743\\uB745-\\uB75F\\uB761-\\uB77B\\uB77D-\\uB797\\uB799-\\uB7B3\\uB7B5-\\uB7CF\\uB7D1-\\uB7EB\\uB7ED-\\uB807\\uB809-\\uB823\\uB825-\\uB83F\\uB841-\\uB85B\\uB85D-\\uB877\\uB879-\\uB893\\uB895-\\uB8AF\\uB8B1-\\uB8CB\\uB8CD-\\uB8E7\\uB8E9-\\uB903\\uB905-\\uB91F\\uB921-\\uB93B\\uB93D-\\uB957\\uB959-\\uB973\\uB975-\\uB98F\\uB991-\\uB9AB\\uB9AD-\\uB9C7\\uB9C9-\\uB9E3\\uB9E5-\\uB9FF\\uBA01-\\uBA1B\\uBA1D-\\uBA37\\uBA39-\\uBA53\\uBA55-\\uBA6F\\uBA71-\\uBA8B\\uBA8D-\\uBAA7\\uBAA9-\\uBAC3\\uBAC5-\\uBADF\\uBAE1-\\uBAFB\\uBAFD-\\uBB17\\uBB19-\\uBB33\\uBB35-\\uBB4F\\uBB51-\\uBB6B\\uBB6D-\\uBB87\\uBB89-\\uBBA3\\uBBA5-\\uBBBF\\uBBC1-\\uBBDB\\uBBDD-\\uBBF7\\uBBF9-\\uBC13\\uBC15-\\uBC2F\\uBC31-\\uBC4B\\uBC4D-\\uBC67\\uBC69-\\uBC83\\uBC85-\\uBC9F\\uBCA1-\\uBCBB\\uBCBD-\\uBCD7\\uBCD9-\\uBCF3\\uBCF5-\\uBD0F\\uBD11-\\uBD2B\\uBD2D-\\uBD47\\uBD49-\\uBD63\\uBD65-\\uBD7F\\uBD81-\\uBD9B\\uBD9D-\\uBDB7\\uBDB9-\\uBDD3\\uBDD5-\\uBDEF\\uBDF1-\\uBE0B\\uBE0D-\\uBE27\\uBE29-\\uBE43\\uBE45-\\uBE5F\\uBE61-\\uBE7B\\uBE7D-\\uBE97\\uBE99-\\uBEB3\\uBEB5-\\uBECF\\uBED1-\\uBEEB\\uBEED-\\uBF07\\uBF09-\\uBF23\\uBF25-\\uBF3F\\uBF41-\\uBF5B\\uBF5D-\\uBF77\\uBF79-\\uBF93\\uBF95-\\uBFAF\\uBFB1-\\uBFCB\\uBFCD-\\uBFE7\\uBFE9-\\uC003\\uC005-\\uC01F\\uC021-\\uC03B\\uC03D-\\uC057\\uC059-\\uC073\\uC075-\\uC08F\\uC091-\\uC0AB\\uC0AD-\\uC0C7\\uC0C9-\\uC0E3\\uC0E5-\\uC0FF\\uC101-\\uC11B\\uC11D-\\uC137\\uC139-\\uC153\\uC155-\\uC16F\\uC171-\\uC18B\\uC18D-\\uC1A7\\uC1A9-\\uC1C3\\uC1C5-\\uC1DF\\uC1E1-\\uC1FB\\uC1FD-\\uC217\\uC219-\\uC233\\uC235-\\uC24F\\uC251-\\uC26B\\uC26D-\\uC287\\uC289-\\uC2A3\\uC2A5-\\uC2BF\\uC2C1-\\uC2DB\\uC2DD-\\uC2F7\\uC2F9-\\uC313\\uC315-\\uC32F\\uC331-\\uC34B\\uC34D-\\uC367\\uC369-\\uC383\\uC385-\\uC39F\\uC3A1-\\uC3BB\\uC3BD-\\uC3D7\\uC3D9-\\uC3F3\\uC3F5-\\uC40F\\uC411-\\uC42B\\uC42D-\\uC447\\uC449-\\uC463\\uC465-\\uC47F\\uC481-\\uC49B\\uC49D-\\uC4B7\\uC4B9-\\uC4D3\\uC4D5-\\uC4EF\\uC4F1-\\uC50B\\uC50D-\\uC527\\uC529-\\uC543\\uC545-\\uC55F\\uC561-\\uC57B\\uC57D-\\uC597\\uC599-\\uC5B3\\uC5B5-\\uC5CF\\uC5D1-\\uC5EB\\uC5ED-\\uC607\\uC609-\\uC623\\uC625-\\uC63F\\uC641-\\uC65B\\uC65D-\\uC677\\uC679-\\uC693\\uC695-\\uC6AF\\uC6B1-\\uC6CB\\uC6CD-\\uC6E7\\uC6E9-\\uC703\\uC705-\\uC71F\\uC721-\\uC73B\\uC73D-\\uC757\\uC759-\\uC773\\uC775-\\uC78F\\uC791-\\uC7AB\\uC7AD-\\uC7C7\\uC7C9-\\uC7E3\\uC7E5-\\uC7FF\\uC801-\\uC81B\\uC81D-\\uC837\\uC839-\\uC853\\uC855-\\uC86F\\uC871-\\uC88B\\uC88D-\\uC8A7\\uC8A9-\\uC8C3\\uC8C5-\\uC8DF\\uC8E1-\\uC8FB\\uC8FD-\\uC917\\uC919-\\uC933\\uC935-\\uC94F\\uC951-\\uC96B\\uC96D-\\uC987\\uC989-\\uC9A3\\uC9A5-\\uC9BF\\uC9C1-\\uC9DB\\uC9DD-\\uC9F7\\uC9F9-\\uCA13\\uCA15-\\uCA2F\\uCA31-\\uCA4B\\uCA4D-\\uCA67\\uCA69-\\uCA83\\uCA85-\\uCA9F\\uCAA1-\\uCABB\\uCABD-\\uCAD7\\uCAD9-\\uCAF3\\uCAF5-\\uCB0F\\uCB11-\\uCB2B\\uCB2D-\\uCB47\\uCB49-\\uCB63\\uCB65-\\uCB7F\\uCB81-\\uCB9B\\uCB9D-\\uCBB7\\uCBB9-\\uCBD3\\uCBD5-\\uCBEF\\uCBF1-\\uCC0B\\uCC0D-\\uCC27\\uCC29-\\uCC43\\uCC45-\\uCC5F\\uCC61-\\uCC7B\\uCC7D-\\uCC97\\uCC99-\\uCCB3\\uCCB5-\\uCCCF\\uCCD1-\\uCCEB\\uCCED-\\uCD07\\uCD09-\\uCD23\\uCD25-\\uCD3F\\uCD41-\\uCD5B\\uCD5D-\\uCD77\\uCD79-\\uCD93\\uCD95-\\uCDAF\\uCDB1-\\uCDCB\\uCDCD-\\uCDE7\\uCDE9-\\uCE03\\uCE05-\\uCE1F\\uCE21-\\uCE3B\\uCE3D-\\uCE57\\uCE59-\\uCE73\\uCE75-\\uCE8F\\uCE91-\\uCEAB\\uCEAD-\\uCEC7\\uCEC9-\\uCEE3\\uCEE5-\\uCEFF\\uCF01-\\uCF1B\\uCF1D-\\uCF37\\uCF39-\\uCF53\\uCF55-\\uCF6F\\uCF71-\\uCF8B\\uCF8D-\\uCFA7\\uCFA9-\\uCFC3\\uCFC5-\\uCFDF\\uCFE1-\\uCFFB\\uCFFD-\\uD017\\uD019-\\uD033\\uD035-\\uD04F\\uD051-\\uD06B\\uD06D-\\uD087\\uD089-\\uD0A3\\uD0A5-\\uD0BF\\uD0C1-\\uD0DB\\uD0DD-\\uD0F7\\uD0F9-\\uD113\\uD115-\\uD12F\\uD131-\\uD14B\\uD14D-\\uD167\\uD169-\\uD183\\uD185-\\uD19F\\uD1A1-\\uD1BB\\uD1BD-\\uD1D7\\uD1D9-\\uD1F3\\uD1F5-\\uD20F\\uD211-\\uD22B\\uD22D-\\uD247\\uD249-\\uD263\\uD265-\\uD27F\\uD281-\\uD29B\\uD29D-\\uD2B7\\uD2B9-\\uD2D3\\uD2D5-\\uD2EF\\uD2F1-\\uD30B\\uD30D-\\uD327\\uD329-\\uD343\\uD345-\\uD35F\\uD361-\\uD37B\\uD37D-\\uD397\\uD399-\\uD3B3\\uD3B5-\\uD3CF\\uD3D1-\\uD3EB\\uD3ED-\\uD407\\uD409-\\uD423\\uD425-\\uD43F\\uD441-\\uD45B\\uD45D-\\uD477\\uD479-\\uD493\\uD495-\\uD4AF\\uD4B1-\\uD4CB\\uD4CD-\\uD4E7\\uD4E9-\\uD503\\uD505-\\uD51F\\uD521-\\uD53B\\uD53D-\\uD557\\uD559-\\uD573\\uD575-\\uD58F\\uD591-\\uD5AB\\uD5AD-\\uD5C7\\uD5C9-\\uD5E3\\uD5E5-\\uD5FF\\uD601-\\uD61B\\uD61D-\\uD637\\uD639-\\uD653\\uD655-\\uD66F\\uD671-\\uD68B\\uD68D-\\uD6A7\\uD6A9-\\uD6C3\\uD6C5-\\uD6DF\\uD6E1-\\uD6FB\\uD6FD-\\uD717\\uD719-\\uD733\\uD735-\\uD74F\\uD751-\\uD76B\\uD76D-\\uD787\\uD789-\\uD7A3]$/;\nvar reExtPict = /^(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])$/;\n\nvar getCodepointType = (char, code) => {\n  var type = CodepointType.Any;\n\n  if (char.search(reExtend) !== -1) {\n    type |= CodepointType.Extend;\n  }\n\n  if (code === 0x200d) {\n    type |= CodepointType.ZWJ;\n  }\n\n  if (code >= 0x1f1e6 && code <= 0x1f1ff) {\n    type |= CodepointType.RI;\n  }\n\n  if (char.search(rePrepend) !== -1) {\n    type |= CodepointType.Prepend;\n  }\n\n  if (char.search(reSpacingMark) !== -1) {\n    type |= CodepointType.SpacingMark;\n  }\n\n  if (char.search(reL) !== -1) {\n    type |= CodepointType.L;\n  }\n\n  if (char.search(reV) !== -1) {\n    type |= CodepointType.V;\n  }\n\n  if (char.search(reT) !== -1) {\n    type |= CodepointType.T;\n  }\n\n  if (char.search(reLV) !== -1) {\n    type |= CodepointType.LV;\n  }\n\n  if (char.search(reLVT) !== -1) {\n    type |= CodepointType.LVT;\n  }\n\n  if (char.search(reExtPict) !== -1) {\n    type |= CodepointType.ExtPict;\n  }\n\n  return type;\n};\n\nfunction intersects(x, y) {\n  return (x & y) !== 0;\n}\n\nvar NonBoundaryPairs = [// GB6\n[CodepointType.L, CodepointType.L | CodepointType.V | CodepointType.LV | CodepointType.LVT], // GB7\n[CodepointType.LV | CodepointType.V, CodepointType.V | CodepointType.T], // GB8\n[CodepointType.LVT | CodepointType.T, CodepointType.T], // GB9\n[CodepointType.Any, CodepointType.Extend | CodepointType.ZWJ], // GB9a\n[CodepointType.Any, CodepointType.SpacingMark], // GB9b\n[CodepointType.Prepend, CodepointType.Any], // GB11\n[CodepointType.ZWJ, CodepointType.ExtPict], // GB12 and GB13\n[CodepointType.RI, CodepointType.RI]];\n\nfunction isBoundaryPair(left, right) {\n  return NonBoundaryPairs.findIndex(r => intersects(left, r[0]) && intersects(right, r[1])) === -1;\n}\n\nvar endingEmojiZWJ = /(?:[\\xA9\\xAE\\u203C\\u2049\\u2122\\u2139\\u2194-\\u2199\\u21A9\\u21AA\\u231A\\u231B\\u2328\\u2388\\u23CF\\u23E9-\\u23F3\\u23F8-\\u23FA\\u24C2\\u25AA\\u25AB\\u25B6\\u25C0\\u25FB-\\u25FE\\u2600-\\u2605\\u2607-\\u2612\\u2614-\\u2685\\u2690-\\u2705\\u2708-\\u2712\\u2714\\u2716\\u271D\\u2721\\u2728\\u2733\\u2734\\u2744\\u2747\\u274C\\u274E\\u2753-\\u2755\\u2757\\u2763-\\u2767\\u2795-\\u2797\\u27A1\\u27B0\\u27BF\\u2934\\u2935\\u2B05-\\u2B07\\u2B1B\\u2B1C\\u2B50\\u2B55\\u3030\\u303D\\u3297\\u3299]|\\uD83C[\\uDC00-\\uDCFF\\uDD0D-\\uDD0F\\uDD2F\\uDD6C-\\uDD71\\uDD7E\\uDD7F\\uDD8E\\uDD91-\\uDD9A\\uDDAD-\\uDDE5\\uDE01-\\uDE0F\\uDE1A\\uDE2F\\uDE32-\\uDE3A\\uDE3C-\\uDE3F\\uDE49-\\uDFFA]|\\uD83D[\\uDC00-\\uDD3D\\uDD46-\\uDE4F\\uDE80-\\uDEFF\\uDF74-\\uDF7F\\uDFD5-\\uDFFF]|\\uD83E[\\uDC0C-\\uDC0F\\uDC48-\\uDC4F\\uDC5A-\\uDC5F\\uDC88-\\uDC8F\\uDCAE-\\uDCFF\\uDD0C-\\uDD3A\\uDD3C-\\uDD45\\uDD47-\\uDEFF]|\\uD83F[\\uDC00-\\uDFFD])(?:[\\u0300-\\u036F\\u0483-\\u0489\\u0591-\\u05BD\\u05BF\\u05C1\\u05C2\\u05C4\\u05C5\\u05C7\\u0610-\\u061A\\u064B-\\u065F\\u0670\\u06D6-\\u06DC\\u06DF-\\u06E4\\u06E7\\u06E8\\u06EA-\\u06ED\\u0711\\u0730-\\u074A\\u07A6-\\u07B0\\u07EB-\\u07F3\\u07FD\\u0816-\\u0819\\u081B-\\u0823\\u0825-\\u0827\\u0829-\\u082D\\u0859-\\u085B\\u08D3-\\u08E1\\u08E3-\\u0902\\u093A\\u093C\\u0941-\\u0948\\u094D\\u0951-\\u0957\\u0962\\u0963\\u0981\\u09BC\\u09BE\\u09C1-\\u09C4\\u09CD\\u09D7\\u09E2\\u09E3\\u09FE\\u0A01\\u0A02\\u0A3C\\u0A41\\u0A42\\u0A47\\u0A48\\u0A4B-\\u0A4D\\u0A51\\u0A70\\u0A71\\u0A75\\u0A81\\u0A82\\u0ABC\\u0AC1-\\u0AC5\\u0AC7\\u0AC8\\u0ACD\\u0AE2\\u0AE3\\u0AFA-\\u0AFF\\u0B01\\u0B3C\\u0B3E\\u0B3F\\u0B41-\\u0B44\\u0B4D\\u0B55-\\u0B57\\u0B62\\u0B63\\u0B82\\u0BBE\\u0BC0\\u0BCD\\u0BD7\\u0C00\\u0C04\\u0C3E-\\u0C40\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56\\u0C62\\u0C63\\u0C81\\u0CBC\\u0CBF\\u0CC2\\u0CC6\\u0CCC\\u0CCD\\u0CD5\\u0CD6\\u0CE2\\u0CE3\\u0D00\\u0D01\\u0D3B\\u0D3C\\u0D3E\\u0D41-\\u0D44\\u0D4D\\u0D57\\u0D62\\u0D63\\u0D81\\u0DCA\\u0DCF\\u0DD2-\\u0DD4\\u0DD6\\u0DDF\\u0E31\\u0E34-\\u0E3A\\u0E47-\\u0E4E\\u0EB1\\u0EB4-\\u0EBC\\u0EC8-\\u0ECD\\u0F18\\u0F19\\u0F35\\u0F37\\u0F39\\u0F71-\\u0F7E\\u0F80-\\u0F84\\u0F86\\u0F87\\u0F8D-\\u0F97\\u0F99-\\u0FBC\\u0FC6\\u102D-\\u1030\\u1032-\\u1037\\u1039\\u103A\\u103D\\u103E\\u1058\\u1059\\u105E-\\u1060\\u1071-\\u1074\\u1082\\u1085\\u1086\\u108D\\u109D\\u135D-\\u135F\\u1712-\\u1714\\u1732-\\u1734\\u1752\\u1753\\u1772\\u1773\\u17B4\\u17B5\\u17B7-\\u17BD\\u17C6\\u17C9-\\u17D3\\u17DD\\u180B-\\u180D\\u1885\\u1886\\u18A9\\u1920-\\u1922\\u1927\\u1928\\u1932\\u1939-\\u193B\\u1A17\\u1A18\\u1A1B\\u1A56\\u1A58-\\u1A5E\\u1A60\\u1A62\\u1A65-\\u1A6C\\u1A73-\\u1A7C\\u1A7F\\u1AB0-\\u1AC0\\u1B00-\\u1B03\\u1B34-\\u1B3A\\u1B3C\\u1B42\\u1B6B-\\u1B73\\u1B80\\u1B81\\u1BA2-\\u1BA5\\u1BA8\\u1BA9\\u1BAB-\\u1BAD\\u1BE6\\u1BE8\\u1BE9\\u1BED\\u1BEF-\\u1BF1\\u1C2C-\\u1C33\\u1C36\\u1C37\\u1CD0-\\u1CD2\\u1CD4-\\u1CE0\\u1CE2-\\u1CE8\\u1CED\\u1CF4\\u1CF8\\u1CF9\\u1DC0-\\u1DF9\\u1DFB-\\u1DFF\\u200C\\u20D0-\\u20F0\\u2CEF-\\u2CF1\\u2D7F\\u2DE0-\\u2DFF\\u302A-\\u302F\\u3099\\u309A\\uA66F-\\uA672\\uA674-\\uA67D\\uA69E\\uA69F\\uA6F0\\uA6F1\\uA802\\uA806\\uA80B\\uA825\\uA826\\uA82C\\uA8C4\\uA8C5\\uA8E0-\\uA8F1\\uA8FF\\uA926-\\uA92D\\uA947-\\uA951\\uA980-\\uA982\\uA9B3\\uA9B6-\\uA9B9\\uA9BC\\uA9BD\\uA9E5\\uAA29-\\uAA2E\\uAA31\\uAA32\\uAA35\\uAA36\\uAA43\\uAA4C\\uAA7C\\uAAB0\\uAAB2-\\uAAB4\\uAAB7\\uAAB8\\uAABE\\uAABF\\uAAC1\\uAAEC\\uAAED\\uAAF6\\uABE5\\uABE8\\uABED\\uFB1E\\uFE00-\\uFE0F\\uFE20-\\uFE2F\\uFF9E\\uFF9F]|\\uD800[\\uDDFD\\uDEE0\\uDF76-\\uDF7A]|\\uD802[\\uDE01-\\uDE03\\uDE05\\uDE06\\uDE0C-\\uDE0F\\uDE38-\\uDE3A\\uDE3F\\uDEE5\\uDEE6]|\\uD803[\\uDD24-\\uDD27\\uDEAB\\uDEAC\\uDF46-\\uDF50]|\\uD804[\\uDC01\\uDC38-\\uDC46\\uDC7F-\\uDC81\\uDCB3-\\uDCB6\\uDCB9\\uDCBA\\uDD00-\\uDD02\\uDD27-\\uDD2B\\uDD2D-\\uDD34\\uDD73\\uDD80\\uDD81\\uDDB6-\\uDDBE\\uDDC9-\\uDDCC\\uDDCF\\uDE2F-\\uDE31\\uDE34\\uDE36\\uDE37\\uDE3E\\uDEDF\\uDEE3-\\uDEEA\\uDF00\\uDF01\\uDF3B\\uDF3C\\uDF3E\\uDF40\\uDF57\\uDF66-\\uDF6C\\uDF70-\\uDF74]|\\uD805[\\uDC38-\\uDC3F\\uDC42-\\uDC44\\uDC46\\uDC5E\\uDCB0\\uDCB3-\\uDCB8\\uDCBA\\uDCBD\\uDCBF\\uDCC0\\uDCC2\\uDCC3\\uDDAF\\uDDB2-\\uDDB5\\uDDBC\\uDDBD\\uDDBF\\uDDC0\\uDDDC\\uDDDD\\uDE33-\\uDE3A\\uDE3D\\uDE3F\\uDE40\\uDEAB\\uDEAD\\uDEB0-\\uDEB5\\uDEB7\\uDF1D-\\uDF1F\\uDF22-\\uDF25\\uDF27-\\uDF2B]|\\uD806[\\uDC2F-\\uDC37\\uDC39\\uDC3A\\uDD30\\uDD3B\\uDD3C\\uDD3E\\uDD43\\uDDD4-\\uDDD7\\uDDDA\\uDDDB\\uDDE0\\uDE01-\\uDE0A\\uDE33-\\uDE38\\uDE3B-\\uDE3E\\uDE47\\uDE51-\\uDE56\\uDE59-\\uDE5B\\uDE8A-\\uDE96\\uDE98\\uDE99]|\\uD807[\\uDC30-\\uDC36\\uDC38-\\uDC3D\\uDC3F\\uDC92-\\uDCA7\\uDCAA-\\uDCB0\\uDCB2\\uDCB3\\uDCB5\\uDCB6\\uDD31-\\uDD36\\uDD3A\\uDD3C\\uDD3D\\uDD3F-\\uDD45\\uDD47\\uDD90\\uDD91\\uDD95\\uDD97\\uDEF3\\uDEF4]|\\uD81A[\\uDEF0-\\uDEF4\\uDF30-\\uDF36]|\\uD81B[\\uDF4F\\uDF8F-\\uDF92\\uDFE4]|\\uD82F[\\uDC9D\\uDC9E]|\\uD834[\\uDD65\\uDD67-\\uDD69\\uDD6E-\\uDD72\\uDD7B-\\uDD82\\uDD85-\\uDD8B\\uDDAA-\\uDDAD\\uDE42-\\uDE44]|\\uD836[\\uDE00-\\uDE36\\uDE3B-\\uDE6C\\uDE75\\uDE84\\uDE9B-\\uDE9F\\uDEA1-\\uDEAF]|\\uD838[\\uDC00-\\uDC06\\uDC08-\\uDC18\\uDC1B-\\uDC21\\uDC23\\uDC24\\uDC26-\\uDC2A\\uDD30-\\uDD36\\uDEEC-\\uDEEF]|\\uD83A[\\uDCD0-\\uDCD6\\uDD44-\\uDD4A]|\\uD83C[\\uDFFB-\\uDFFF]|\\uDB40[\\uDC20-\\uDC7F\\uDD00-\\uDDEF])*\\u200D$/;\n\nvar endsWithEmojiZWJ = str => {\n  return str.search(endingEmojiZWJ) !== -1;\n};\n\nvar endingRIs = /(?:\\uD83C[\\uDDE6-\\uDDFF])+$/g;\n\nvar endsWithOddNumberOfRIs = str => {\n  var match = str.match(endingRIs);\n\n  if (match === null) {\n    return false;\n  } else {\n    // A RI is represented by a surrogate pair.\n    var numRIs = match[0].length / 2;\n    return numRIs % 2 === 1;\n  }\n};\n\n/**\r\n * Shared the function with isElementType utility\r\n */\n\nvar isElement = value => {\n  return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children) && !Editor.isEditor(value);\n}; // eslint-disable-next-line no-redeclare\n\n\nvar Element = {\n  /**\r\n   * Check if a value implements the 'Ancestor' interface.\r\n   */\n  isAncestor(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Node.isNodeList(value.children);\n  },\n\n  /**\r\n   * Check if a value implements the `Element` interface.\r\n   */\n  isElement,\n\n  /**\r\n   * Check if a value is an array of `Element` objects.\r\n   */\n  isElementList(value) {\n    return Array.isArray(value) && value.every(val => Element.isElement(val));\n  },\n\n  /**\r\n   * Check if a set of props is a partial of Element.\r\n   */\n  isElementProps(props) {\n    return props.children !== undefined;\n  },\n\n  /**\r\n   * Check if a value implements the `Element` interface and has elementKey with selected value.\r\n   * Default it check to `type` key value\r\n   */\n  isElementType: function isElementType(value, elementVal) {\n    var elementKey = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'type';\n    return isElement(value) && value[elementKey] === elementVal;\n  },\n\n  /**\r\n   * Check if an element matches set of properties.\r\n   *\r\n   * Note: this checks custom properties, and it does not ensure that any\r\n   * children are equivalent.\r\n   */\n  matches(element, props) {\n    for (var key in props) {\n      if (key === 'children') {\n        continue;\n      }\n\n      if (element[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n};\n\nvar _excluded$4 = [\"text\"],\n    _excluded2$3 = [\"text\"];\n\nfunction ownKeys$8(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$8(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$8(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$8(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar IS_EDITOR_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar Editor = {\n  /**\r\n   * Get the ancestor above a location in the document.\r\n   */\n  above(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      voids = false,\n      mode = 'lowest',\n      at = editor.selection,\n      match\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var path = Editor.path(editor, at);\n    var reverse = mode === 'lowest';\n\n    for (var [n, p] of Editor.levels(editor, {\n      at: path,\n      voids,\n      match,\n      reverse\n    })) {\n      if (!Text.isText(n) && !Path.equals(path, p)) {\n        return [n, p];\n      }\n    }\n  },\n\n  /**\r\n   * Add a custom property to the leaf text nodes in the current selection.\r\n   *\r\n   * If the selection is currently collapsed, the marks will be added to the\r\n   * `editor.marks` property instead, and applied when text is inserted next.\r\n   */\n  addMark(editor, key, value) {\n    editor.addMark(key, value);\n  },\n\n  /**\r\n   * Get the point after a location.\r\n   */\n  after(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.point(editor, at, {\n      edge: 'end'\n    });\n    var focus = Editor.end(editor, []);\n    var range = {\n      anchor,\n      focus\n    };\n    var {\n      distance = 1\n    } = options;\n    var d = 0;\n    var target;\n\n    for (var p of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      at: range\n    }))) {\n      if (d > distance) {\n        break;\n      }\n\n      if (d !== 0) {\n        target = p;\n      }\n\n      d++;\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Get the point before a location.\r\n   */\n  before(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var anchor = Editor.start(editor, []);\n    var focus = Editor.point(editor, at, {\n      edge: 'start'\n    });\n    var range = {\n      anchor,\n      focus\n    };\n    var {\n      distance = 1\n    } = options;\n    var d = 0;\n    var target;\n\n    for (var p of Editor.positions(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      at: range,\n      reverse: true\n    }))) {\n      if (d > distance) {\n        break;\n      }\n\n      if (d !== 0) {\n        target = p;\n      }\n\n      d++;\n    }\n\n    return target;\n  },\n\n  /**\r\n   * Delete content in the editor backward from the current selection.\r\n   */\n  deleteBackward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteBackward(unit);\n  },\n\n  /**\r\n   * Delete content in the editor forward from the current selection.\r\n   */\n  deleteForward(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      unit = 'character'\n    } = options;\n    editor.deleteForward(unit);\n  },\n\n  /**\r\n   * Delete the content in the current selection.\r\n   */\n  deleteFragment(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      direction = 'forward'\n    } = options;\n    editor.deleteFragment(direction);\n  },\n\n  /**\r\n   * Get the start and end points of a location.\r\n   */\n  edges(editor, at) {\n    return [Editor.start(editor, at), Editor.end(editor, at)];\n  },\n\n  /**\r\n   * Get the end point of a location.\r\n   */\n  end(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'end'\n    });\n  },\n\n  /**\r\n   * Get the first node at a location.\r\n   */\n  first(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'start'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the fragment at a location.\r\n   */\n  fragment(editor, at) {\n    var range = Editor.range(editor, at);\n    var fragment = Node.fragment(editor, range);\n    return fragment;\n  },\n\n  /**\r\n   * Check if a node has block children.\r\n   */\n  hasBlocks(editor, element) {\n    return element.children.some(n => Editor.isBlock(editor, n));\n  },\n\n  /**\r\n   * Check if a node has inline and text children.\r\n   */\n  hasInlines(editor, element) {\n    return element.children.some(n => Text.isText(n) || Editor.isInline(editor, n));\n  },\n\n  /**\r\n   * Check if a node has text children.\r\n   */\n  hasTexts(editor, element) {\n    return element.children.every(n => Text.isText(n));\n  },\n\n  /**\r\n   * Insert a block break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertBreak(editor) {\n    editor.insertBreak();\n  },\n\n  /**\r\n   * Insert a soft break at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertSoftBreak(editor) {\n    editor.insertSoftBreak();\n  },\n\n  /**\r\n   * Insert a fragment at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertFragment(editor, fragment) {\n    editor.insertFragment(fragment);\n  },\n\n  /**\r\n   * Insert a node at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertNode(editor, node) {\n    editor.insertNode(node);\n  },\n\n  /**\r\n   * Insert text at the current selection.\r\n   *\r\n   * If the selection is currently expanded, it will be deleted first.\r\n   */\n  insertText(editor, text) {\n    editor.insertText(text);\n  },\n\n  /**\r\n   * Check if a value is a block `Element` object.\r\n   */\n  isBlock(editor, value) {\n    return Element.isElement(value) && !editor.isInline(value);\n  },\n\n  /**\r\n   * Check if a value is an `Editor` object.\r\n   */\n  isEditor(value) {\n    var cachedIsEditor = IS_EDITOR_CACHE.get(value);\n\n    if (cachedIsEditor !== undefined) {\n      return cachedIsEditor;\n    }\n\n    if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n      return false;\n    }\n\n    var isEditor = typeof value.addMark === 'function' && typeof value.apply === 'function' && typeof value.deleteBackward === 'function' && typeof value.deleteForward === 'function' && typeof value.deleteFragment === 'function' && typeof value.insertBreak === 'function' && typeof value.insertSoftBreak === 'function' && typeof value.insertFragment === 'function' && typeof value.insertNode === 'function' && typeof value.insertText === 'function' && typeof value.isInline === 'function' && typeof value.isVoid === 'function' && typeof value.normalizeNode === 'function' && typeof value.onChange === 'function' && typeof value.removeMark === 'function' && (value.marks === null || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.marks)) && (value.selection === null || Range.isRange(value.selection)) && Node.isNodeList(value.children) && Operation.isOperationList(value.operations);\n    IS_EDITOR_CACHE.set(value, isEditor);\n    return isEditor;\n  },\n\n  /**\r\n   * Check if a point is the end point of a location.\r\n   */\n  isEnd(editor, point, at) {\n    var end = Editor.end(editor, at);\n    return Point.equals(point, end);\n  },\n\n  /**\r\n   * Check if a point is an edge of a location.\r\n   */\n  isEdge(editor, point, at) {\n    return Editor.isStart(editor, point, at) || Editor.isEnd(editor, point, at);\n  },\n\n  /**\r\n   * Check if an element is empty, accounting for void nodes.\r\n   */\n  isEmpty(editor, element) {\n    var {\n      children\n    } = element;\n    var [first] = children;\n    return children.length === 0 || children.length === 1 && Text.isText(first) && first.text === '' && !editor.isVoid(element);\n  },\n\n  /**\r\n   * Check if a value is an inline `Element` object.\r\n   */\n  isInline(editor, value) {\n    return Element.isElement(value) && editor.isInline(value);\n  },\n\n  /**\r\n   * Check if the editor is currently normalizing after each operation.\r\n   */\n  isNormalizing(editor) {\n    var isNormalizing = NORMALIZING.get(editor);\n    return isNormalizing === undefined ? true : isNormalizing;\n  },\n\n  /**\r\n   * Check if a point is the start point of a location.\r\n   */\n  isStart(editor, point, at) {\n    // PERF: If the offset isn't `0` we know it's not the start.\n    if (point.offset !== 0) {\n      return false;\n    }\n\n    var start = Editor.start(editor, at);\n    return Point.equals(point, start);\n  },\n\n  /**\r\n   * Check if a value is a void `Element` object.\r\n   */\n  isVoid(editor, value) {\n    return Element.isElement(value) && editor.isVoid(value);\n  },\n\n  /**\r\n   * Get the last node at a location.\r\n   */\n  last(editor, at) {\n    var path = Editor.path(editor, at, {\n      edge: 'end'\n    });\n    return Editor.node(editor, path);\n  },\n\n  /**\r\n   * Get the leaf text node at a location.\r\n   */\n  leaf(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.leaf(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the levels at a location.\r\n   */\n  *levels(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n\n    if (match == null) {\n      match = () => true;\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var levels = [];\n    var path = Editor.path(editor, at);\n\n    for (var [n, p] of Node.levels(editor, path)) {\n      if (!match(n, p)) {\n        continue;\n      }\n\n      levels.push([n, p]);\n\n      if (!voids && Editor.isVoid(editor, n)) {\n        break;\n      }\n    }\n\n    if (reverse) {\n      levels.reverse();\n    }\n\n    yield* levels;\n  },\n\n  /**\r\n   * Get the marks that would be added to text at the current selection.\r\n   */\n  marks(editor) {\n    var {\n      marks,\n      selection\n    } = editor;\n\n    if (!selection) {\n      return null;\n    }\n\n    if (marks) {\n      return marks;\n    }\n\n    if (Range.isExpanded(selection)) {\n      var [match] = Editor.nodes(editor, {\n        match: Text.isText\n      });\n\n      if (match) {\n        var [_node] = match;\n\n        var _rest = _objectWithoutProperties(_node, _excluded$4);\n\n        return _rest;\n      } else {\n        return {};\n      }\n    }\n\n    var {\n      anchor\n    } = selection;\n    var {\n      path\n    } = anchor;\n    var [node] = Editor.leaf(editor, path);\n\n    if (anchor.offset === 0) {\n      var prev = Editor.previous(editor, {\n        at: path,\n        match: Text.isText\n      });\n      var block = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n)\n      });\n\n      if (prev && block) {\n        var [prevNode, prevPath] = prev;\n        var [, blockPath] = block;\n\n        if (Path.isAncestor(blockPath, prevPath)) {\n          node = prevNode;\n        }\n      }\n    }\n\n    var rest = _objectWithoutProperties(node, _excluded2$3);\n\n    return rest;\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document after a location.\r\n   */\n  next(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var pointAfterLocation = Editor.after(editor, at, {\n      voids\n    });\n    if (!pointAfterLocation) return;\n    var [, to] = Editor.last(editor, []);\n    var span = [pointAfterLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the next node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n\n        match = n => parent.children.includes(n);\n      } else {\n        match = () => true;\n      }\n    }\n\n    var [next] = Editor.nodes(editor, {\n      at: span,\n      match,\n      mode,\n      voids\n    });\n    return next;\n  },\n\n  /**\r\n   * Get the node at a location.\r\n   */\n  node(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var node = Node.get(editor, path);\n    return [node, path];\n  },\n\n  /**\r\n   * Iterate through all of the nodes in the Editor.\r\n   */\n  *nodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      mode = 'all',\n      universal = false,\n      reverse = false,\n      voids = false\n    } = options;\n    var {\n      match\n    } = options;\n\n    if (!match) {\n      match = () => true;\n    }\n\n    if (!at) {\n      return;\n    }\n\n    var from;\n    var to;\n\n    if (Span.isSpan(at)) {\n      from = at[0];\n      to = at[1];\n    } else {\n      var first = Editor.path(editor, at, {\n        edge: 'start'\n      });\n      var last = Editor.path(editor, at, {\n        edge: 'end'\n      });\n      from = reverse ? last : first;\n      to = reverse ? first : last;\n    }\n\n    var nodeEntries = Node.nodes(editor, {\n      reverse,\n      from,\n      to,\n      pass: _ref => {\n        var [n] = _ref;\n        return voids ? false : Editor.isVoid(editor, n);\n      }\n    });\n    var matches = [];\n    var hit;\n\n    for (var [node, path] of nodeEntries) {\n      var isLower = hit && Path.compare(path, hit[1]) === 0; // In highest mode any node lower than the last hit is not a match.\n\n      if (mode === 'highest' && isLower) {\n        continue;\n      }\n\n      if (!match(node, path)) {\n        // If we've arrived at a leaf text node that is not lower than the last\n        // hit, then we've found a branch that doesn't include a match, which\n        // means the match is not universal.\n        if (universal && !isLower && Text.isText(node)) {\n          return;\n        } else {\n          continue;\n        }\n      } // If there's a match and it's lower than the last, update the hit.\n\n\n      if (mode === 'lowest' && isLower) {\n        hit = [node, path];\n        continue;\n      } // In lowest mode we emit the last hit, once it's guaranteed lowest.\n\n\n      var emit = mode === 'lowest' ? hit : [node, path];\n\n      if (emit) {\n        if (universal) {\n          matches.push(emit);\n        } else {\n          yield emit;\n        }\n      }\n\n      hit = [node, path];\n    } // Since lowest is always emitting one behind, catch up at the end.\n\n\n    if (mode === 'lowest' && hit) {\n      if (universal) {\n        matches.push(hit);\n      } else {\n        yield hit;\n      }\n    } // Universal defers to ensure that the match occurs in every branch, so we\n    // yield all of the matches after iterating.\n\n\n    if (universal) {\n      yield* matches;\n    }\n  },\n\n  /**\r\n   * Normalize any dirty objects in the editor.\r\n   */\n  normalize(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      force = false\n    } = options;\n\n    var getDirtyPaths = editor => {\n      return DIRTY_PATHS.get(editor) || [];\n    };\n\n    var getDirtyPathKeys = editor => {\n      return DIRTY_PATH_KEYS.get(editor) || new Set();\n    };\n\n    var popDirtyPath = editor => {\n      var path = getDirtyPaths(editor).pop();\n      var key = path.join(',');\n      getDirtyPathKeys(editor).delete(key);\n      return path;\n    };\n\n    if (!Editor.isNormalizing(editor)) {\n      return;\n    }\n\n    if (force) {\n      var allPaths = Array.from(Node.nodes(editor), _ref2 => {\n        var [, p] = _ref2;\n        return p;\n      });\n      var allPathKeys = new Set(allPaths.map(p => p.join(',')));\n      DIRTY_PATHS.set(editor, allPaths);\n      DIRTY_PATH_KEYS.set(editor, allPathKeys);\n    }\n\n    if (getDirtyPaths(editor).length === 0) {\n      return;\n    }\n\n    Editor.withoutNormalizing(editor, () => {\n      /*\r\n        Fix dirty elements with no children.\r\n        editor.normalizeNode() does fix this, but some normalization fixes also require it to work.\r\n        Running an initial pass avoids the catch-22 race condition.\r\n      */\n      for (var dirtyPath of getDirtyPaths(editor)) {\n        if (Node.has(editor, dirtyPath)) {\n          var entry = Editor.node(editor, dirtyPath);\n          var [node, _] = entry;\n          /*\r\n            The default normalizer inserts an empty text node in this scenario, but it can be customised.\r\n            So there is some risk here.\r\n                       As long as the normalizer only inserts child nodes for this case it is safe to do in any order;\r\n            by definition adding children to an empty node can't cause other paths to change.\r\n          */\n\n          if (Element.isElement(node) && node.children.length === 0) {\n            editor.normalizeNode(entry);\n          }\n        }\n      }\n\n      var max = getDirtyPaths(editor).length * 42; // HACK: better way?\n\n      var m = 0;\n\n      while (getDirtyPaths(editor).length !== 0) {\n        if (m > max) {\n          throw new Error(\"\\n            Could not completely normalize the editor after \".concat(max, \" iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state.\\n          \"));\n        }\n\n        var _dirtyPath = popDirtyPath(editor); // If the node doesn't exist in the tree, it does not need to be normalized.\n\n\n        if (Node.has(editor, _dirtyPath)) {\n          var _entry = Editor.node(editor, _dirtyPath);\n\n          editor.normalizeNode(_entry);\n        }\n\n        m++;\n      }\n    });\n  },\n\n  /**\r\n   * Get the parent node of a location.\r\n   */\n  parent(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var path = Editor.path(editor, at, options);\n    var parentPath = Path.parent(path);\n    var entry = Editor.node(editor, parentPath);\n    return entry;\n  },\n\n  /**\r\n   * Get the path of a location.\r\n   */\n  path(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      depth,\n      edge\n    } = options;\n\n    if (Path.isPath(at)) {\n      if (edge === 'start') {\n        var [, firstPath] = Node.first(editor, at);\n        at = firstPath;\n      } else if (edge === 'end') {\n        var [, lastPath] = Node.last(editor, at);\n        at = lastPath;\n      }\n    }\n\n    if (Range.isRange(at)) {\n      if (edge === 'start') {\n        at = Range.start(at);\n      } else if (edge === 'end') {\n        at = Range.end(at);\n      } else {\n        at = Path.common(at.anchor.path, at.focus.path);\n      }\n    }\n\n    if (Point.isPoint(at)) {\n      at = at.path;\n    }\n\n    if (depth != null) {\n      at = at.slice(0, depth);\n    }\n\n    return at;\n  },\n\n  hasPath(editor, path) {\n    return Node.has(editor, path);\n  },\n\n  /**\r\n   * Create a mutable ref for a `Path` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pathRef(editor, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: path,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var pathRefs = Editor.pathRefs(editor);\n        pathRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.pathRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked path refs of the editor.\r\n   */\n  pathRefs(editor) {\n    var refs = PATH_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      PATH_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Get the start or end point of a location.\r\n   */\n  point(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      edge = 'start'\n    } = options;\n\n    if (Path.isPath(at)) {\n      var path;\n\n      if (edge === 'end') {\n        var [, lastPath] = Node.last(editor, at);\n        path = lastPath;\n      } else {\n        var [, firstPath] = Node.first(editor, at);\n        path = firstPath;\n      }\n\n      var node = Node.get(editor, path);\n\n      if (!Text.isText(node)) {\n        throw new Error(\"Cannot get the \".concat(edge, \" point in the node at path [\").concat(at, \"] because it has no \").concat(edge, \" text node.\"));\n      }\n\n      return {\n        path,\n        offset: edge === 'end' ? node.text.length : 0\n      };\n    }\n\n    if (Range.isRange(at)) {\n      var [start, end] = Range.edges(at);\n      return edge === 'start' ? start : end;\n    }\n\n    return at;\n  },\n\n  /**\r\n   * Create a mutable ref for a `Point` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  pointRef(editor, point) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: point,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var pointRefs = Editor.pointRefs(editor);\n        pointRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.pointRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked point refs of the editor.\r\n   */\n  pointRefs(editor) {\n    var refs = POINT_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      POINT_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Return all the positions in `at` range where a `Point` can be placed.\r\n   *\r\n   * By default, moves forward by individual offsets at a time, but\r\n   * the `unit` option can be used to to move by character, word, line, or block.\r\n   *\r\n   * The `reverse` option can be used to change iteration direction.\r\n   *\r\n   * Note: By default void nodes are treated as a single point and iteration\r\n   * will not happen inside their content unless you pass in true for the\r\n   * `voids` option, then iteration will occur.\r\n   */\n  *positions(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      at = editor.selection,\n      unit = 'offset',\n      reverse = false,\n      voids = false\n    } = options;\n\n    if (!at) {\n      return;\n    }\n    /**\r\n     * Algorithm notes:\r\n     *\r\n     * Each step `distance` is dynamic depending on the underlying text\r\n     * and the `unit` specified.  Each step, e.g., a line or word, may\r\n     * span multiple text nodes, so we iterate through the text both on\r\n     * two levels in step-sync:\r\n     *\r\n     * `leafText` stores the text on a text leaf level, and is advanced\r\n     * through using the counters `leafTextOffset` and `leafTextRemaining`.\r\n     *\r\n     * `blockText` stores the text on a block level, and is shortened\r\n     * by `distance` every time it is advanced.\r\n     *\r\n     * We only maintain a window of one blockText and one leafText because\r\n     * a block node always appears before all of its leaf nodes.\r\n     */\n\n\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var first = reverse ? end : start;\n    var isNewBlock = false;\n    var blockText = '';\n    var distance = 0; // Distance for leafText to catch up to blockText.\n\n    var leafTextRemaining = 0;\n    var leafTextOffset = 0; // Iterate through all nodes in range, grabbing entire textual content\n    // of block nodes in blockText, and text nodes in leafText.\n    // Exploits the fact that nodes are sequenced in such a way that we first\n    // encounter the block node, then all of its text nodes, so when iterating\n    // through the blockText and leafText we just need to remember a window of\n    // one block node and leaf node, respectively.\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at,\n      reverse,\n      voids\n    })) {\n      /*\r\n       * ELEMENT NODE - Yield position(s) for voids, collect blockText for blocks\r\n       */\n      if (Element.isElement(node)) {\n        // Void nodes are a special case, so by default we will always\n        // yield their first point. If the `voids` option is set to true,\n        // then we will iterate over their content.\n        if (!voids && editor.isVoid(node)) {\n          yield Editor.start(editor, path);\n          continue;\n        } // Inline element nodes are ignored as they don't themselves\n        // contribute to `blockText` or `leafText` - their parent and\n        // children do.\n\n\n        if (editor.isInline(node)) continue; // Block element node - set `blockText` to its text content.\n\n        if (Editor.hasInlines(editor, node)) {\n          // We always exhaust block nodes before encountering a new one:\n          //   console.assert(blockText === '',\n          //     `blockText='${blockText}' - `+\n          //     `not exhausted before new block node`, path)\n          // Ensure range considered is capped to `range`, in the\n          // start/end edge cases where block extends beyond range.\n          // Equivalent to this, but presumably more performant:\n          //   blockRange = Editor.range(editor, ...Editor.edges(editor, path))\n          //   blockRange = Range.intersection(range, blockRange) // intersect\n          //   blockText = Editor.string(editor, blockRange, { voids })\n          var e = Path.isAncestor(path, end.path) ? end : Editor.end(editor, path);\n          var s = Path.isAncestor(path, start.path) ? start : Editor.start(editor, path);\n          blockText = Editor.string(editor, {\n            anchor: s,\n            focus: e\n          }, {\n            voids\n          });\n          isNewBlock = true;\n        }\n      }\n      /*\r\n       * TEXT LEAF NODE - Iterate through text content, yielding\r\n       * positions every `distance` offset according to `unit`.\r\n       */\n\n\n      if (Text.isText(node)) {\n        var isFirst = Path.equals(path, first.path); // Proof that we always exhaust text nodes before encountering a new one:\n        //   console.assert(leafTextRemaining <= 0,\n        //     `leafTextRemaining=${leafTextRemaining} - `+\n        //     `not exhausted before new leaf text node`, path)\n        // Reset `leafText` counters for new text node.\n\n        if (isFirst) {\n          leafTextRemaining = reverse ? first.offset : node.text.length - first.offset;\n          leafTextOffset = first.offset; // Works for reverse too.\n        } else {\n          leafTextRemaining = node.text.length;\n          leafTextOffset = reverse ? leafTextRemaining : 0;\n        } // Yield position at the start of node (potentially).\n\n\n        if (isFirst || isNewBlock || unit === 'offset') {\n          yield {\n            path,\n            offset: leafTextOffset\n          };\n          isNewBlock = false;\n        } // Yield positions every (dynamically calculated) `distance` offset.\n\n\n        while (true) {\n          // If `leafText` has caught up with `blockText` (distance=0),\n          // and if blockText is exhausted, break to get another block node,\n          // otherwise advance blockText forward by the new `distance`.\n          if (distance === 0) {\n            if (blockText === '') break;\n            distance = calcDistance(blockText, unit, reverse); // Split the string at the previously found distance and use the\n            // remaining string for the next iteration.\n\n            blockText = splitByCharacterDistance(blockText, distance, reverse)[1];\n          } // Advance `leafText` by the current `distance`.\n\n\n          leafTextOffset = reverse ? leafTextOffset - distance : leafTextOffset + distance;\n          leafTextRemaining = leafTextRemaining - distance; // If `leafText` is exhausted, break to get a new leaf node\n          // and set distance to the overflow amount, so we'll (maybe)\n          // catch up to blockText in the next leaf text node.\n\n          if (leafTextRemaining < 0) {\n            distance = -leafTextRemaining;\n            break;\n          } // Successfully walked `distance` offsets through `leafText`\n          // to catch up with `blockText`, so we can reset `distance`\n          // and yield this position in this node.\n\n\n          distance = 0;\n          yield {\n            path,\n            offset: leafTextOffset\n          };\n        }\n      }\n    } // Proof that upon completion, we've exahusted both leaf and block text:\n    //   console.assert(leafTextRemaining <= 0, \"leafText wasn't exhausted\")\n    //   console.assert(blockText === '', \"blockText wasn't exhausted\")\n    // Helper:\n    // Return the distance in offsets for a step of size `unit` on given string.\n\n\n    function calcDistance(text, unit, reverse) {\n      if (unit === 'character') {\n        return getCharacterDistance(text, reverse);\n      } else if (unit === 'word') {\n        return getWordDistance(text, reverse);\n      } else if (unit === 'line' || unit === 'block') {\n        return text.length;\n      }\n\n      return 1;\n    }\n  },\n\n  /**\r\n   * Get the matching node in the branch of the document before a location.\r\n   */\n  previous(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      mode = 'lowest',\n      voids = false\n    } = options;\n    var {\n      match,\n      at = editor.selection\n    } = options;\n\n    if (!at) {\n      return;\n    }\n\n    var pointBeforeLocation = Editor.before(editor, at, {\n      voids\n    });\n\n    if (!pointBeforeLocation) {\n      return;\n    }\n\n    var [, to] = Editor.first(editor, []); // The search location is from the start of the document to the path of\n    // the point before the location passed in\n\n    var span = [pointBeforeLocation.path, to];\n\n    if (Path.isPath(at) && at.length === 0) {\n      throw new Error(\"Cannot get the previous node from the root node!\");\n    }\n\n    if (match == null) {\n      if (Path.isPath(at)) {\n        var [parent] = Editor.parent(editor, at);\n\n        match = n => parent.children.includes(n);\n      } else {\n        match = () => true;\n      }\n    }\n\n    var [previous] = Editor.nodes(editor, {\n      reverse: true,\n      at: span,\n      match,\n      mode,\n      voids\n    });\n    return previous;\n  },\n\n  /**\r\n   * Get a range of a location.\r\n   */\n  range(editor, at, to) {\n    if (Range.isRange(at) && !to) {\n      return at;\n    }\n\n    var start = Editor.start(editor, at);\n    var end = Editor.end(editor, to || at);\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Create a mutable ref for a `Range` object, which will stay in sync as new\r\n   * operations are applied to the editor.\r\n   */\n  rangeRef(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      affinity = 'forward'\n    } = options;\n    var ref = {\n      current: range,\n      affinity,\n\n      unref() {\n        var {\n          current\n        } = ref;\n        var rangeRefs = Editor.rangeRefs(editor);\n        rangeRefs.delete(ref);\n        ref.current = null;\n        return current;\n      }\n\n    };\n    var refs = Editor.rangeRefs(editor);\n    refs.add(ref);\n    return ref;\n  },\n\n  /**\r\n   * Get the set of currently tracked range refs of the editor.\r\n   */\n  rangeRefs(editor) {\n    var refs = RANGE_REFS.get(editor);\n\n    if (!refs) {\n      refs = new Set();\n      RANGE_REFS.set(editor, refs);\n    }\n\n    return refs;\n  },\n\n  /**\r\n   * Remove a custom property from all of the leaf text nodes in the current\r\n   * selection.\r\n   *\r\n   * If the selection is currently collapsed, the removal will be stored on\r\n   * `editor.marks` and applied to the text inserted next.\r\n   */\n  removeMark(editor, key) {\n    editor.removeMark(key);\n  },\n\n  /**\r\n   * Manually set if the editor should currently be normalizing.\r\n   *\r\n   * Note: Using this incorrectly can leave the editor in an invalid state.\r\n   *\r\n   */\n  setNormalizing(editor, isNormalizing) {\n    NORMALIZING.set(editor, isNormalizing);\n  },\n\n  /**\r\n   * Get the start point of a location.\r\n   */\n  start(editor, at) {\n    return Editor.point(editor, at, {\n      edge: 'start'\n    });\n  },\n\n  /**\r\n   * Get the text string content of a location.\r\n   *\r\n   * Note: by default the text of void nodes is considered to be an empty\r\n   * string, regardless of content, unless you pass in true for the voids option\r\n   */\n  string(editor, at) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      voids = false\n    } = options;\n    var range = Editor.range(editor, at);\n    var [start, end] = Range.edges(range);\n    var text = '';\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at: range,\n      match: Text.isText,\n      voids\n    })) {\n      var t = node.text;\n\n      if (Path.equals(path, end.path)) {\n        t = t.slice(0, end.offset);\n      }\n\n      if (Path.equals(path, start.path)) {\n        t = t.slice(start.offset);\n      }\n\n      text += t;\n    }\n\n    return text;\n  },\n\n  /**\r\n   * Convert a range into a non-hanging one.\r\n   */\n  unhangRange(editor, range) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      voids = false\n    } = options;\n    var [start, end] = Range.edges(range); // PERF: exit early if we can guarantee that the range isn't hanging.\n\n    if (start.offset !== 0 || end.offset !== 0 || Range.isCollapsed(range)) {\n      return range;\n    }\n\n    var endBlock = Editor.above(editor, {\n      at: end,\n      match: n => Editor.isBlock(editor, n)\n    });\n    var blockPath = endBlock ? endBlock[1] : [];\n    var first = Editor.start(editor, start);\n    var before = {\n      anchor: first,\n      focus: end\n    };\n    var skip = true;\n\n    for (var [node, path] of Editor.nodes(editor, {\n      at: before,\n      match: Text.isText,\n      reverse: true,\n      voids\n    })) {\n      if (skip) {\n        skip = false;\n        continue;\n      }\n\n      if (node.text !== '' || Path.isBefore(path, blockPath)) {\n        end = {\n          path,\n          offset: node.text.length\n        };\n        break;\n      }\n    }\n\n    return {\n      anchor: start,\n      focus: end\n    };\n  },\n\n  /**\r\n   * Match a void node in the current branch of the editor.\r\n   */\n  void(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return Editor.above(editor, _objectSpread$8(_objectSpread$8({}, options), {}, {\n      match: n => Editor.isVoid(editor, n)\n    }));\n  },\n\n  /**\r\n   * Call a function, deferring normalization until after it completes.\r\n   */\n  withoutNormalizing(editor, fn) {\n    var value = Editor.isNormalizing(editor);\n    Editor.setNormalizing(editor, false);\n\n    try {\n      fn();\n    } finally {\n      Editor.setNormalizing(editor, value);\n    }\n\n    Editor.normalize(editor);\n  }\n\n};\n\nvar Location = {\n  /**\r\n   * Check if a value implements the `Location` interface.\r\n   */\n  isLocation(value) {\n    return Path.isPath(value) || Point.isPoint(value) || Range.isRange(value);\n  }\n\n}; // eslint-disable-next-line no-redeclare\n\nvar Span = {\n  /**\r\n   * Check if a value implements the `Span` interface.\r\n   */\n  isSpan(value) {\n    return Array.isArray(value) && value.length === 2 && value.every(Path.isPath);\n  }\n\n};\n\nvar _excluded$3 = [\"children\"],\n    _excluded2$2 = [\"text\"];\nvar IS_NODE_LIST_CACHE = new WeakMap(); // eslint-disable-next-line no-redeclare\n\nvar Node = {\n  /**\r\n   * Get the node at a specific path, asserting that it's an ancestor node.\r\n   */\n  ancestor(root, path) {\n    var node = Node.get(root, path);\n\n    if (Text.isText(node)) {\n      throw new Error(\"Cannot get the ancestor node at path [\".concat(path, \"] because it refers to a text node instead: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the ancestor nodes above a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest ancestor in\r\n   * the tree, but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  *ancestors(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (var p of Path.ancestors(path, options)) {\n      var n = Node.ancestor(root, p);\n      var entry = [n, p];\n      yield entry;\n    }\n  },\n\n  /**\r\n   * Get the child of a node at a specific index.\r\n   */\n  child(root, index) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get the child of a text node: \".concat(Scrubber.stringify(root)));\n    }\n\n    var c = root.children[index];\n\n    if (c == null) {\n      throw new Error(\"Cannot get child at index `\".concat(index, \"` in node: \").concat(Scrubber.stringify(root)));\n    }\n\n    return c;\n  },\n\n  /**\r\n   * Iterate over the children of a node at a specific path.\r\n   */\n  *children(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      reverse = false\n    } = options;\n    var ancestor = Node.ancestor(root, path);\n    var {\n      children\n    } = ancestor;\n    var index = reverse ? children.length - 1 : 0;\n\n    while (reverse ? index >= 0 : index < children.length) {\n      var child = Node.child(ancestor, index);\n      var childPath = path.concat(index);\n      yield [child, childPath];\n      index = reverse ? index - 1 : index + 1;\n    }\n  },\n\n  /**\r\n   * Get an entry for the common ancesetor node of two paths.\r\n   */\n  common(root, path, another) {\n    var p = Path.common(path, another);\n    var n = Node.get(root, p);\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, asserting that it's a descendant node.\r\n   */\n  descendant(root, path) {\n    var node = Node.get(root, path);\n\n    if (Editor.isEditor(node)) {\n      throw new Error(\"Cannot get the descendant node at path [\".concat(path, \"] because it refers to the root editor node instead: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of all the descendant node entries inside a root node.\r\n   */\n  *descendants(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (path.length !== 0) {\n        // NOTE: we have to coerce here because checking the path's length does\n        // guarantee that `node` is not a `Editor`, but TypeScript doesn't know.\n        yield [node, path];\n      }\n    }\n  },\n\n  /**\r\n   * Return a generator of all the element nodes inside a root node. Each iteration\r\n   * will return an `ElementEntry` tuple consisting of `[Element, Path]`. If the\r\n   * root node is an element it will be included in the iteration as well.\r\n   */\n  *elements(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (Element.isElement(node)) {\n        yield [node, path];\n      }\n    }\n  },\n\n  /**\r\n   * Extract props from a Node.\r\n   */\n  extractProps(node) {\n    if (Element.isAncestor(node)) {\n      var properties = _objectWithoutProperties(node, _excluded$3);\n\n      return properties;\n    } else {\n      var properties = _objectWithoutProperties(node, _excluded2$2);\n\n      return properties;\n    }\n  },\n\n  /**\r\n   * Get the first node entry in a root node from a path.\r\n   */\n  first(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        n = n.children[0];\n        p.push(0);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the sliced fragment represented by a range inside a root node.\r\n   */\n  fragment(root, range) {\n    if (Text.isText(root)) {\n      throw new Error(\"Cannot get a fragment starting from a root text node: \".concat(Scrubber.stringify(root)));\n    }\n\n    var newRoot = (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)({\n      children: root.children\n    }, r => {\n      var [start, end] = Range.edges(range);\n      var nodeEntries = Node.nodes(r, {\n        reverse: true,\n        pass: _ref => {\n          var [, path] = _ref;\n          return !Range.includes(range, path);\n        }\n      });\n\n      for (var [, path] of nodeEntries) {\n        if (!Range.includes(range, path)) {\n          var parent = Node.parent(r, path);\n          var index = path[path.length - 1];\n          parent.children.splice(index, 1);\n        }\n\n        if (Path.equals(path, end.path)) {\n          var leaf = Node.leaf(r, path);\n          leaf.text = leaf.text.slice(0, end.offset);\n        }\n\n        if (Path.equals(path, start.path)) {\n          var _leaf = Node.leaf(r, path);\n\n          _leaf.text = _leaf.text.slice(start.offset);\n        }\n      }\n\n      if (Editor.isEditor(r)) {\n        r.selection = null;\n      }\n    });\n    return newRoot.children;\n  },\n\n  /**\r\n   * Get the descendant node referred to by a specific path. If the path is an\r\n   * empty array, it refers to the root node itself.\r\n   */\n  get(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        throw new Error(\"Cannot find a descendant at path [\".concat(path, \"] in node: \").concat(Scrubber.stringify(root)));\n      }\n\n      node = node.children[p];\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Check if a descendant node exists at a specific path.\r\n   */\n  has(root, path) {\n    var node = root;\n\n    for (var i = 0; i < path.length; i++) {\n      var p = path[i];\n\n      if (Text.isText(node) || !node.children[p]) {\n        return false;\n      }\n\n      node = node.children[p];\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Check if a value implements the `Node` interface.\r\n   */\n  isNode(value) {\n    return Text.isText(value) || Element.isElement(value) || Editor.isEditor(value);\n  },\n\n  /**\r\n   * Check if a value is a list of `Node` objects.\r\n   */\n  isNodeList(value) {\n    if (!Array.isArray(value)) {\n      return false;\n    }\n\n    var cachedResult = IS_NODE_LIST_CACHE.get(value);\n\n    if (cachedResult !== undefined) {\n      return cachedResult;\n    }\n\n    var isNodeList = value.every(val => Node.isNode(val));\n    IS_NODE_LIST_CACHE.set(value, isNodeList);\n    return isNodeList;\n  },\n\n  /**\r\n   * Get the last node entry in a root node from a path.\r\n   */\n  last(root, path) {\n    var p = path.slice();\n    var n = Node.get(root, p);\n\n    while (n) {\n      if (Text.isText(n) || n.children.length === 0) {\n        break;\n      } else {\n        var i = n.children.length - 1;\n        n = n.children[i];\n        p.push(i);\n      }\n    }\n\n    return [n, p];\n  },\n\n  /**\r\n   * Get the node at a specific path, ensuring it's a leaf text node.\r\n   */\n  leaf(root, path) {\n    var node = Node.get(root, path);\n\n    if (!Text.isText(node)) {\n      throw new Error(\"Cannot get the leaf node at path [\".concat(path, \"] because it refers to a non-leaf node: \").concat(Scrubber.stringify(node)));\n    }\n\n    return node;\n  },\n\n  /**\r\n   * Return a generator of the in a branch of the tree, from a specific path.\r\n   *\r\n   * By default the order is top-down, from highest to lowest node in the tree,\r\n   * but you can pass the `reverse: true` option to go bottom-up.\r\n   */\n  *levels(root, path) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    for (var p of Path.levels(path, options)) {\n      var n = Node.get(root, p);\n      yield [n, p];\n    }\n  },\n\n  /**\r\n   * Check if a node matches a set of props.\r\n   */\n  matches(node, props) {\n    return Element.isElement(node) && Element.isElementProps(props) && Element.matches(node, props) || Text.isText(node) && Text.isTextProps(props) && Text.matches(node, props);\n  },\n\n  /**\r\n   * Return a generator of all the node entries of a root node. Each entry is\r\n   * returned as a `[Node, Path]` tuple, with the path referring to the node's\r\n   * position inside the root node.\r\n   */\n  *nodes(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      pass,\n      reverse = false\n    } = options;\n    var {\n      from = [],\n      to\n    } = options;\n    var visited = new Set();\n    var p = [];\n    var n = root;\n\n    while (true) {\n      if (to && (reverse ? Path.isBefore(p, to) : Path.isAfter(p, to))) {\n        break;\n      }\n\n      if (!visited.has(n)) {\n        yield [n, p];\n      } // If we're allowed to go downward and we haven't descended yet, do.\n\n\n      if (!visited.has(n) && !Text.isText(n) && n.children.length !== 0 && (pass == null || pass([n, p]) === false)) {\n        visited.add(n);\n        var nextIndex = reverse ? n.children.length - 1 : 0;\n\n        if (Path.isAncestor(p, from)) {\n          nextIndex = from[p.length];\n        }\n\n        p = p.concat(nextIndex);\n        n = Node.get(root, p);\n        continue;\n      } // If we're at the root and we can't go down, we're done.\n\n\n      if (p.length === 0) {\n        break;\n      } // If we're going forward...\n\n\n      if (!reverse) {\n        var newPath = Path.next(p);\n\n        if (Node.has(root, newPath)) {\n          p = newPath;\n          n = Node.get(root, p);\n          continue;\n        }\n      } // If we're going backward...\n\n\n      if (reverse && p[p.length - 1] !== 0) {\n        var _newPath = Path.previous(p);\n\n        p = _newPath;\n        n = Node.get(root, p);\n        continue;\n      } // Otherwise we're going upward...\n\n\n      p = Path.parent(p);\n      n = Node.get(root, p);\n      visited.add(n);\n    }\n  },\n\n  /**\r\n   * Get the parent of a node at a specific path.\r\n   */\n  parent(root, path) {\n    var parentPath = Path.parent(path);\n    var p = Node.get(root, parentPath);\n\n    if (Text.isText(p)) {\n      throw new Error(\"Cannot get the parent of path [\".concat(path, \"] because it does not exist in the root.\"));\n    }\n\n    return p;\n  },\n\n  /**\r\n   * Get the concatenated text string of a node's content.\r\n   *\r\n   * Note that this will not include spaces or line breaks between block nodes.\r\n   * It is not a user-facing string, but a string for performing offset-related\r\n   * computations for a node.\r\n   */\n  string(node) {\n    if (Text.isText(node)) {\n      return node.text;\n    } else {\n      return node.children.map(Node.string).join('');\n    }\n  },\n\n  /**\r\n   * Return a generator of all leaf text nodes in a root node.\r\n   */\n  *texts(root) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    for (var [node, path] of Node.nodes(root, options)) {\n      if (Text.isText(node)) {\n        yield [node, path];\n      }\n    }\n  }\n\n};\n\nfunction ownKeys$7(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$7(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$7(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$7(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Operation = {\n  /**\r\n   * Check of a value is a `NodeOperation` object.\r\n   */\n  isNodeOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_node');\n  },\n\n  /**\r\n   * Check of a value is an `Operation` object.\r\n   */\n  isOperation(value) {\n    if (!(0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value)) {\n      return false;\n    }\n\n    switch (value.type) {\n      case 'insert_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'insert_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'merge_node':\n        return typeof value.position === 'number' && Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n\n      case 'move_node':\n        return Path.isPath(value.path) && Path.isPath(value.newPath);\n\n      case 'remove_node':\n        return Path.isPath(value.path) && Node.isNode(value.node);\n\n      case 'remove_text':\n        return typeof value.offset === 'number' && typeof value.text === 'string' && Path.isPath(value.path);\n\n      case 'set_node':\n        return Path.isPath(value.path) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n\n      case 'set_selection':\n        return value.properties === null && Range.isRange(value.newProperties) || value.newProperties === null && Range.isRange(value.properties) || (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.newProperties);\n\n      case 'split_node':\n        return Path.isPath(value.path) && typeof value.position === 'number' && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value.properties);\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Check if a value is a list of `Operation` objects.\r\n   */\n  isOperationList(value) {\n    return Array.isArray(value) && value.every(val => Operation.isOperation(val));\n  },\n\n  /**\r\n   * Check of a value is a `SelectionOperation` object.\r\n   */\n  isSelectionOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_selection');\n  },\n\n  /**\r\n   * Check of a value is a `TextOperation` object.\r\n   */\n  isTextOperation(value) {\n    return Operation.isOperation(value) && value.type.endsWith('_text');\n  },\n\n  /**\r\n   * Invert an operation, returning a new operation that will exactly undo the\r\n   * original when applied.\r\n   */\n  inverse(op) {\n    switch (op.type) {\n      case 'insert_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'remove_node'\n          });\n        }\n\n      case 'insert_text':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'remove_text'\n          });\n        }\n\n      case 'merge_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'split_node',\n            path: Path.previous(op.path)\n          });\n        }\n\n      case 'move_node':\n        {\n          var {\n            newPath,\n            path\n          } = op; // PERF: in this case the move operation is a no-op anyways.\n\n          if (Path.equals(newPath, path)) {\n            return op;\n          } // If the move happens completely within a single parent the path and\n          // newPath are stable with respect to each other.\n\n\n          if (Path.isSibling(path, newPath)) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              path: newPath,\n              newPath: path\n            });\n          } // If the move does not happen within a single parent it is possible\n          // for the move to impact the true path to the location where the node\n          // was removed from and where it was inserted. We have to adjust for this\n          // and find the original path. We can accomplish this (only in non-sibling)\n          // moves by looking at the impact of the move operation on the node\n          // after the original move path.\n\n\n          var inversePath = Path.transform(path, op);\n          var inverseNewPath = Path.transform(Path.next(path), op);\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            path: inversePath,\n            newPath: inverseNewPath\n          });\n        }\n\n      case 'remove_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'insert_node'\n          });\n        }\n\n      case 'remove_text':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'insert_text'\n          });\n        }\n\n      case 'set_node':\n        {\n          var {\n            properties,\n            newProperties\n          } = op;\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            properties: newProperties,\n            newProperties: properties\n          });\n        }\n\n      case 'set_selection':\n        {\n          var {\n            properties: _properties,\n            newProperties: _newProperties\n          } = op;\n\n          if (_properties == null) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: _newProperties,\n              newProperties: null\n            });\n          } else if (_newProperties == null) {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: null,\n              newProperties: _properties\n            });\n          } else {\n            return _objectSpread$7(_objectSpread$7({}, op), {}, {\n              properties: _newProperties,\n              newProperties: _properties\n            });\n          }\n        }\n\n      case 'split_node':\n        {\n          return _objectSpread$7(_objectSpread$7({}, op), {}, {\n            type: 'merge_node',\n            path: Path.next(op.path)\n          });\n        }\n    }\n  }\n\n};\n\nvar Path = {\n  /**\r\n   * Get a list of ancestor paths for a given path.\r\n   *\r\n   * The paths are sorted from shallowest to deepest ancestor. However, if the\r\n   * `reverse: true` option is passed, they are reversed.\r\n   */\n  ancestors(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var paths = Path.levels(path, options);\n\n    if (reverse) {\n      paths = paths.slice(1);\n    } else {\n      paths = paths.slice(0, -1);\n    }\n\n    return paths;\n  },\n\n  /**\r\n   * Get the common ancestor path of two paths.\r\n   */\n  common(path, another) {\n    var common = [];\n\n    for (var i = 0; i < path.length && i < another.length; i++) {\n      var av = path[i];\n      var bv = another[i];\n\n      if (av !== bv) {\n        break;\n      }\n\n      common.push(av);\n    }\n\n    return common;\n  },\n\n  /**\r\n   * Compare a path to another, returning an integer indicating whether the path\r\n   * was before, at, or after the other.\r\n   *\r\n   * Note: Two paths of unequal length can still receive a `0` result if one is\r\n   * directly above or below the other. If you want exact matching, use\r\n   * [[Path.equals]] instead.\r\n   */\n  compare(path, another) {\n    var min = Math.min(path.length, another.length);\n\n    for (var i = 0; i < min; i++) {\n      if (path[i] < another[i]) return -1;\n      if (path[i] > another[i]) return 1;\n    }\n\n    return 0;\n  },\n\n  /**\r\n   * Check if a path ends after one of the indexes in another.\r\n   */\n  endsAfter(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av > bv;\n  },\n\n  /**\r\n   * Check if a path ends at one of the indexes in another.\r\n   */\n  endsAt(path, another) {\n    var i = path.length;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    return Path.equals(as, bs);\n  },\n\n  /**\r\n   * Check if a path ends before one of the indexes in another.\r\n   */\n  endsBefore(path, another) {\n    var i = path.length - 1;\n    var as = path.slice(0, i);\n    var bs = another.slice(0, i);\n    var av = path[i];\n    var bv = another[i];\n    return Path.equals(as, bs) && av < bv;\n  },\n\n  /**\r\n   * Check if a path is exactly equal to another.\r\n   */\n  equals(path, another) {\n    return path.length === another.length && path.every((n, i) => n === another[i]);\n  },\n\n  /**\r\n   * Check if the path of previous sibling node exists\r\n   */\n  hasPrevious(path) {\n    return path[path.length - 1] > 0;\n  },\n\n  /**\r\n   * Check if a path is after another.\r\n   */\n  isAfter(path, another) {\n    return Path.compare(path, another) === 1;\n  },\n\n  /**\r\n   * Check if a path is an ancestor of another.\r\n   */\n  isAncestor(path, another) {\n    return path.length < another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is before another.\r\n   */\n  isBefore(path, another) {\n    return Path.compare(path, another) === -1;\n  },\n\n  /**\r\n   * Check if a path is a child of another.\r\n   */\n  isChild(path, another) {\n    return path.length === another.length + 1 && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is equal to or an ancestor of another.\r\n   */\n  isCommon(path, another) {\n    return path.length <= another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is a descendant of another.\r\n   */\n  isDescendant(path, another) {\n    return path.length > another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check if a path is the parent of another.\r\n   */\n  isParent(path, another) {\n    return path.length + 1 === another.length && Path.compare(path, another) === 0;\n  },\n\n  /**\r\n   * Check is a value implements the `Path` interface.\r\n   */\n  isPath(value) {\n    return Array.isArray(value) && (value.length === 0 || typeof value[0] === 'number');\n  },\n\n  /**\r\n   * Check if a path is a sibling of another.\r\n   */\n  isSibling(path, another) {\n    if (path.length !== another.length) {\n      return false;\n    }\n\n    var as = path.slice(0, -1);\n    var bs = another.slice(0, -1);\n    var al = path[path.length - 1];\n    var bl = another[another.length - 1];\n    return al !== bl && Path.equals(as, bs);\n  },\n\n  /**\r\n   * Get a list of paths at every level down to a path. Note: this is the same\r\n   * as `Path.ancestors`, but including the path itself.\r\n   *\r\n   * The paths are sorted from shallowest to deepest. However, if the `reverse:\r\n   * true` option is passed, they are reversed.\r\n   */\n  levels(path) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var list = [];\n\n    for (var i = 0; i <= path.length; i++) {\n      list.push(path.slice(0, i));\n    }\n\n    if (reverse) {\n      list.reverse();\n    }\n\n    return list;\n  },\n\n  /**\r\n   * Given a path, get the path to the next sibling node.\r\n   */\n  next(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the next path of a root path [\".concat(path, \"], because it has no next index.\"));\n    }\n\n    var last = path[path.length - 1];\n    return path.slice(0, -1).concat(last + 1);\n  },\n\n  /**\r\n   * Returns whether this operation can affect paths or not. Used as an\r\n   * optimization when updating dirty paths during normalization\r\n   *\r\n   * NOTE: This *must* be kept in sync with the implementation of 'transform'\r\n   * below\r\n   */\n  operationCanTransformPath(operation) {\n    switch (operation.type) {\n      case 'insert_node':\n      case 'remove_node':\n      case 'merge_node':\n      case 'split_node':\n      case 'move_node':\n        return true;\n\n      default:\n        return false;\n    }\n  },\n\n  /**\r\n   * Given a path, return a new path referring to the parent node above it.\r\n   */\n  parent(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the parent path of the root path [\".concat(path, \"].\"));\n    }\n\n    return path.slice(0, -1);\n  },\n\n  /**\r\n   * Given a path, get the path to the previous sibling node.\r\n   */\n  previous(path) {\n    if (path.length === 0) {\n      throw new Error(\"Cannot get the previous path of a root path [\".concat(path, \"], because it has no previous index.\"));\n    }\n\n    var last = path[path.length - 1];\n\n    if (last <= 0) {\n      throw new Error(\"Cannot get the previous path of a first child path [\".concat(path, \"] because it would result in a negative index.\"));\n    }\n\n    return path.slice(0, -1).concat(last - 1);\n  },\n\n  /**\r\n   * Get a path relative to an ancestor.\r\n   */\n  relative(path, ancestor) {\n    if (!Path.isAncestor(ancestor, path) && !Path.equals(path, ancestor)) {\n      throw new Error(\"Cannot get the relative path of [\".concat(path, \"] inside ancestor [\").concat(ancestor, \"], because it is not above or equal to the path.\"));\n    }\n\n    return path.slice(ancestor.length);\n  },\n\n  /**\r\n   * Transform a path by an operation.\r\n   */\n  transform(path, operation) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(path, p => {\n      var {\n        affinity = 'forward'\n      } = options; // PERF: Exit early if the operation is guaranteed not to have an effect.\n\n      if (!path || (path === null || path === void 0 ? void 0 : path.length) === 0) {\n        return;\n      }\n\n      if (p === null) {\n        return null;\n      }\n\n      switch (operation.type) {\n        case 'insert_node':\n          {\n            var {\n              path: op\n            } = operation;\n\n            if (Path.equals(op, p) || Path.endsBefore(op, p) || Path.isAncestor(op, p)) {\n              p[op.length - 1] += 1;\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            var {\n              path: _op\n            } = operation;\n\n            if (Path.equals(_op, p) || Path.isAncestor(_op, p)) {\n              return null;\n            } else if (Path.endsBefore(_op, p)) {\n              p[_op.length - 1] -= 1;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            var {\n              path: _op2,\n              position\n            } = operation;\n\n            if (Path.equals(_op2, p) || Path.endsBefore(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n            } else if (Path.isAncestor(_op2, p)) {\n              p[_op2.length - 1] -= 1;\n              p[_op2.length] += position;\n            }\n\n            break;\n          }\n\n        case 'split_node':\n          {\n            var {\n              path: _op3,\n              position: _position\n            } = operation;\n\n            if (Path.equals(_op3, p)) {\n              if (affinity === 'forward') {\n                p[p.length - 1] += 1;\n              } else if (affinity === 'backward') ; else {\n                return null;\n              }\n            } else if (Path.endsBefore(_op3, p)) {\n              p[_op3.length - 1] += 1;\n            } else if (Path.isAncestor(_op3, p) && path[_op3.length] >= _position) {\n              p[_op3.length - 1] += 1;\n              p[_op3.length] -= _position;\n            }\n\n            break;\n          }\n\n        case 'move_node':\n          {\n            var {\n              path: _op4,\n              newPath: onp\n            } = operation; // If the old and new path are the same, it's a no-op.\n\n            if (Path.equals(_op4, onp)) {\n              return;\n            }\n\n            if (Path.isAncestor(_op4, p) || Path.equals(_op4, p)) {\n              var copy = onp.slice();\n\n              if (Path.endsBefore(_op4, onp) && _op4.length < onp.length) {\n                copy[_op4.length - 1] -= 1;\n              }\n\n              return copy.concat(p.slice(_op4.length));\n            } else if (Path.isSibling(_op4, onp) && (Path.isAncestor(onp, p) || Path.equals(onp, p))) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              } else {\n                p[_op4.length - 1] += 1;\n              }\n            } else if (Path.endsBefore(onp, p) || Path.equals(onp, p) || Path.isAncestor(onp, p)) {\n              if (Path.endsBefore(_op4, p)) {\n                p[_op4.length - 1] -= 1;\n              }\n\n              p[onp.length - 1] += 1;\n            } else if (Path.endsBefore(_op4, p)) {\n              if (Path.equals(onp, p)) {\n                p[onp.length - 1] += 1;\n              }\n\n              p[_op4.length - 1] -= 1;\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n};\n\nvar PathRef = {\n  /**\r\n   * Transform the path ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Path.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nfunction ownKeys$6(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$6(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$6(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$6(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Point = {\n  /**\r\n   * Compare a point to another, returning an integer indicating whether the\r\n   * point was before, at, or after the other.\r\n   */\n  compare(point, another) {\n    var result = Path.compare(point.path, another.path);\n\n    if (result === 0) {\n      if (point.offset < another.offset) return -1;\n      if (point.offset > another.offset) return 1;\n      return 0;\n    }\n\n    return result;\n  },\n\n  /**\r\n   * Check if a point is after another.\r\n   */\n  isAfter(point, another) {\n    return Point.compare(point, another) === 1;\n  },\n\n  /**\r\n   * Check if a point is before another.\r\n   */\n  isBefore(point, another) {\n    return Point.compare(point, another) === -1;\n  },\n\n  /**\r\n   * Check if a point is exactly equal to another.\r\n   */\n  equals(point, another) {\n    // PERF: ensure the offsets are equal first since they are cheaper to check.\n    return point.offset === another.offset && Path.equals(point.path, another.path);\n  },\n\n  /**\r\n   * Check if a value implements the `Point` interface.\r\n   */\n  isPoint(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.offset === 'number' && Path.isPath(value.path);\n  },\n\n  /**\r\n   * Transform a point by an operation.\r\n   */\n  transform(point, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(point, p => {\n      if (p === null) {\n        return null;\n      }\n\n      var {\n        affinity = 'forward'\n      } = options;\n      var {\n        path,\n        offset\n      } = p;\n\n      switch (op.type) {\n        case 'insert_node':\n        case 'move_node':\n          {\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'insert_text':\n          {\n            if (Path.equals(op.path, path) && (op.offset < offset || op.offset === offset && affinity === 'forward')) {\n              p.offset += op.text.length;\n            }\n\n            break;\n          }\n\n        case 'merge_node':\n          {\n            if (Path.equals(op.path, path)) {\n              p.offset += op.position;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'remove_text':\n          {\n            if (Path.equals(op.path, path) && op.offset <= offset) {\n              p.offset -= Math.min(offset - op.offset, op.text.length);\n            }\n\n            break;\n          }\n\n        case 'remove_node':\n          {\n            if (Path.equals(op.path, path) || Path.isAncestor(op.path, path)) {\n              return null;\n            }\n\n            p.path = Path.transform(path, op, options);\n            break;\n          }\n\n        case 'split_node':\n          {\n            if (Path.equals(op.path, path)) {\n              if (op.position === offset && affinity == null) {\n                return null;\n              } else if (op.position < offset || op.position === offset && affinity === 'forward') {\n                p.offset -= op.position;\n                p.path = Path.transform(path, op, _objectSpread$6(_objectSpread$6({}, options), {}, {\n                  affinity: 'forward'\n                }));\n              }\n            } else {\n              p.path = Path.transform(path, op, options);\n            }\n\n            break;\n          }\n      }\n    });\n  }\n\n};\n\nvar PointRef = {\n  /**\r\n   * Transform the point ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var point = Point.transform(current, op, {\n      affinity\n    });\n    ref.current = point;\n\n    if (point == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nvar _excluded$2 = [\"anchor\", \"focus\"];\n\nfunction ownKeys$5(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$5(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$5(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$5(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Range = {\n  /**\r\n   * Get the start and end points of a range, in the order in which they appear\r\n   * in the document.\r\n   */\n  edges(range) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      reverse = false\n    } = options;\n    var {\n      anchor,\n      focus\n    } = range;\n    return Range.isBackward(range) === reverse ? [anchor, focus] : [focus, anchor];\n  },\n\n  /**\r\n   * Get the end point of a range.\r\n   */\n  end(range) {\n    var [, end] = Range.edges(range);\n    return end;\n  },\n\n  /**\r\n   * Check if a range is exactly equal to another.\r\n   */\n  equals(range, another) {\n    return Point.equals(range.anchor, another.anchor) && Point.equals(range.focus, another.focus);\n  },\n\n  /**\r\n   * Check if a range includes a path, a point or part of another range.\r\n   */\n  includes(range, target) {\n    if (Range.isRange(target)) {\n      if (Range.includes(range, target.anchor) || Range.includes(range, target.focus)) {\n        return true;\n      }\n\n      var [rs, re] = Range.edges(range);\n      var [ts, te] = Range.edges(target);\n      return Point.isBefore(rs, ts) && Point.isAfter(re, te);\n    }\n\n    var [start, end] = Range.edges(range);\n    var isAfterStart = false;\n    var isBeforeEnd = false;\n\n    if (Point.isPoint(target)) {\n      isAfterStart = Point.compare(target, start) >= 0;\n      isBeforeEnd = Point.compare(target, end) <= 0;\n    } else {\n      isAfterStart = Path.compare(target, start.path) >= 0;\n      isBeforeEnd = Path.compare(target, end.path) <= 0;\n    }\n\n    return isAfterStart && isBeforeEnd;\n  },\n\n  /**\r\n   * Get the intersection of a range with another.\r\n   */\n  intersection(range, another) {\n    var rest = _objectWithoutProperties(range, _excluded$2);\n\n    var [s1, e1] = Range.edges(range);\n    var [s2, e2] = Range.edges(another);\n    var start = Point.isBefore(s1, s2) ? s2 : s1;\n    var end = Point.isBefore(e1, e2) ? e1 : e2;\n\n    if (Point.isBefore(end, start)) {\n      return null;\n    } else {\n      return _objectSpread$5({\n        anchor: start,\n        focus: end\n      }, rest);\n    }\n  },\n\n  /**\r\n   * Check if a range is backward, meaning that its anchor point appears in the\r\n   * document _after_ its focus point.\r\n   */\n  isBackward(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.isAfter(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is collapsed, meaning that both its anchor and focus\r\n   * points refer to the exact same position in the document.\r\n   */\n  isCollapsed(range) {\n    var {\n      anchor,\n      focus\n    } = range;\n    return Point.equals(anchor, focus);\n  },\n\n  /**\r\n   * Check if a range is expanded.\r\n   *\r\n   * This is the opposite of [[Range.isCollapsed]] and is provided for legibility.\r\n   */\n  isExpanded(range) {\n    return !Range.isCollapsed(range);\n  },\n\n  /**\r\n   * Check if a range is forward.\r\n   *\r\n   * This is the opposite of [[Range.isBackward]] and is provided for legibility.\r\n   */\n  isForward(range) {\n    return !Range.isBackward(range);\n  },\n\n  /**\r\n   * Check if a value implements the [[Range]] interface.\r\n   */\n  isRange(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && Point.isPoint(value.anchor) && Point.isPoint(value.focus);\n  },\n\n  /**\r\n   * Iterate through all of the point entries in a range.\r\n   */\n  *points(range) {\n    yield [range.anchor, 'anchor'];\n    yield [range.focus, 'focus'];\n  },\n\n  /**\r\n   * Get the start point of a range.\r\n   */\n  start(range) {\n    var [start] = Range.edges(range);\n    return start;\n  },\n\n  /**\r\n   * Transform a range by an operation.\r\n   */\n  transform(range, op) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return (0,immer__WEBPACK_IMPORTED_MODULE_1__.produce)(range, r => {\n      if (r === null) {\n        return null;\n      }\n\n      var {\n        affinity = 'inward'\n      } = options;\n      var affinityAnchor;\n      var affinityFocus;\n\n      if (affinity === 'inward') {\n        // If the range is collapsed, make sure to use the same affinity to\n        // avoid the two points passing each other and expanding in the opposite\n        // direction\n        var isCollapsed = Range.isCollapsed(r);\n\n        if (Range.isForward(r)) {\n          affinityAnchor = 'forward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'backward';\n        } else {\n          affinityAnchor = 'backward';\n          affinityFocus = isCollapsed ? affinityAnchor : 'forward';\n        }\n      } else if (affinity === 'outward') {\n        if (Range.isForward(r)) {\n          affinityAnchor = 'backward';\n          affinityFocus = 'forward';\n        } else {\n          affinityAnchor = 'forward';\n          affinityFocus = 'backward';\n        }\n      } else {\n        affinityAnchor = affinity;\n        affinityFocus = affinity;\n      }\n\n      var anchor = Point.transform(r.anchor, op, {\n        affinity: affinityAnchor\n      });\n      var focus = Point.transform(r.focus, op, {\n        affinity: affinityFocus\n      });\n\n      if (!anchor || !focus) {\n        return null;\n      }\n\n      r.anchor = anchor;\n      r.focus = focus;\n    });\n  }\n\n};\n\nvar RangeRef = {\n  /**\r\n   * Transform the range ref's current value by an operation.\r\n   */\n  transform(ref, op) {\n    var {\n      current,\n      affinity\n    } = ref;\n\n    if (current == null) {\n      return;\n    }\n\n    var path = Range.transform(current, op, {\n      affinity\n    });\n    ref.current = path;\n\n    if (path == null) {\n      ref.unref();\n    }\n  }\n\n};\n\nvar _scrubber = undefined;\n/**\r\n * This interface implements a stringify() function, which is used by Slate\r\n * internally when generating exceptions containing end user data. Developers\r\n * using Slate may call Scrubber.setScrubber() to alter the behavior of this\r\n * stringify() function.\r\n *\r\n * For example, to prevent the cleartext logging of 'text' fields within Nodes:\r\n *\r\n *    import { Scrubber } from 'slate';\r\n *    Scrubber.setScrubber((key, val) => {\r\n *      if (key === 'text') return '...scrubbed...'\r\n *      return val\r\n *    });\r\n *\r\n */\n// eslint-disable-next-line no-redeclare\n\nvar Scrubber = {\n  setScrubber(scrubber) {\n    _scrubber = scrubber;\n  },\n\n  stringify(value) {\n    return JSON.stringify(value, _scrubber);\n  }\n\n};\n\n/*\r\n  Custom deep equal comparison for Slate nodes.\r\n\n  We don't need general purpose deep equality;\r\n  Slate only supports plain values, Arrays, and nested objects.\r\n  Complex values nested inside Arrays are not supported.\r\n\n  Slate objects are designed to be serialised, so\r\n  missing keys are deliberately normalised to undefined.\r\n */\n\nvar isDeepEqual = (node, another) => {\n  for (var key in node) {\n    var a = node[key];\n    var b = another[key];\n\n    if ((0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(a) && (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(b)) {\n      if (!isDeepEqual(a, b)) return false;\n    } else if (Array.isArray(a) && Array.isArray(b)) {\n      if (a.length !== b.length) return false;\n\n      for (var i = 0; i < a.length; i++) {\n        if (a[i] !== b[i]) return false;\n      }\n    } else if (a !== b) {\n      return false;\n    }\n  }\n  /*\r\n    Deep object equality is only necessary in one direction; in the reverse direction\r\n    we are only looking for keys that are missing.\r\n    As above, undefined keys are normalised to missing.\r\n  */\n\n\n  for (var _key in another) {\n    if (node[_key] === undefined && another[_key] !== undefined) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nvar _excluded$1 = [\"text\"],\n    _excluded2$1 = [\"anchor\", \"focus\"];\n\nfunction ownKeys$4(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$4(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$4(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$4(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar Text = {\n  /**\r\n   * Check if two text nodes are equal.\r\n   *\r\n   * When loose is set, the text is not compared. This is\r\n   * used to check whether sibling text nodes can be merged.\r\n   */\n  equals(text, another) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      loose = false\n    } = options;\n\n    function omitText(obj) {\n      var rest = _objectWithoutProperties(obj, _excluded$1);\n\n      return rest;\n    }\n\n    return isDeepEqual(loose ? omitText(text) : text, loose ? omitText(another) : another);\n  },\n\n  /**\r\n   * Check if a value implements the `Text` interface.\r\n   */\n  isText(value) {\n    return (0,is_plain_object__WEBPACK_IMPORTED_MODULE_0__.isPlainObject)(value) && typeof value.text === 'string';\n  },\n\n  /**\r\n   * Check if a value is a list of `Text` objects.\r\n   */\n  isTextList(value) {\n    return Array.isArray(value) && value.every(val => Text.isText(val));\n  },\n\n  /**\r\n   * Check if some props are a partial of Text.\r\n   */\n  isTextProps(props) {\n    return props.text !== undefined;\n  },\n\n  /**\r\n   * Check if an text matches set of properties.\r\n   *\r\n   * Note: this is for matching custom properties, and it does not ensure that\r\n   * the `text` property are two nodes equal.\r\n   */\n  matches(text, props) {\n    for (var key in props) {\n      if (key === 'text') {\n        continue;\n      }\n\n      if (!text.hasOwnProperty(key) || text[key] !== props[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\r\n   * Get the leaves for a text node given decorations.\r\n   */\n  decorations(node, decorations) {\n    var leaves = [_objectSpread$4({}, node)];\n\n    for (var dec of decorations) {\n      var rest = _objectWithoutProperties(dec, _excluded2$1);\n\n      var [start, end] = Range.edges(dec);\n      var next = [];\n      var leafEnd = 0;\n      var decorationStart = start.offset;\n      var decorationEnd = end.offset;\n\n      for (var leaf of leaves) {\n        var {\n          length\n        } = leaf.text;\n        var leafStart = leafEnd;\n        leafEnd += length; // If the range encompasses the entire leaf, add the range.\n\n        if (decorationStart <= leafStart && leafEnd <= decorationEnd) {\n          Object.assign(leaf, rest);\n          next.push(leaf);\n          continue;\n        } // If the range expanded and match the leaf, or starts after, or ends before it, continue.\n\n\n        if (decorationStart !== decorationEnd && (decorationStart === leafEnd || decorationEnd === leafStart) || decorationStart > leafEnd || decorationEnd < leafStart || decorationEnd === leafStart && leafStart !== 0) {\n          next.push(leaf);\n          continue;\n        } // Otherwise we need to split the leaf, at the start, end, or both,\n        // and add the range to the middle intersecting section. Do the end\n        // split first since we don't need to update the offset that way.\n\n\n        var middle = leaf;\n        var before = void 0;\n        var after = void 0;\n\n        if (decorationEnd < leafEnd) {\n          var off = decorationEnd - leafStart;\n          after = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(off)\n          });\n          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(0, off)\n          });\n        }\n\n        if (decorationStart > leafStart) {\n          var _off = decorationStart - leafStart;\n\n          before = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(0, _off)\n          });\n          middle = _objectSpread$4(_objectSpread$4({}, middle), {}, {\n            text: middle.text.slice(_off)\n          });\n        }\n\n        Object.assign(middle, rest);\n\n        if (before) {\n          next.push(before);\n        }\n\n        next.push(middle);\n\n        if (after) {\n          next.push(after);\n        }\n      }\n\n      leaves = next;\n    }\n\n    return leaves;\n  }\n\n};\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$3(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar applyToDraft = (editor, selection, op) => {\n  switch (op.type) {\n    case 'insert_node':\n      {\n        var {\n          path,\n          node\n        } = op;\n        var parent = Node.parent(editor, path);\n        var index = path[path.length - 1];\n\n        if (index > parent.children.length) {\n          throw new Error(\"Cannot apply an \\\"insert_node\\\" operation at path [\".concat(path, \"] because the destination is past the end of the node.\"));\n        }\n\n        parent.children.splice(index, 0, node);\n\n        if (selection) {\n          for (var [point, key] of Range.points(selection)) {\n            selection[key] = Point.transform(point, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'insert_text':\n      {\n        var {\n          path: _path,\n          offset,\n          text\n        } = op;\n        if (text.length === 0) break;\n\n        var _node = Node.leaf(editor, _path);\n\n        var before = _node.text.slice(0, offset);\n\n        var after = _node.text.slice(offset);\n\n        _node.text = before + text + after;\n\n        if (selection) {\n          for (var [_point, _key] of Range.points(selection)) {\n            selection[_key] = Point.transform(_point, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'merge_node':\n      {\n        var {\n          path: _path2\n        } = op;\n\n        var _node2 = Node.get(editor, _path2);\n\n        var prevPath = Path.previous(_path2);\n        var prev = Node.get(editor, prevPath);\n\n        var _parent = Node.parent(editor, _path2);\n\n        var _index = _path2[_path2.length - 1];\n\n        if (Text.isText(_node2) && Text.isText(prev)) {\n          prev.text += _node2.text;\n        } else if (!Text.isText(_node2) && !Text.isText(prev)) {\n          prev.children.push(..._node2.children);\n        } else {\n          throw new Error(\"Cannot apply a \\\"merge_node\\\" operation at path [\".concat(_path2, \"] to nodes of different interfaces: \").concat(Scrubber.stringify(_node2), \" \").concat(Scrubber.stringify(prev)));\n        }\n\n        _parent.children.splice(_index, 1);\n\n        if (selection) {\n          for (var [_point2, _key2] of Range.points(selection)) {\n            selection[_key2] = Point.transform(_point2, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'move_node':\n      {\n        var {\n          path: _path3,\n          newPath\n        } = op;\n\n        if (Path.isAncestor(_path3, newPath)) {\n          throw new Error(\"Cannot move a path [\".concat(_path3, \"] to new path [\").concat(newPath, \"] because the destination is inside itself.\"));\n        }\n\n        var _node3 = Node.get(editor, _path3);\n\n        var _parent2 = Node.parent(editor, _path3);\n\n        var _index2 = _path3[_path3.length - 1]; // This is tricky, but since the `path` and `newPath` both refer to\n        // the same snapshot in time, there's a mismatch. After either\n        // removing the original position, the second step's path can be out\n        // of date. So instead of using the `op.newPath` directly, we\n        // transform `op.path` to ascertain what the `newPath` would be after\n        // the operation was applied.\n\n        _parent2.children.splice(_index2, 1);\n\n        var truePath = Path.transform(_path3, op);\n        var newParent = Node.get(editor, Path.parent(truePath));\n        var newIndex = truePath[truePath.length - 1];\n        newParent.children.splice(newIndex, 0, _node3);\n\n        if (selection) {\n          for (var [_point3, _key3] of Range.points(selection)) {\n            selection[_key3] = Point.transform(_point3, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_node':\n      {\n        var {\n          path: _path4\n        } = op;\n        var _index3 = _path4[_path4.length - 1];\n\n        var _parent3 = Node.parent(editor, _path4);\n\n        _parent3.children.splice(_index3, 1); // Transform all of the points in the value, but if the point was in the\n        // node that was removed we need to update the range or remove it.\n\n\n        if (selection) {\n          for (var [_point4, _key4] of Range.points(selection)) {\n            var result = Point.transform(_point4, op);\n\n            if (selection != null && result != null) {\n              selection[_key4] = result;\n            } else {\n              var _prev = void 0;\n\n              var next = void 0;\n\n              for (var [n, p] of Node.texts(editor)) {\n                if (Path.compare(p, _path4) === -1) {\n                  _prev = [n, p];\n                } else {\n                  next = [n, p];\n                  break;\n                }\n              }\n\n              var preferNext = false;\n\n              if (_prev && next) {\n                if (Path.equals(next[1], _path4)) {\n                  preferNext = !Path.hasPrevious(next[1]);\n                } else {\n                  preferNext = Path.common(_prev[1], _path4).length < Path.common(next[1], _path4).length;\n                }\n              }\n\n              if (_prev && !preferNext) {\n                _point4.path = _prev[1];\n                _point4.offset = _prev[0].text.length;\n              } else if (next) {\n                _point4.path = next[1];\n                _point4.offset = 0;\n              } else {\n                selection = null;\n              }\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'remove_text':\n      {\n        var {\n          path: _path5,\n          offset: _offset,\n          text: _text\n        } = op;\n        if (_text.length === 0) break;\n\n        var _node4 = Node.leaf(editor, _path5);\n\n        var _before = _node4.text.slice(0, _offset);\n\n        var _after = _node4.text.slice(_offset + _text.length);\n\n        _node4.text = _before + _after;\n\n        if (selection) {\n          for (var [_point5, _key5] of Range.points(selection)) {\n            selection[_key5] = Point.transform(_point5, op);\n          }\n        }\n\n        break;\n      }\n\n    case 'set_node':\n      {\n        var {\n          path: _path6,\n          properties,\n          newProperties\n        } = op;\n\n        if (_path6.length === 0) {\n          throw new Error(\"Cannot set properties on the root node!\");\n        }\n\n        var _node5 = Node.get(editor, _path6);\n\n        for (var _key6 in newProperties) {\n          if (_key6 === 'children' || _key6 === 'text') {\n            throw new Error(\"Cannot set the \\\"\".concat(_key6, \"\\\" property of nodes!\"));\n          }\n\n          var value = newProperties[_key6];\n\n          if (value == null) {\n            delete _node5[_key6];\n          } else {\n            _node5[_key6] = value;\n          }\n        } // properties that were previously defined, but are now missing, must be deleted\n\n\n        for (var _key7 in properties) {\n          if (!newProperties.hasOwnProperty(_key7)) {\n            delete _node5[_key7];\n          }\n        }\n\n        break;\n      }\n\n    case 'set_selection':\n      {\n        var {\n          newProperties: _newProperties\n        } = op;\n\n        if (_newProperties == null) {\n          selection = _newProperties;\n        } else {\n          if (selection == null) {\n            if (!Range.isRange(_newProperties)) {\n              throw new Error(\"Cannot apply an incomplete \\\"set_selection\\\" operation properties \".concat(Scrubber.stringify(_newProperties), \" when there is no current selection.\"));\n            }\n\n            selection = _objectSpread$3({}, _newProperties);\n          }\n\n          for (var _key8 in _newProperties) {\n            var _value = _newProperties[_key8];\n\n            if (_value == null) {\n              if (_key8 === 'anchor' || _key8 === 'focus') {\n                throw new Error(\"Cannot remove the \\\"\".concat(_key8, \"\\\" selection property\"));\n              }\n\n              delete selection[_key8];\n            } else {\n              selection[_key8] = _value;\n            }\n          }\n        }\n\n        break;\n      }\n\n    case 'split_node':\n      {\n        var {\n          path: _path7,\n          position,\n          properties: _properties\n        } = op;\n\n        if (_path7.length === 0) {\n          throw new Error(\"Cannot apply a \\\"split_node\\\" operation at path [\".concat(_path7, \"] because the root node cannot be split.\"));\n        }\n\n        var _node6 = Node.get(editor, _path7);\n\n        var _parent4 = Node.parent(editor, _path7);\n\n        var _index4 = _path7[_path7.length - 1];\n        var newNode;\n\n        if (Text.isText(_node6)) {\n          var _before2 = _node6.text.slice(0, position);\n\n          var _after2 = _node6.text.slice(position);\n\n          _node6.text = _before2;\n          newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n            text: _after2\n          });\n        } else {\n          var _before3 = _node6.children.slice(0, position);\n\n          var _after3 = _node6.children.slice(position);\n\n          _node6.children = _before3;\n          newNode = _objectSpread$3(_objectSpread$3({}, _properties), {}, {\n            children: _after3\n          });\n        }\n\n        _parent4.children.splice(_index4 + 1, 0, newNode);\n\n        if (selection) {\n          for (var [_point6, _key9] of Range.points(selection)) {\n            selection[_key9] = Point.transform(_point6, op);\n          }\n        }\n\n        break;\n      }\n  }\n\n  return selection;\n}; // eslint-disable-next-line no-redeclare\n\n\nvar GeneralTransforms = {\n  /**\r\n   * Transform the editor by an operation.\r\n   */\n  transform(editor, op) {\n    editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.children);\n    var selection = editor.selection && (0,immer__WEBPACK_IMPORTED_MODULE_1__.createDraft)(editor.selection);\n\n    try {\n      selection = applyToDraft(editor, selection, op);\n    } finally {\n      editor.children = (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(editor.children);\n\n      if (selection) {\n        editor.selection = (0,immer__WEBPACK_IMPORTED_MODULE_1__.isDraft)(selection) ? (0,immer__WEBPACK_IMPORTED_MODULE_1__.finishDraft)(selection) : selection;\n      } else {\n        editor.selection = null;\n      }\n    }\n  }\n\n};\n\nvar _excluded = [\"text\"],\n    _excluded2 = [\"children\"];\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$2(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar NodeTransforms = {\n  /**\r\n   * Insert nodes at a specific location in the Editor.\r\n   */\n  insertNodes(editor, nodes) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n      var {\n        at,\n        match,\n        select\n      } = options;\n\n      if (Node.isNode(nodes)) {\n        nodes = [nodes];\n      }\n\n      if (nodes.length === 0) {\n        return;\n      }\n\n      var [node] = nodes; // By default, use the selection as the target location. But if there is\n      // no selection, insert at the end of the document since that is such a\n      // common use case when inserting from a non-selected state.\n\n      if (!at) {\n        if (editor.selection) {\n          at = editor.selection;\n        } else if (editor.children.length > 0) {\n          at = Editor.end(editor, []);\n        } else {\n          at = [0];\n        }\n\n        select = true;\n      }\n\n      if (select == null) {\n        select = false;\n      }\n\n      if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = Range.edges(at);\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n        }\n      }\n\n      if (Point.isPoint(at)) {\n        if (match == null) {\n          if (Text.isText(node)) {\n            match = n => Text.isText(n);\n          } else if (editor.isInline(node)) {\n            match = n => Text.isText(n) || Editor.isInline(editor, n);\n          } else {\n            match = n => Editor.isBlock(editor, n);\n          }\n        }\n\n        var [entry] = Editor.nodes(editor, {\n          at: at.path,\n          match,\n          mode,\n          voids\n        });\n\n        if (entry) {\n          var [, _matchPath] = entry;\n          var pathRef = Editor.pathRef(editor, _matchPath);\n          var isAtEnd = Editor.isEnd(editor, at, _matchPath);\n          Transforms.splitNodes(editor, {\n            at,\n            match,\n            mode,\n            voids\n          });\n          var path = pathRef.unref();\n          at = isAtEnd ? Path.next(path) : path;\n        } else {\n          return;\n        }\n      }\n\n      var parentPath = Path.parent(at);\n      var index = at[at.length - 1];\n\n      if (!voids && Editor.void(editor, {\n        at: parentPath\n      })) {\n        return;\n      }\n\n      for (var _node of nodes) {\n        var _path = parentPath.concat(index);\n\n        index++;\n        editor.apply({\n          type: 'insert_node',\n          path: _path,\n          node: _node\n        });\n        at = Path.next(at);\n      }\n\n      at = Path.previous(at);\n\n      if (select) {\n        var point = Editor.end(editor, at);\n\n        if (point) {\n          Transforms.select(editor, point);\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Lift nodes at a specific location upwards in the document tree, splitting\r\n   * their parent in two if necessary.\r\n   */\n  liftNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match\n      } = options;\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var matches = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(matches, _ref => {\n        var [, p] = _ref;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n\n        if (path.length < 2) {\n          throw new Error(\"Cannot lift node at a path [\".concat(path, \"] because it has a depth of less than `2`.\"));\n        }\n\n        var parentNodeEntry = Editor.node(editor, Path.parent(path));\n        var [parent, parentPath] = parentNodeEntry;\n        var index = path[path.length - 1];\n        var {\n          length\n        } = parent.children;\n\n        if (length === 1) {\n          var toPath = Path.next(parentPath);\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: toPath,\n            voids\n          });\n          Transforms.removeNodes(editor, {\n            at: parentPath,\n            voids\n          });\n        } else if (index === 0) {\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: parentPath,\n            voids\n          });\n        } else if (index === length - 1) {\n          var _toPath = Path.next(parentPath);\n\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath,\n            voids\n          });\n        } else {\n          var splitPath = Path.next(path);\n\n          var _toPath2 = Path.next(parentPath);\n\n          Transforms.splitNodes(editor, {\n            at: splitPath,\n            voids\n          });\n          Transforms.moveNodes(editor, {\n            at: path,\n            to: _toPath2,\n            voids\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Merge a node at a location with the previous node of the same depth,\r\n   * removing any empty containing nodes after the merge if necessary.\r\n   */\n  mergeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        match,\n        at = editor.selection\n      } = options;\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          var [parent] = Editor.parent(editor, at);\n\n          match = n => parent.children.includes(n);\n        } else {\n          match = n => Editor.isBlock(editor, n);\n        }\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = Range.edges(at);\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n\n          if (options.at == null) {\n            Transforms.select(editor, at);\n          }\n        }\n      }\n\n      var [current] = Editor.nodes(editor, {\n        at,\n        match,\n        voids,\n        mode\n      });\n      var prev = Editor.previous(editor, {\n        at,\n        match,\n        voids,\n        mode\n      });\n\n      if (!current || !prev) {\n        return;\n      }\n\n      var [node, path] = current;\n      var [prevNode, prevPath] = prev;\n\n      if (path.length === 0 || prevPath.length === 0) {\n        return;\n      }\n\n      var newPath = Path.next(prevPath);\n      var commonPath = Path.common(path, prevPath);\n      var isPreviousSibling = Path.isSibling(path, prevPath);\n      var levels = Array.from(Editor.levels(editor, {\n        at: path\n      }), _ref2 => {\n        var [n] = _ref2;\n        return n;\n      }).slice(commonPath.length).slice(0, -1); // Determine if the merge will leave an ancestor of the path empty as a\n      // result, in which case we'll want to remove it after merging.\n\n      var emptyAncestor = Editor.above(editor, {\n        at: path,\n        mode: 'highest',\n        match: n => levels.includes(n) && hasSingleChildNest(editor, n)\n      });\n      var emptyRef = emptyAncestor && Editor.pathRef(editor, emptyAncestor[1]);\n      var properties;\n      var position; // Ensure that the nodes are equivalent, and figure out what the position\n      // and extra properties of the merge will be.\n\n      if (Text.isText(node) && Text.isText(prevNode)) {\n        var rest = _objectWithoutProperties(node, _excluded);\n\n        position = prevNode.text.length;\n        properties = rest;\n      } else if (Element.isElement(node) && Element.isElement(prevNode)) {\n        var rest = _objectWithoutProperties(node, _excluded2);\n\n        position = prevNode.children.length;\n        properties = rest;\n      } else {\n        throw new Error(\"Cannot merge the node at path [\".concat(path, \"] with the previous sibling because it is not the same kind: \").concat(Scrubber.stringify(node), \" \").concat(Scrubber.stringify(prevNode)));\n      } // If the node isn't already the next sibling of the previous node, move\n      // it so that it is before merging.\n\n\n      if (!isPreviousSibling) {\n        Transforms.moveNodes(editor, {\n          at: path,\n          to: newPath,\n          voids\n        });\n      } // If there was going to be an empty ancestor of the node that was merged,\n      // we remove it from the tree.\n\n\n      if (emptyRef) {\n        Transforms.removeNodes(editor, {\n          at: emptyRef.current,\n          voids\n        });\n      } // If the target node that we're merging with is empty, remove it instead\n      // of merging the two. This is a common rich text editor behavior to\n      // prevent losing formatting when deleting entire nodes when you have a\n      // hanging selection.\n      // if prevNode is first child in parent,don't remove it.\n\n\n      if (Element.isElement(prevNode) && Editor.isEmpty(editor, prevNode) || Text.isText(prevNode) && prevNode.text === '' && prevPath[prevPath.length - 1] !== 0) {\n        Transforms.removeNodes(editor, {\n          at: prevPath,\n          voids\n        });\n      } else {\n        editor.apply({\n          type: 'merge_node',\n          path: newPath,\n          position,\n          properties\n        });\n      }\n\n      if (emptyRef) {\n        emptyRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Move the nodes at a location to a new location.\r\n   */\n  moveNodes(editor, options) {\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        to,\n        at = editor.selection,\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      var toRef = Editor.pathRef(editor, to);\n      var targets = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(targets, _ref3 => {\n        var [, p] = _ref3;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n        var newPath = toRef.current;\n\n        if (path.length !== 0) {\n          editor.apply({\n            type: 'move_node',\n            path,\n            newPath\n          });\n        }\n\n        if (toRef.current && Path.isSibling(newPath, path) && Path.isAfter(newPath, path)) {\n          // When performing a sibling move to a later index, the path at the destination is shifted\n          // to before the insertion point instead of after. To ensure our group of nodes are inserted\n          // in the correct order we increment toRef to account for that\n          toRef.current = Path.next(toRef.current);\n        }\n      }\n\n      toRef.unref();\n    });\n  },\n\n  /**\r\n   * Remove the nodes at a specific location in the document.\r\n   */\n  removeNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false,\n        mode = 'lowest'\n      } = options;\n      var {\n        at = editor.selection,\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      var depths = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(depths, _ref4 => {\n        var [, p] = _ref4;\n        return Editor.pathRef(editor, p);\n      });\n\n      for (var pathRef of pathRefs) {\n        var path = pathRef.unref();\n\n        if (path) {\n          var [node] = Editor.node(editor, path);\n          editor.apply({\n            type: 'remove_node',\n            path,\n            node\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Set new properties on the nodes at a location.\r\n   */\n  setNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        match,\n        at = editor.selection,\n        compare,\n        merge\n      } = options;\n      var {\n        hanging = false,\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (!hanging && Range.isRange(at)) {\n        at = Editor.unhangRange(editor, at);\n      }\n\n      if (split && Range.isRange(at)) {\n        if (Range.isCollapsed(at) && Editor.leaf(editor, at.anchor)[0].text.length > 0) {\n          // If the range is collapsed in a non-empty node and 'split' is true, there's nothing to\n          // set that won't get normalized away\n          return;\n        }\n\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        var [start, end] = Range.edges(at);\n        var splitMode = mode === 'lowest' ? 'lowest' : 'highest';\n        var endAtEndOfNode = Editor.isEnd(editor, end, end.path);\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          mode: splitMode,\n          voids,\n          always: !endAtEndOfNode\n        });\n        var startAtStartOfNode = Editor.isStart(editor, start, start.path);\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          mode: splitMode,\n          voids,\n          always: !startAtStartOfNode\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      if (!compare) {\n        compare = (prop, nodeProp) => prop !== nodeProp;\n      }\n\n      for (var [node, path] of Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      })) {\n        var properties = {};\n        var newProperties = {}; // You can't set properties on the editor node.\n\n        if (path.length === 0) {\n          continue;\n        }\n\n        var hasChanges = false;\n\n        for (var k in props) {\n          if (k === 'children' || k === 'text') {\n            continue;\n          }\n\n          if (compare(props[k], node[k])) {\n            hasChanges = true; // Omit new properties from the old properties list\n\n            if (node.hasOwnProperty(k)) properties[k] = node[k]; // Omit properties that have been removed from the new properties list\n\n            if (merge) {\n              if (props[k] != null) newProperties[k] = merge(node[k], props[k]);\n            } else {\n              if (props[k] != null) newProperties[k] = props[k];\n            }\n          }\n        }\n\n        if (hasChanges) {\n          editor.apply({\n            type: 'set_node',\n            path,\n            properties,\n            newProperties\n          });\n        }\n      }\n    });\n  },\n\n  /**\r\n   * Split the nodes at a specific location.\r\n   */\n  splitNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        voids = false\n      } = options;\n      var {\n        match,\n        at = editor.selection,\n        height = 0,\n        always = false\n      } = options;\n\n      if (match == null) {\n        match = n => Editor.isBlock(editor, n);\n      }\n\n      if (Range.isRange(at)) {\n        at = deleteRange(editor, at);\n      } // If the target is a path, the default height-skipping and position\n      // counters need to account for us potentially splitting at a non-leaf.\n\n\n      if (Path.isPath(at)) {\n        var path = at;\n        var point = Editor.point(editor, path);\n        var [parent] = Editor.parent(editor, path);\n\n        match = n => n === parent;\n\n        height = point.path.length - path.length + 1;\n        at = point;\n        always = true;\n      }\n\n      if (!at) {\n        return;\n      }\n\n      var beforeRef = Editor.pointRef(editor, at, {\n        affinity: 'backward'\n      });\n      var afterRef;\n\n      try {\n        var [highest] = Editor.nodes(editor, {\n          at,\n          match,\n          mode,\n          voids\n        });\n\n        if (!highest) {\n          return;\n        }\n\n        var voidMatch = Editor.void(editor, {\n          at,\n          mode: 'highest'\n        });\n        var nudge = 0;\n\n        if (!voids && voidMatch) {\n          var [voidNode, voidPath] = voidMatch;\n\n          if (Element.isElement(voidNode) && editor.isInline(voidNode)) {\n            var after = Editor.after(editor, voidPath);\n\n            if (!after) {\n              var text = {\n                text: ''\n              };\n              var afterPath = Path.next(voidPath);\n              Transforms.insertNodes(editor, text, {\n                at: afterPath,\n                voids\n              });\n              after = Editor.point(editor, afterPath);\n            }\n\n            at = after;\n            always = true;\n          }\n\n          var siblingHeight = at.path.length - voidPath.length;\n          height = siblingHeight + 1;\n          always = true;\n        }\n\n        afterRef = Editor.pointRef(editor, at);\n        var depth = at.path.length - height;\n        var [, highestPath] = highest;\n        var lowestPath = at.path.slice(0, depth);\n        var position = height === 0 ? at.offset : at.path[depth] + nudge;\n\n        for (var [node, _path2] of Editor.levels(editor, {\n          at: lowestPath,\n          reverse: true,\n          voids\n        })) {\n          var split = false;\n\n          if (_path2.length < highestPath.length || _path2.length === 0 || !voids && Editor.isVoid(editor, node)) {\n            break;\n          }\n\n          var _point = beforeRef.current;\n          var isEnd = Editor.isEnd(editor, _point, _path2);\n\n          if (always || !beforeRef || !Editor.isEdge(editor, _point, _path2)) {\n            split = true;\n            var properties = Node.extractProps(node);\n            editor.apply({\n              type: 'split_node',\n              path: _path2,\n              position,\n              properties\n            });\n          }\n\n          position = _path2[_path2.length - 1] + (split || isEnd ? 1 : 0);\n        }\n\n        if (options.at == null) {\n          var _point2 = afterRef.current || Editor.end(editor, []);\n\n          Transforms.select(editor, _point2);\n        }\n      } finally {\n        var _afterRef;\n\n        beforeRef.unref();\n        (_afterRef = afterRef) === null || _afterRef === void 0 ? void 0 : _afterRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Unset properties on the nodes at a location.\r\n   */\n  unsetNodes(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (!Array.isArray(props)) {\n      props = [props];\n    }\n\n    var obj = {};\n\n    for (var key of props) {\n      obj[key] = null;\n    }\n\n    Transforms.setNodes(editor, obj, options);\n  },\n\n  /**\r\n   * Unwrap the nodes at a location from a parent node, splitting the parent if\r\n   * necessary to ensure that only the content in the range is unwrapped.\r\n   */\n  unwrapNodes(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection,\n        match\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        match = Path.isPath(at) ? matchPath(editor, at) : n => Editor.isBlock(editor, n);\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      var rangeRef = Range.isRange(at) ? Editor.rangeRef(editor, at) : null;\n      var matches = Editor.nodes(editor, {\n        at,\n        match,\n        mode,\n        voids\n      });\n      var pathRefs = Array.from(matches, _ref5 => {\n        var [, p] = _ref5;\n        return Editor.pathRef(editor, p);\n      } // unwrapNode will call liftNode which does not support splitting the node when nested.\n      // If we do not reverse the order and call it from top to the bottom, it will remove all blocks\n      // that wrap target node. So we reverse the order.\n      ).reverse();\n\n      var _loop = function _loop(pathRef) {\n        var path = pathRef.unref();\n        var [node] = Editor.node(editor, path);\n        var range = Editor.range(editor, path);\n\n        if (split && rangeRef) {\n          range = Range.intersection(rangeRef.current, range);\n        }\n\n        Transforms.liftNodes(editor, {\n          at: range,\n          match: n => Element.isAncestor(node) && node.children.includes(n),\n          voids\n        });\n      };\n\n      for (var pathRef of pathRefs) {\n        _loop(pathRef);\n      }\n\n      if (rangeRef) {\n        rangeRef.unref();\n      }\n    });\n  },\n\n  /**\r\n   * Wrap the nodes at a location in a new container node, splitting the edges\r\n   * of the range first to ensure that only the content in the range is wrapped.\r\n   */\n  wrapNodes(editor, element) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        mode = 'lowest',\n        split = false,\n        voids = false\n      } = options;\n      var {\n        match,\n        at = editor.selection\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (match == null) {\n        if (Path.isPath(at)) {\n          match = matchPath(editor, at);\n        } else if (editor.isInline(element)) {\n          match = n => Editor.isInline(editor, n) || Text.isText(n);\n        } else {\n          match = n => Editor.isBlock(editor, n);\n        }\n      }\n\n      if (split && Range.isRange(at)) {\n        var [start, end] = Range.edges(at);\n        var rangeRef = Editor.rangeRef(editor, at, {\n          affinity: 'inward'\n        });\n        Transforms.splitNodes(editor, {\n          at: end,\n          match,\n          voids\n        });\n        Transforms.splitNodes(editor, {\n          at: start,\n          match,\n          voids\n        });\n        at = rangeRef.unref();\n\n        if (options.at == null) {\n          Transforms.select(editor, at);\n        }\n      }\n\n      var roots = Array.from(Editor.nodes(editor, {\n        at,\n        match: editor.isInline(element) ? n => Editor.isBlock(editor, n) : n => Editor.isEditor(n),\n        mode: 'lowest',\n        voids\n      }));\n\n      for (var [, rootPath] of roots) {\n        var a = Range.isRange(at) ? Range.intersection(at, Editor.range(editor, rootPath)) : at;\n\n        if (!a) {\n          continue;\n        }\n\n        var matches = Array.from(Editor.nodes(editor, {\n          at: a,\n          match,\n          mode,\n          voids\n        }));\n\n        if (matches.length > 0) {\n          var _ret = function () {\n            var [first] = matches;\n            var last = matches[matches.length - 1];\n            var [, firstPath] = first;\n            var [, lastPath] = last;\n\n            if (firstPath.length === 0 && lastPath.length === 0) {\n              // if there's no matching parent - usually means the node is an editor - don't do anything\n              return \"continue\";\n            }\n\n            var commonPath = Path.equals(firstPath, lastPath) ? Path.parent(firstPath) : Path.common(firstPath, lastPath);\n            var range = Editor.range(editor, firstPath, lastPath);\n            var commonNodeEntry = Editor.node(editor, commonPath);\n            var [commonNode] = commonNodeEntry;\n            var depth = commonPath.length + 1;\n            var wrapperPath = Path.next(lastPath.slice(0, depth));\n\n            var wrapper = _objectSpread$2(_objectSpread$2({}, element), {}, {\n              children: []\n            });\n\n            Transforms.insertNodes(editor, wrapper, {\n              at: wrapperPath,\n              voids\n            });\n            Transforms.moveNodes(editor, {\n              at: range,\n              match: n => Element.isAncestor(commonNode) && commonNode.children.includes(n),\n              to: wrapperPath.concat(0),\n              voids\n            });\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n      }\n    });\n  }\n\n};\n\nvar hasSingleChildNest = (editor, node) => {\n  if (Element.isElement(node)) {\n    var element = node;\n\n    if (Editor.isVoid(editor, node)) {\n      return true;\n    } else if (element.children.length === 1) {\n      return hasSingleChildNest(editor, element.children[0]);\n    } else {\n      return false;\n    }\n  } else if (Editor.isEditor(node)) {\n    return false;\n  } else {\n    return true;\n  }\n};\n/**\r\n * Convert a range into a point by deleting it's content.\r\n */\n\n\nvar deleteRange = (editor, range) => {\n  if (Range.isCollapsed(range)) {\n    return range.anchor;\n  } else {\n    var [, end] = Range.edges(range);\n    var pointRef = Editor.pointRef(editor, end);\n    Transforms.delete(editor, {\n      at: range\n    });\n    return pointRef.unref();\n  }\n};\n\nvar matchPath = (editor, path) => {\n  var [node] = Editor.node(editor, path);\n  return n => n === node;\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys$1(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nvar SelectionTransforms = {\n  /**\r\n   * Collapse the selection.\r\n   */\n  collapse(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      edge = 'anchor'\n    } = options;\n    var {\n      selection\n    } = editor;\n\n    if (!selection) {\n      return;\n    } else if (edge === 'anchor') {\n      Transforms.select(editor, selection.anchor);\n    } else if (edge === 'focus') {\n      Transforms.select(editor, selection.focus);\n    } else if (edge === 'start') {\n      var [start] = Range.edges(selection);\n      Transforms.select(editor, start);\n    } else if (edge === 'end') {\n      var [, end] = Range.edges(selection);\n      Transforms.select(editor, end);\n    }\n  },\n\n  /**\r\n   * Unset the selection.\r\n   */\n  deselect(editor) {\n    var {\n      selection\n    } = editor;\n\n    if (selection) {\n      editor.apply({\n        type: 'set_selection',\n        properties: selection,\n        newProperties: null\n      });\n    }\n  },\n\n  /**\r\n   * Move the selection's point forward or backward.\r\n   */\n  move(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var {\n      selection\n    } = editor;\n    var {\n      distance = 1,\n      unit = 'character',\n      reverse = false\n    } = options;\n    var {\n      edge = null\n    } = options;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var {\n      anchor,\n      focus\n    } = selection;\n    var opts = {\n      distance,\n      unit\n    };\n    var props = {};\n\n    if (edge == null || edge === 'anchor') {\n      var point = reverse ? Editor.before(editor, anchor, opts) : Editor.after(editor, anchor, opts);\n\n      if (point) {\n        props.anchor = point;\n      }\n    }\n\n    if (edge == null || edge === 'focus') {\n      var _point = reverse ? Editor.before(editor, focus, opts) : Editor.after(editor, focus, opts);\n\n      if (_point) {\n        props.focus = _point;\n      }\n    }\n\n    Transforms.setSelection(editor, props);\n  },\n\n  /**\r\n   * Set the selection to a new value.\r\n   */\n  select(editor, target) {\n    var {\n      selection\n    } = editor;\n    target = Editor.range(editor, target);\n\n    if (selection) {\n      Transforms.setSelection(editor, target);\n      return;\n    }\n\n    if (!Range.isRange(target)) {\n      throw new Error(\"When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: \".concat(Scrubber.stringify(target)));\n    }\n\n    editor.apply({\n      type: 'set_selection',\n      properties: selection,\n      newProperties: target\n    });\n  },\n\n  /**\r\n   * Set new properties on one of the selection's points.\r\n   */\n  setPoint(editor, props) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var {\n      selection\n    } = editor;\n    var {\n      edge = 'both'\n    } = options;\n\n    if (!selection) {\n      return;\n    }\n\n    if (edge === 'start') {\n      edge = Range.isBackward(selection) ? 'focus' : 'anchor';\n    }\n\n    if (edge === 'end') {\n      edge = Range.isBackward(selection) ? 'anchor' : 'focus';\n    }\n\n    var {\n      anchor,\n      focus\n    } = selection;\n    var point = edge === 'anchor' ? anchor : focus;\n    Transforms.setSelection(editor, {\n      [edge === 'anchor' ? 'anchor' : 'focus']: _objectSpread$1(_objectSpread$1({}, point), props)\n    });\n  },\n\n  /**\r\n   * Set new properties on the selection.\r\n   */\n  setSelection(editor, props) {\n    var {\n      selection\n    } = editor;\n    var oldProps = {};\n    var newProps = {};\n\n    if (!selection) {\n      return;\n    }\n\n    for (var k in props) {\n      if (k === 'anchor' && props.anchor != null && !Point.equals(props.anchor, selection.anchor) || k === 'focus' && props.focus != null && !Point.equals(props.focus, selection.focus) || k !== 'anchor' && k !== 'focus' && props[k] !== selection[k]) {\n        oldProps[k] = selection[k];\n        newProps[k] = props[k];\n      }\n    }\n\n    if (Object.keys(oldProps).length > 0) {\n      editor.apply({\n        type: 'set_selection',\n        properties: oldProps,\n        newProperties: newProps\n      });\n    }\n  }\n\n};\n\nvar TextTransforms = {\n  /**\r\n   * Delete content in the editor.\r\n   */\n  delete(editor) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        reverse = false,\n        unit = 'character',\n        distance = 1,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection,\n        hanging = false\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      var isCollapsed = false;\n\n      if (Range.isRange(at) && Range.isCollapsed(at)) {\n        isCollapsed = true;\n        at = at.anchor;\n      }\n\n      if (Point.isPoint(at)) {\n        var furthestVoid = Editor.void(editor, {\n          at,\n          mode: 'highest'\n        });\n\n        if (!voids && furthestVoid) {\n          var [, voidPath] = furthestVoid;\n          at = voidPath;\n        } else {\n          var opts = {\n            unit,\n            distance\n          };\n          var target = reverse ? Editor.before(editor, at, opts) || Editor.start(editor, []) : Editor.after(editor, at, opts) || Editor.end(editor, []);\n          at = {\n            anchor: at,\n            focus: target\n          };\n          hanging = true;\n        }\n      }\n\n      if (Path.isPath(at)) {\n        Transforms.removeNodes(editor, {\n          at,\n          voids\n        });\n        return;\n      }\n\n      if (Range.isCollapsed(at)) {\n        return;\n      }\n\n      if (!hanging) {\n        var [, _end] = Range.edges(at);\n        var endOfDoc = Editor.end(editor, []);\n\n        if (!Point.equals(_end, endOfDoc)) {\n          at = Editor.unhangRange(editor, at, {\n            voids\n          });\n        }\n      }\n\n      var [start, end] = Range.edges(at);\n      var startBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: start,\n        voids\n      });\n      var endBlock = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at: end,\n        voids\n      });\n      var isAcrossBlocks = startBlock && endBlock && !Path.equals(startBlock[1], endBlock[1]);\n      var isSingleText = Path.equals(start.path, end.path);\n      var startVoid = voids ? null : Editor.void(editor, {\n        at: start,\n        mode: 'highest'\n      });\n      var endVoid = voids ? null : Editor.void(editor, {\n        at: end,\n        mode: 'highest'\n      }); // If the start or end points are inside an inline void, nudge them out.\n\n      if (startVoid) {\n        var before = Editor.before(editor, start);\n\n        if (before && startBlock && Path.isAncestor(startBlock[1], before.path)) {\n          start = before;\n        }\n      }\n\n      if (endVoid) {\n        var after = Editor.after(editor, end);\n\n        if (after && endBlock && Path.isAncestor(endBlock[1], after.path)) {\n          end = after;\n        }\n      } // Get the highest nodes that are completely inside the range, as well as\n      // the start and end nodes.\n\n\n      var matches = [];\n      var lastPath;\n\n      for (var entry of Editor.nodes(editor, {\n        at,\n        voids\n      })) {\n        var [node, path] = entry;\n\n        if (lastPath && Path.compare(path, lastPath) === 0) {\n          continue;\n        }\n\n        if (!voids && Editor.isVoid(editor, node) || !Path.isCommon(path, start.path) && !Path.isCommon(path, end.path)) {\n          matches.push(entry);\n          lastPath = path;\n        }\n      }\n\n      var pathRefs = Array.from(matches, _ref => {\n        var [, p] = _ref;\n        return Editor.pathRef(editor, p);\n      });\n      var startRef = Editor.pointRef(editor, start);\n      var endRef = Editor.pointRef(editor, end);\n      var removedText = '';\n\n      if (!isSingleText && !startVoid) {\n        var _point = startRef.current;\n        var [_node] = Editor.leaf(editor, _point);\n        var {\n          path: _path\n        } = _point;\n        var {\n          offset\n        } = start;\n\n        var text = _node.text.slice(offset);\n\n        if (text.length > 0) {\n          editor.apply({\n            type: 'remove_text',\n            path: _path,\n            offset,\n            text\n          });\n          removedText = text;\n        }\n      }\n\n      for (var pathRef of pathRefs) {\n        var _path2 = pathRef.unref();\n\n        Transforms.removeNodes(editor, {\n          at: _path2,\n          voids\n        });\n      }\n\n      if (!endVoid) {\n        var _point2 = endRef.current;\n        var [_node2] = Editor.leaf(editor, _point2);\n        var {\n          path: _path3\n        } = _point2;\n\n        var _offset = isSingleText ? start.offset : 0;\n\n        var _text = _node2.text.slice(_offset, end.offset);\n\n        if (_text.length > 0) {\n          editor.apply({\n            type: 'remove_text',\n            path: _path3,\n            offset: _offset,\n            text: _text\n          });\n          removedText = _text;\n        }\n      }\n\n      if (!isSingleText && isAcrossBlocks && endRef.current && startRef.current) {\n        Transforms.mergeNodes(editor, {\n          at: endRef.current,\n          hanging: true,\n          voids\n        });\n      } // For Thai script, deleting N character(s) backward should delete\n      // N code point(s) instead of an entire grapheme cluster.\n      // Therefore, the remaining code points should be inserted back.\n\n\n      if (isCollapsed && reverse && unit === 'character' && removedText.length > 1 && removedText.match(/[\\u0E00-\\u0E7F]+/)) {\n        Transforms.insertText(editor, removedText.slice(0, removedText.length - distance));\n      }\n\n      var startUnref = startRef.unref();\n      var endUnref = endRef.unref();\n      var point = reverse ? startUnref || endUnref : endUnref || startUnref;\n\n      if (options.at == null && point) {\n        Transforms.select(editor, point);\n      }\n    });\n  },\n\n  /**\r\n   * Insert a fragment at a specific location in the editor.\r\n   */\n  insertFragment(editor, fragment) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        hanging = false,\n        voids = false\n      } = options;\n      var {\n        at = editor.selection\n      } = options;\n\n      if (!fragment.length) {\n        return;\n      }\n\n      if (!at) {\n        return;\n      } else if (Range.isRange(at)) {\n        if (!hanging) {\n          at = Editor.unhangRange(editor, at);\n        }\n\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var [, end] = Range.edges(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var pointRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at\n          });\n          at = pointRef.unref();\n        }\n      } else if (Path.isPath(at)) {\n        at = Editor.start(editor, at);\n      }\n\n      if (!voids && Editor.void(editor, {\n        at\n      })) {\n        return;\n      } // If the insert point is at the edge of an inline node, move it outside\n      // instead since it will need to be split otherwise.\n\n\n      var inlineElementMatch = Editor.above(editor, {\n        at,\n        match: n => Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (inlineElementMatch) {\n        var [, _inlinePath] = inlineElementMatch;\n\n        if (Editor.isEnd(editor, at, _inlinePath)) {\n          var after = Editor.after(editor, _inlinePath);\n          at = after;\n        } else if (Editor.isStart(editor, at, _inlinePath)) {\n          var before = Editor.before(editor, _inlinePath);\n          at = before;\n        }\n      }\n\n      var blockMatch = Editor.above(editor, {\n        match: n => Editor.isBlock(editor, n),\n        at,\n        voids\n      });\n      var [, blockPath] = blockMatch;\n      var isBlockStart = Editor.isStart(editor, at, blockPath);\n      var isBlockEnd = Editor.isEnd(editor, at, blockPath);\n      var isBlockEmpty = isBlockStart && isBlockEnd;\n      var mergeStart = !isBlockStart || isBlockStart && isBlockEnd;\n      var mergeEnd = !isBlockEnd;\n      var [, firstPath] = Node.first({\n        children: fragment\n      }, []);\n      var [, lastPath] = Node.last({\n        children: fragment\n      }, []);\n      var matches = [];\n\n      var matcher = _ref2 => {\n        var [n, p] = _ref2;\n        var isRoot = p.length === 0;\n\n        if (isRoot) {\n          return false;\n        }\n\n        if (isBlockEmpty) {\n          return true;\n        }\n\n        if (mergeStart && Path.isAncestor(p, firstPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        if (mergeEnd && Path.isAncestor(p, lastPath) && Element.isElement(n) && !editor.isVoid(n) && !editor.isInline(n)) {\n          return false;\n        }\n\n        return true;\n      };\n\n      for (var entry of Node.nodes({\n        children: fragment\n      }, {\n        pass: matcher\n      })) {\n        if (matcher(entry)) {\n          matches.push(entry);\n        }\n      }\n\n      var starts = [];\n      var middles = [];\n      var ends = [];\n      var starting = true;\n      var hasBlocks = false;\n\n      for (var [node] of matches) {\n        if (Element.isElement(node) && !editor.isInline(node)) {\n          starting = false;\n          hasBlocks = true;\n          middles.push(node);\n        } else if (starting) {\n          starts.push(node);\n        } else {\n          ends.push(node);\n        }\n      }\n\n      var [inlineMatch] = Editor.nodes(editor, {\n        at,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n      var [, inlinePath] = inlineMatch;\n      var isInlineStart = Editor.isStart(editor, at, inlinePath);\n      var isInlineEnd = Editor.isEnd(editor, at, inlinePath);\n      var middleRef = Editor.pathRef(editor, isBlockEnd && !ends.length ? Path.next(blockPath) : blockPath);\n      var endRef = Editor.pathRef(editor, isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.splitNodes(editor, {\n        at,\n        match: n => hasBlocks ? Editor.isBlock(editor, n) : Text.isText(n) || Editor.isInline(editor, n),\n        mode: hasBlocks ? 'lowest' : 'highest',\n        always: hasBlocks && (!isBlockStart || starts.length > 0) && (!isBlockEnd || ends.length > 0),\n        voids\n      });\n      var startRef = Editor.pathRef(editor, !isInlineStart || isInlineStart && isInlineEnd ? Path.next(inlinePath) : inlinePath);\n      Transforms.insertNodes(editor, starts, {\n        at: startRef.current,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (isBlockEmpty && !starts.length && middles.length && !ends.length) {\n        Transforms.delete(editor, {\n          at: blockPath,\n          voids\n        });\n      }\n\n      Transforms.insertNodes(editor, middles, {\n        at: middleRef.current,\n        match: n => Editor.isBlock(editor, n),\n        mode: 'lowest',\n        voids\n      });\n      Transforms.insertNodes(editor, ends, {\n        at: endRef.current,\n        match: n => Text.isText(n) || Editor.isInline(editor, n),\n        mode: 'highest',\n        voids\n      });\n\n      if (!options.at) {\n        var path;\n\n        if (ends.length > 0 && endRef.current) {\n          path = Path.previous(endRef.current);\n        } else if (middles.length > 0 && middleRef.current) {\n          path = Path.previous(middleRef.current);\n        } else if (startRef.current) {\n          path = Path.previous(startRef.current);\n        }\n\n        if (path) {\n          var _end2 = Editor.end(editor, path);\n\n          Transforms.select(editor, _end2);\n        }\n      }\n\n      startRef.unref();\n      middleRef.unref();\n      endRef.unref();\n    });\n  },\n\n  /**\r\n   * Insert a string of text in the Editor.\r\n   */\n  insertText(editor, text) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    Editor.withoutNormalizing(editor, () => {\n      var {\n        voids = false\n      } = options;\n      var {\n        at = editor.selection\n      } = options;\n\n      if (!at) {\n        return;\n      }\n\n      if (Path.isPath(at)) {\n        at = Editor.range(editor, at);\n      }\n\n      if (Range.isRange(at)) {\n        if (Range.isCollapsed(at)) {\n          at = at.anchor;\n        } else {\n          var end = Range.end(at);\n\n          if (!voids && Editor.void(editor, {\n            at: end\n          })) {\n            return;\n          }\n\n          var start = Range.start(at);\n          var startRef = Editor.pointRef(editor, start);\n          var endRef = Editor.pointRef(editor, end);\n          Transforms.delete(editor, {\n            at,\n            voids\n          });\n          var startPoint = startRef.unref();\n          var endPoint = endRef.unref();\n          at = startPoint || endPoint;\n          Transforms.setSelection(editor, {\n            anchor: at,\n            focus: at\n          });\n        }\n      }\n\n      if (!voids && Editor.void(editor, {\n        at\n      })) {\n        return;\n      }\n\n      var {\n        path,\n        offset\n      } = at;\n      if (text.length > 0) editor.apply({\n        type: 'insert_text',\n        path,\n        offset,\n        text\n      });\n    });\n  }\n\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\nvar Transforms = _objectSpread(_objectSpread(_objectSpread(_objectSpread({}, GeneralTransforms), NodeTransforms), SelectionTransforms), TextTransforms);\n\n\n//# sourceMappingURL=index.es.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vc2xhdGVAMC44Mi4wL25vZGVfbW9kdWxlcy9zbGF0ZS9kaXN0L2luZGV4LmVzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFnRDtBQUNtQjs7QUFFbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxtREFBbUQsbUZBQW1GLE9BQU87QUFDNWdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWLHdEQUF3RCw0QkFBNEIsS0FBSztBQUN6RjtBQUNBLFdBQVc7O0FBRVg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVzs7QUFFWDtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFFBQVE7OztBQUdSLHNOQUFzTjtBQUN0Tjs7QUFFQTs7QUFFQSxzQkFBc0IsMEJBQTBCO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwR0FBMEc7QUFDMUc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVix3Q0FBd0MsNEJBQTRCOztBQUVwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTs7QUFFVjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsY0FBYyx1QkFBdUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGdCQUFnQiw2QkFBNkI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjs7QUFFcEIsbUJBQW1COztBQUVuQix1QkFBdUI7O0FBRXZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHNDQUFzQzs7QUFFdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDhEQUFhO0FBQ3RCLEdBQUc7OztBQUdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLDhEQUFhO0FBQ3hCLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBLDZDQUE2QyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFN1UsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSx5REFBeUQsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLG1EQUFtRCxtRkFBbUYsT0FBTztBQUM1Z0IscUNBQXFDOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBLDZFQUE2RSxjQUFjO0FBQzNGO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQSw2RUFBNkUsY0FBYztBQUMzRjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxTQUFTLDhEQUFhO0FBQ3RCO0FBQ0E7O0FBRUEsMHFCQUEwcUIsOERBQWE7QUFDdnJCO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1EQUFtRDs7QUFFbkQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDOzs7QUFHL0M7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjs7QUFFdEI7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQSw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixVQUFVO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCxPQUFPO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0Esb0NBQW9DLG1CQUFtQjtBQUN2RDtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQSxZQUFZOzs7QUFHWjtBQUNBLDREQUE0RDtBQUM1RDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiwyQ0FBMkM7O0FBRTNDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLGNBQWM7QUFDaEY7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDOztBQUV4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxNQUFNO0FBQ047O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCLDhDQUFPO0FBQ3pCO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsaUJBQWlCO0FBQ3JDOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROzs7QUFHUjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7OztBQUdSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxtREFBbUQsbUZBQW1GLE9BQU87O0FBRTVnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyw4REFBYTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0ZBQWdGLDhEQUFhOztBQUU3RjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDBDQUEwQyw4REFBYSxzQkFBc0IsOERBQWE7O0FBRTFGO0FBQ0EscUpBQXFKLDhEQUFhLHNCQUFzQiw4REFBYTs7QUFFck07QUFDQSxnRkFBZ0YsOERBQWE7O0FBRTdGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxTQUFTO0FBQzVEO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxNQUFNOztBQUVsQjtBQUNBO0FBQ0EsWUFBWTtBQUNaOzs7QUFHQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsbURBQW1ELFNBQVM7QUFDNUQ7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWixtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZOztBQUVaO0FBQ0EscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1oscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYixZQUFZO0FBQ1oscURBQXFELFNBQVM7QUFDOUQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUztBQUM1RDtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsdUNBQXVDO0FBQzNEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOOztBQUVBLG9CQUFvQixrQkFBa0I7QUFDdEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBTztBQUNsQjtBQUNBO0FBQ0EsUUFBUSxXQUFXOztBQUVuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYzs7QUFFZDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjOztBQUVkO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixvQ0FBb0M7QUFDcEQ7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxhQUFhOztBQUUzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsNkNBQTZDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELHNCQUFzQiwwQ0FBMEMsaUVBQWlFLEtBQUssa0NBQWtDOztBQUU3VSxtQ0FBbUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHlEQUF5RCw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8sbURBQW1ELG1GQUFtRixPQUFPOztBQUU1Z0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQWE7QUFDeEIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4Q0FBTztBQUNsQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBLG9GQUFvRixjQUFjO0FBQ2xHO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsY0FBYztBQUNkO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBLDZDQUE2QyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFN1UsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSx5REFBeUQsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLG1EQUFtRCxtRkFBbUYsT0FBTzs7QUFFNWdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOERBQWE7QUFDeEIsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOENBQU87QUFDbEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFdBQVc7QUFDMUI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSw4REFBYSxPQUFPLDhEQUFhO0FBQ3pDO0FBQ0EsTUFBTTtBQUNOOztBQUVBLHNCQUFzQixjQUFjO0FBQ3BDO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxtREFBbUQsbUZBQW1GLE9BQU87O0FBRTVnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyw4REFBYTtBQUN4QixHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DOztBQUVwQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7OztBQUdWO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRCxhQUFhO0FBQ2pFO0FBQ0EsV0FBVztBQUNYLHFEQUFxRCxhQUFhO0FBQ2xFO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7O0FBRUEscURBQXFELGFBQWE7QUFDbEU7QUFDQSxXQUFXO0FBQ1gscURBQXFELGFBQWE7QUFDbEU7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQSw2Q0FBNkMsZ0NBQWdDLG9DQUFvQyxvREFBb0Qsc0JBQXNCLDBDQUEwQyxpRUFBaUUsS0FBSyxrQ0FBa0M7O0FBRTdVLG1DQUFtQyxnQkFBZ0Isc0JBQXNCLE9BQU8sdURBQXVELGFBQWEseURBQXlELDRDQUE0QyxLQUFLLDZDQUE2Qyw2RUFBNkUsT0FBTyxtREFBbUQsbUZBQW1GLE9BQU87O0FBRTVnQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUEsOENBQThDO0FBQzlDOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGNBQWM7QUFDZDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxVQUFVOzs7QUFHVjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsMENBQTBDO0FBQzFDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxzREFBc0Qsa0JBQWtCO0FBQ3hFO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjs7QUFFQTs7QUFFQTtBQUNBLHNEQUFzRCxrQkFBa0I7QUFDeEU7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtEQUFXO0FBQ2pDLHdDQUF3QyxrREFBVzs7QUFFbkQ7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0Isa0RBQVc7O0FBRW5DO0FBQ0EsMkJBQTJCLDhDQUFPLGNBQWMsa0RBQVc7QUFDM0QsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsNkNBQTZDLGdDQUFnQyxvQ0FBb0Msb0RBQW9ELHNCQUFzQiwwQ0FBMEMsaUVBQWlFLEtBQUssa0NBQWtDOztBQUU3VSxtQ0FBbUMsZ0JBQWdCLHNCQUFzQixPQUFPLHVEQUF1RCxhQUFhLHlEQUF5RCw0Q0FBNEMsS0FBSyw2Q0FBNkMsNkVBQTZFLE9BQU8sbURBQW1ELG1GQUFtRixPQUFPOztBQUU1Z0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7QUFDMUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVOztBQUVWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU8seUNBQXlDO0FBQ2hEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxnQ0FBZ0M7O0FBRWhDO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLCtCQUErQjs7QUFFL0IsaUVBQWlFOztBQUVqRTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNERBQTRELGNBQWM7QUFDMUU7QUFDQSxhQUFhOztBQUViO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7O0FBRVg7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZDQUE2QyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFN1UsbUNBQW1DLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSx5REFBeUQsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLG1EQUFtRCxtRkFBbUYsT0FBTzs7QUFFNWdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTs7QUFFTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLGtGQUFrRjtBQUNsRixLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7O0FBRVY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVOztBQUVWOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjs7QUFFQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsUUFBUTtBQUNSOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7QUFFUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBOztBQUVBLDJDQUEyQyxnQ0FBZ0Msb0NBQW9DLG9EQUFvRCxzQkFBc0IsMENBQTBDLGlFQUFpRSxLQUFLLGtDQUFrQzs7QUFFM1UsaUNBQWlDLGdCQUFnQixzQkFBc0IsT0FBTyx1REFBdUQsYUFBYSx1REFBdUQsNENBQTRDLEtBQUssNkNBQTZDLDZFQUE2RSxPQUFPLGlEQUFpRCxtRkFBbUYsT0FBTztBQUN0Z0IsMkVBQTJFOztBQUU0RTtBQUN2SiIsInNvdXJjZXMiOlsiL1VzZXJzL21pY2thZWwvRG9jdW1lbnRzL2dhbGFkcmltL3Jpc2UvY21zX3Jlc2VhcmNoL3BheWxvYWQvcmlzZS9ub2RlX21vZHVsZXMvLnBucG0vc2xhdGVAMC44Mi4wL25vZGVfbW9kdWxlcy9zbGF0ZS9kaXN0L2luZGV4LmVzLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGlzUGxhaW5PYmplY3QgfSBmcm9tICdpcy1wbGFpbi1vYmplY3QnO1xuaW1wb3J0IHsgcHJvZHVjZSwgY3JlYXRlRHJhZnQsIGZpbmlzaERyYWZ0LCBpc0RyYWZ0IH0gZnJvbSAnaW1tZXInO1xuXG5mdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxudmFyIERJUlRZX1BBVEhTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBESVJUWV9QQVRIX0tFWVMgPSBuZXcgV2Vha01hcCgpO1xudmFyIEZMVVNISU5HID0gbmV3IFdlYWtNYXAoKTtcbnZhciBOT1JNQUxJWklORyA9IG5ldyBXZWFrTWFwKCk7XG52YXIgUEFUSF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBQT0lOVF9SRUZTID0gbmV3IFdlYWtNYXAoKTtcbnZhciBSQU5HRV9SRUZTID0gbmV3IFdlYWtNYXAoKTtcblxuZnVuY3Rpb24gb3duS2V5cyQ5KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ5KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkOShPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDkoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG4vKipcclxuICogQ3JlYXRlIGEgbmV3IFNsYXRlIGBFZGl0b3JgIG9iamVjdC5cclxuICovXG5cbnZhciBjcmVhdGVFZGl0b3IgPSAoKSA9PiB7XG4gIHZhciBlZGl0b3IgPSB7XG4gICAgY2hpbGRyZW46IFtdLFxuICAgIG9wZXJhdGlvbnM6IFtdLFxuICAgIHNlbGVjdGlvbjogbnVsbCxcbiAgICBtYXJrczogbnVsbCxcbiAgICBpc0lubGluZTogKCkgPT4gZmFsc2UsXG4gICAgaXNWb2lkOiAoKSA9PiBmYWxzZSxcbiAgICBvbkNoYW5nZTogKCkgPT4ge30sXG4gICAgYXBwbHk6IG9wID0+IHtcbiAgICAgIGZvciAodmFyIHJlZiBvZiBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKSkge1xuICAgICAgICBQYXRoUmVmLnRyYW5zZm9ybShyZWYsIG9wKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX3JlZiBvZiBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcikpIHtcbiAgICAgICAgUG9pbnRSZWYudHJhbnNmb3JtKF9yZWYsIG9wKTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX3JlZjIgb2YgRWRpdG9yLnJhbmdlUmVmcyhlZGl0b3IpKSB7XG4gICAgICAgIFJhbmdlUmVmLnRyYW5zZm9ybShfcmVmMiwgb3ApO1xuICAgICAgfVxuXG4gICAgICB2YXIgb2xkRGlydHlQYXRocyA9IERJUlRZX1BBVEhTLmdldChlZGl0b3IpIHx8IFtdO1xuICAgICAgdmFyIG9sZERpcnR5UGF0aEtleXMgPSBESVJUWV9QQVRIX0tFWVMuZ2V0KGVkaXRvcikgfHwgbmV3IFNldCgpO1xuICAgICAgdmFyIGRpcnR5UGF0aHM7XG4gICAgICB2YXIgZGlydHlQYXRoS2V5cztcblxuICAgICAgdmFyIGFkZCA9IHBhdGggPT4ge1xuICAgICAgICBpZiAocGF0aCkge1xuICAgICAgICAgIHZhciBrZXkgPSBwYXRoLmpvaW4oJywnKTtcblxuICAgICAgICAgIGlmICghZGlydHlQYXRoS2V5cy5oYXMoa2V5KSkge1xuICAgICAgICAgICAgZGlydHlQYXRoS2V5cy5hZGQoa2V5KTtcbiAgICAgICAgICAgIGRpcnR5UGF0aHMucHVzaChwYXRoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIGlmIChQYXRoLm9wZXJhdGlvbkNhblRyYW5zZm9ybVBhdGgob3ApKSB7XG4gICAgICAgIGRpcnR5UGF0aHMgPSBbXTtcbiAgICAgICAgZGlydHlQYXRoS2V5cyA9IG5ldyBTZXQoKTtcblxuICAgICAgICBmb3IgKHZhciBwYXRoIG9mIG9sZERpcnR5UGF0aHMpIHtcbiAgICAgICAgICB2YXIgbmV3UGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wKTtcbiAgICAgICAgICBhZGQobmV3UGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRpcnR5UGF0aHMgPSBvbGREaXJ0eVBhdGhzO1xuICAgICAgICBkaXJ0eVBhdGhLZXlzID0gb2xkRGlydHlQYXRoS2V5cztcbiAgICAgIH1cblxuICAgICAgdmFyIG5ld0RpcnR5UGF0aHMgPSBnZXREaXJ0eVBhdGhzKG9wKTtcblxuICAgICAgZm9yICh2YXIgX3BhdGggb2YgbmV3RGlydHlQYXRocykge1xuICAgICAgICBhZGQoX3BhdGgpO1xuICAgICAgfVxuXG4gICAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhzKTtcbiAgICAgIERJUlRZX1BBVEhfS0VZUy5zZXQoZWRpdG9yLCBkaXJ0eVBhdGhLZXlzKTtcbiAgICAgIFRyYW5zZm9ybXMudHJhbnNmb3JtKGVkaXRvciwgb3ApO1xuICAgICAgZWRpdG9yLm9wZXJhdGlvbnMucHVzaChvcCk7XG4gICAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7IC8vIENsZWFyIGFueSBmb3JtYXRzIGFwcGxpZWQgdG8gdGhlIGN1cnNvciBpZiB0aGUgc2VsZWN0aW9uIGNoYW5nZXMuXG5cbiAgICAgIGlmIChvcC50eXBlID09PSAnc2V0X3NlbGVjdGlvbicpIHtcbiAgICAgICAgZWRpdG9yLm1hcmtzID0gbnVsbDtcbiAgICAgIH1cblxuICAgICAgaWYgKCFGTFVTSElORy5nZXQoZWRpdG9yKSkge1xuICAgICAgICBGTFVTSElORy5zZXQoZWRpdG9yLCB0cnVlKTtcbiAgICAgICAgUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgRkxVU0hJTkcuc2V0KGVkaXRvciwgZmFsc2UpO1xuICAgICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIGVkaXRvci5vcGVyYXRpb25zID0gW107XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgYWRkTWFyazogKGtleSwgdmFsdWUpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHNlbGVjdGlvblxuICAgICAgfSA9IGVkaXRvcjtcblxuICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIFtrZXldOiB2YWx1ZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ5KF9vYmplY3RTcHJlYWQkOSh7fSwgRWRpdG9yLm1hcmtzKGVkaXRvcikgfHwge30pLCB7fSwge1xuICAgICAgICAgICAgW2tleV06IHZhbHVlXG4gICAgICAgICAgfSk7XG5cbiAgICAgICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcblxuICAgICAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlQmFja3dhcmQ6IHVuaXQgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uICYmIFJhbmdlLmlzQ29sbGFwc2VkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgdW5pdCxcbiAgICAgICAgICByZXZlcnNlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlRm9yd2FyZDogdW5pdCA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNDb2xsYXBzZWQoc2VsZWN0aW9uKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICB1bml0XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0sXG4gICAgZGVsZXRlRnJhZ21lbnQ6IGRpcmVjdGlvbiA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24gJiYgUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgIHJldmVyc2U6IGRpcmVjdGlvbiA9PT0gJ2JhY2t3YXJkJ1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldEZyYWdtZW50OiAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb25cbiAgICAgIH0gPSBlZGl0b3I7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIE5vZGUuZnJhZ21lbnQoZWRpdG9yLCBzZWxlY3Rpb24pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gW107XG4gICAgfSxcbiAgICBpbnNlcnRCcmVhazogKCkgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICBhbHdheXM6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sXG4gICAgaW5zZXJ0U29mdEJyZWFrOiAoKSA9PiB7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGFsd2F5czogdHJ1ZVxuICAgICAgfSk7XG4gICAgfSxcbiAgICBpbnNlcnRGcmFnbWVudDogZnJhZ21lbnQgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRGcmFnbWVudChlZGl0b3IsIGZyYWdtZW50KTtcbiAgICB9LFxuICAgIGluc2VydE5vZGU6IG5vZGUgPT4ge1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIG5vZGUpO1xuICAgIH0sXG4gICAgaW5zZXJ0VGV4dDogdGV4dCA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBzZWxlY3Rpb24sXG4gICAgICAgIG1hcmtzXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChtYXJrcykge1xuICAgICAgICAgIHZhciBub2RlID0gX29iamVjdFNwcmVhZCQ5KHtcbiAgICAgICAgICAgIHRleHRcbiAgICAgICAgICB9LCBtYXJrcyk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbm9kZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnRUZXh0KGVkaXRvciwgdGV4dCk7XG4gICAgICAgIH1cblxuICAgICAgICBlZGl0b3IubWFya3MgPSBudWxsO1xuICAgICAgfVxuICAgIH0sXG4gICAgbm9ybWFsaXplTm9kZTogZW50cnkgPT4ge1xuICAgICAgdmFyIFtub2RlLCBwYXRoXSA9IGVudHJ5OyAvLyBUaGVyZSBhcmUgbm8gY29yZSBub3JtYWxpemF0aW9ucyBmb3IgdGV4dCBub2Rlcy5cblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gLy8gRW5zdXJlIHRoYXQgYmxvY2sgYW5kIGlubGluZSBub2RlcyBoYXZlIGF0IGxlYXN0IG9uZSB0ZXh0IGNoaWxkLlxuXG5cbiAgICAgIGlmIChFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICB2YXIgY2hpbGQgPSB7XG4gICAgICAgICAgdGV4dDogJydcbiAgICAgICAgfTtcbiAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIGNoaWxkLCB7XG4gICAgICAgICAgYXQ6IHBhdGguY29uY2F0KDApLFxuICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm47XG4gICAgICB9IC8vIERldGVybWluZSB3aGV0aGVyIHRoZSBub2RlIHNob3VsZCBoYXZlIGJsb2NrIG9yIGlubGluZSBjaGlsZHJlbi5cblxuXG4gICAgICB2YXIgc2hvdWxkSGF2ZUlubGluZXMgPSBFZGl0b3IuaXNFZGl0b3Iobm9kZSkgPyBmYWxzZSA6IEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIChlZGl0b3IuaXNJbmxpbmUobm9kZSkgfHwgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDAgfHwgVGV4dC5pc1RleHQobm9kZS5jaGlsZHJlblswXSkgfHwgZWRpdG9yLmlzSW5saW5lKG5vZGUuY2hpbGRyZW5bMF0pKTsgLy8gU2luY2Ugd2UnbGwgYmUgYXBwbHlpbmcgb3BlcmF0aW9ucyB3aGlsZSBpdGVyYXRpbmcsIGtlZXAgdHJhY2sgb2YgYW5cbiAgICAgIC8vIGluZGV4IHRoYXQgYWNjb3VudHMgZm9yIGFueSBhZGRlZC9yZW1vdmVkIG5vZGVzLlxuXG4gICAgICB2YXIgbiA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkrKywgbisrKSB7XG4gICAgICAgIHZhciBjdXJyZW50Tm9kZSA9IE5vZGUuZ2V0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChjdXJyZW50Tm9kZSkpIGNvbnRpbnVlO1xuICAgICAgICB2YXIgX2NoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgdmFyIHByZXYgPSBjdXJyZW50Tm9kZS5jaGlsZHJlbltuIC0gMV07XG4gICAgICAgIHZhciBpc0xhc3QgPSBpID09PSBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIHZhciBpc0lubGluZU9yVGV4dCA9IFRleHQuaXNUZXh0KF9jaGlsZCkgfHwgRWxlbWVudC5pc0VsZW1lbnQoX2NoaWxkKSAmJiBlZGl0b3IuaXNJbmxpbmUoX2NoaWxkKTsgLy8gT25seSBhbGxvdyBibG9jayBub2RlcyBpbiB0aGUgdG9wLWxldmVsIGNoaWxkcmVuIGFuZCBwYXJlbnQgYmxvY2tzXG4gICAgICAgIC8vIHRoYXQgb25seSBjb250YWluIGJsb2NrIG5vZGVzLiBTaW1pbGFybHksIG9ubHkgYWxsb3cgaW5saW5lIG5vZGVzIGluXG4gICAgICAgIC8vIG90aGVyIGlubGluZSBub2Rlcywgb3IgcGFyZW50IGJsb2NrcyB0aGF0IG9ubHkgY29udGFpbiBpbmxpbmVzIGFuZFxuICAgICAgICAvLyB0ZXh0LlxuXG4gICAgICAgIGlmIChpc0lubGluZU9yVGV4dCAhPT0gc2hvdWxkSGF2ZUlubGluZXMpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBuLS07XG4gICAgICAgIH0gZWxzZSBpZiAoRWxlbWVudC5pc0VsZW1lbnQoX2NoaWxkKSkge1xuICAgICAgICAgIC8vIEVuc3VyZSB0aGF0IGlubGluZSBub2RlcyBhcmUgc3Vycm91bmRlZCBieSB0ZXh0IG5vZGVzLlxuICAgICAgICAgIGlmIChlZGl0b3IuaXNJbmxpbmUoX2NoaWxkKSkge1xuICAgICAgICAgICAgaWYgKHByZXYgPT0gbnVsbCB8fCAhVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgICAgdmFyIG5ld0NoaWxkID0ge1xuICAgICAgICAgICAgICAgIHRleHQ6ICcnXG4gICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCBuZXdDaGlsZCwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpc0xhc3QpIHtcbiAgICAgICAgICAgICAgdmFyIF9uZXdDaGlsZCA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiAnJ1xuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgX25ld0NoaWxkLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4gKyAxKSxcbiAgICAgICAgICAgICAgICB2b2lkczogdHJ1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgbisrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBNZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzIHRoYXQgYXJlIGVtcHR5IG9yIG1hdGNoLlxuICAgICAgICAgIGlmIChwcmV2ICE9IG51bGwgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICAgIGlmIChUZXh0LmVxdWFscyhfY2hpbGQsIHByZXYsIHtcbiAgICAgICAgICAgICAgbG9vc2U6IHRydWVcbiAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgICBhdDogcGF0aC5jb25jYXQobiksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJldi50ZXh0ID09PSAnJykge1xuICAgICAgICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgICAgICAgIGF0OiBwYXRoLmNvbmNhdChuIC0gMSksXG4gICAgICAgICAgICAgICAgdm9pZHM6IHRydWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIG4tLTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoX2NoaWxkLnRleHQgPT09ICcnKSB7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICAgICAgYXQ6IHBhdGguY29uY2F0KG4pLFxuICAgICAgICAgICAgICAgIHZvaWRzOiB0cnVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBuLS07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICByZW1vdmVNYXJrOiBrZXkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgc2VsZWN0aW9uXG4gICAgICB9ID0gZWRpdG9yO1xuXG4gICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0V4cGFuZGVkKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnVuc2V0Tm9kZXMoZWRpdG9yLCBrZXksIHtcbiAgICAgICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgICAgICAgIHNwbGl0OiB0cnVlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIG1hcmtzID0gX29iamVjdFNwcmVhZCQ5KHt9LCBFZGl0b3IubWFya3MoZWRpdG9yKSB8fCB7fSk7XG5cbiAgICAgICAgICBkZWxldGUgbWFya3Nba2V5XTtcbiAgICAgICAgICBlZGl0b3IubWFya3MgPSBtYXJrcztcblxuICAgICAgICAgIGlmICghRkxVU0hJTkcuZ2V0KGVkaXRvcikpIHtcbiAgICAgICAgICAgIGVkaXRvci5vbkNoYW5nZSgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgcmV0dXJuIGVkaXRvcjtcbn07XG4vKipcclxuICogR2V0IHRoZSBcImRpcnR5XCIgcGF0aHMgZ2VuZXJhdGVkIGZyb20gYW4gb3BlcmF0aW9uLlxyXG4gKi9cblxudmFyIGdldERpcnR5UGF0aHMgPSBvcCA9PiB7XG4gIHN3aXRjaCAob3AudHlwZSkge1xuICAgIGNhc2UgJ2luc2VydF90ZXh0JzpcbiAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGhcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICByZXR1cm4gUGF0aC5sZXZlbHMocGF0aCk7XG4gICAgICB9XG5cbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbm9kZSxcbiAgICAgICAgICBwYXRoOiBfcGF0aDJcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgbGV2ZWxzID0gUGF0aC5sZXZlbHMoX3BhdGgyKTtcbiAgICAgICAgdmFyIGRlc2NlbmRhbnRzID0gVGV4dC5pc1RleHQobm9kZSkgPyBbXSA6IEFycmF5LmZyb20oTm9kZS5ub2Rlcyhub2RlKSwgX3JlZjMgPT4ge1xuICAgICAgICAgIHZhciBbLCBwXSA9IF9yZWYzO1xuICAgICAgICAgIHJldHVybiBfcGF0aDIuY29uY2F0KHApO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFsuLi5sZXZlbHMsIC4uLmRlc2NlbmRhbnRzXTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoM1xuICAgICAgICB9ID0gb3A7XG4gICAgICAgIHZhciBhbmNlc3RvcnMgPSBQYXRoLmFuY2VzdG9ycyhfcGF0aDMpO1xuICAgICAgICB2YXIgcHJldmlvdXNQYXRoID0gUGF0aC5wcmV2aW91cyhfcGF0aDMpO1xuICAgICAgICByZXR1cm4gWy4uLmFuY2VzdG9ycywgcHJldmlvdXNQYXRoXTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg0LFxuICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChQYXRoLmVxdWFscyhfcGF0aDQsIG5ld1BhdGgpKSB7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG9sZEFuY2VzdG9ycyA9IFtdO1xuICAgICAgICB2YXIgbmV3QW5jZXN0b3JzID0gW107XG5cbiAgICAgICAgZm9yICh2YXIgYW5jZXN0b3Igb2YgUGF0aC5hbmNlc3RvcnMoX3BhdGg0KSkge1xuICAgICAgICAgIHZhciBwID0gUGF0aC50cmFuc2Zvcm0oYW5jZXN0b3IsIG9wKTtcbiAgICAgICAgICBvbGRBbmNlc3RvcnMucHVzaChwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIF9hbmNlc3RvciBvZiBQYXRoLmFuY2VzdG9ycyhuZXdQYXRoKSkge1xuICAgICAgICAgIHZhciBfcCA9IFBhdGgudHJhbnNmb3JtKF9hbmNlc3Rvciwgb3ApO1xuXG4gICAgICAgICAgbmV3QW5jZXN0b3JzLnB1c2goX3ApO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG5ld1BhcmVudCA9IG5ld0FuY2VzdG9yc1tuZXdBbmNlc3RvcnMubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuZXdJbmRleCA9IG5ld1BhdGhbbmV3UGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJlc3VsdFBhdGggPSBuZXdQYXJlbnQuY29uY2F0KG5ld0luZGV4KTtcbiAgICAgICAgcmV0dXJuIFsuLi5vbGRBbmNlc3RvcnMsIC4uLm5ld0FuY2VzdG9ycywgcmVzdWx0UGF0aF07XG4gICAgICB9XG5cbiAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGg1XG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICB2YXIgX2FuY2VzdG9ycyA9IFBhdGguYW5jZXN0b3JzKF9wYXRoNSk7XG5cbiAgICAgICAgcmV0dXJuIFsuLi5fYW5jZXN0b3JzXTtcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNlxuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgdmFyIF9sZXZlbHMgPSBQYXRoLmxldmVscyhfcGF0aDYpO1xuXG4gICAgICAgIHZhciBuZXh0UGF0aCA9IFBhdGgubmV4dChfcGF0aDYpO1xuICAgICAgICByZXR1cm4gWy4uLl9sZXZlbHMsIG5leHRQYXRoXTtcbiAgICAgIH1cblxuICAgIGRlZmF1bHQ6XG4gICAgICB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCkge1xuICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgdmFyIHRhcmdldCA9IHt9O1xuICB2YXIgc291cmNlS2V5cyA9IE9iamVjdC5rZXlzKHNvdXJjZSk7XG4gIHZhciBrZXksIGk7XG5cbiAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICBrZXkgPSBzb3VyY2VLZXlzW2ldO1xuICAgIGlmIChleGNsdWRlZC5pbmRleE9mKGtleSkgPj0gMCkgY29udGludWU7XG4gICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhzb3VyY2UsIGV4Y2x1ZGVkKSB7XG4gIGlmIChzb3VyY2UgPT0gbnVsbCkgcmV0dXJuIHt9O1xuICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gIHZhciBrZXksIGk7XG5cbiAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBzb3VyY2VTeW1ib2xLZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBzb3VyY2VTeW1ib2xLZXlzW2ldO1xuICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHNvdXJjZSwga2V5KSkgY29udGludWU7XG4gICAgICB0YXJnZXRba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0YXJnZXQ7XG59XG5cbi8vIENoYXJhY3RlciAoZ3JhcGhlbWUgY2x1c3RlcikgYm91bmRhcmllcyBhcmUgZGV0ZXJtaW5lZCBhY2NvcmRpbmcgdG9cbi8vIHRoZSBkZWZhdWx0IGdyYXBoZW1lIGNsdXN0ZXIgYm91bmRhcnkgc3BlY2lmaWNhdGlvbiwgZXh0ZW5kZWQgZ3JhcGhlbWUgY2x1c3RlcnMgdmFyaWFudFsxXS5cbi8vXG4vLyBSZWZlcmVuY2VzOlxuLy9cbi8vIFsxXSBodHRwczovL3d3dy51bmljb2RlLm9yZy9yZXBvcnRzL3RyMjkvI0RlZmF1bHRfR3JhcGhlbWVfQ2x1c3Rlcl9UYWJsZVxuLy8gWzJdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Byb3BlcnR5LnR4dFxuLy8gWzNdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QuaHRtbFxuLy8gWzRdIGh0dHBzOi8vd3d3LnVuaWNvZGUub3JnL1B1YmxpYy9VQ0QvbGF0ZXN0L3VjZC9hdXhpbGlhcnkvR3JhcGhlbWVCcmVha1Rlc3QudHh0XG5cbi8qKlxyXG4gKiBHZXQgdGhlIGRpc3RhbmNlIHRvIHRoZSBlbmQgb2YgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiBhIHN0cmluZyBvZiB0ZXh0LlxyXG4gKi9cbnZhciBnZXRDaGFyYWN0ZXJEaXN0YW5jZSA9IGZ1bmN0aW9uIGdldENoYXJhY3RlckRpc3RhbmNlKHN0cikge1xuICB2YXIgaXNSVEwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IGZhbHNlO1xuICB2YXIgaXNMVFIgPSAhaXNSVEw7XG4gIHZhciBjb2RlcG9pbnRzID0gaXNSVEwgPyBjb2RlcG9pbnRzSXRlcmF0b3JSVEwoc3RyKSA6IHN0cjtcbiAgdmFyIGxlZnQgPSBDb2RlcG9pbnRUeXBlLk5vbmU7XG4gIHZhciByaWdodCA9IENvZGVwb2ludFR5cGUuTm9uZTtcbiAgdmFyIGRpc3RhbmNlID0gMDsgLy8gRXZhbHVhdGlvbiBvZiB0aGVzZSBjb25kaXRpb25zIGFyZSBkZWZlcnJlZC5cblxuICB2YXIgZ2IxMSA9IG51bGw7IC8vIElzIEdCMTEgYXBwbGljYWJsZT9cblxuICB2YXIgZ2IxMk9yMTMgPSBudWxsOyAvLyBJcyBHQjEyIG9yIEdCMTMgYXBwbGljYWJsZT9cblxuICBmb3IgKHZhciBjaGFyIG9mIGNvZGVwb2ludHMpIHtcbiAgICB2YXIgY29kZSA9IGNoYXIuY29kZVBvaW50QXQoMCk7XG4gICAgaWYgKCFjb2RlKSBicmVhaztcbiAgICB2YXIgdHlwZSA9IGdldENvZGVwb2ludFR5cGUoY2hhciwgY29kZSk7XG4gICAgW2xlZnQsIHJpZ2h0XSA9IGlzTFRSID8gW3JpZ2h0LCB0eXBlXSA6IFt0eXBlLCBsZWZ0XTtcblxuICAgIGlmIChpbnRlcnNlY3RzKGxlZnQsIENvZGVwb2ludFR5cGUuWldKKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCBDb2RlcG9pbnRUeXBlLkV4dFBpY3QpKSB7XG4gICAgICBpZiAoaXNMVFIpIHtcbiAgICAgICAgZ2IxMSA9IGVuZHNXaXRoRW1vamlaV0ooc3RyLnN1YnN0cmluZygwLCBkaXN0YW5jZSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ2IxMSA9IGVuZHNXaXRoRW1vamlaV0ooc3RyLnN1YnN0cmluZygwLCBzdHIubGVuZ3RoIC0gZGlzdGFuY2UpKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFnYjExKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoaW50ZXJzZWN0cyhsZWZ0LCBDb2RlcG9pbnRUeXBlLlJJKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCBDb2RlcG9pbnRUeXBlLlJJKSkge1xuICAgICAgaWYgKGdiMTJPcjEzICE9PSBudWxsKSB7XG4gICAgICAgIGdiMTJPcjEzID0gIWdiMTJPcjEzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGlzTFRSKSB7XG4gICAgICAgICAgZ2IxMk9yMTMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGdiMTJPcjEzID0gZW5kc1dpdGhPZGROdW1iZXJPZlJJcyhzdHIuc3Vic3RyaW5nKDAsIHN0ci5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghZ2IxMk9yMTMpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChsZWZ0ICE9PSBDb2RlcG9pbnRUeXBlLk5vbmUgJiYgcmlnaHQgIT09IENvZGVwb2ludFR5cGUuTm9uZSAmJiBpc0JvdW5kYXJ5UGFpcihsZWZ0LCByaWdodCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIGRpc3RhbmNlICs9IGNoYXIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGRpc3RhbmNlIHx8IDE7XG59O1xudmFyIFNQQUNFID0gL1xccy87XG52YXIgUFVOQ1RVQVRJT04gPSAvW1xcdTAwMjEtXFx1MDAyM1xcdTAwMjUtXFx1MDAyQVxcdTAwMkMtXFx1MDAyRlxcdTAwM0FcXHUwMDNCXFx1MDAzRlxcdTAwNDBcXHUwMDVCLVxcdTAwNURcXHUwMDVGXFx1MDA3QlxcdTAwN0RcXHUwMEExXFx1MDBBN1xcdTAwQUJcXHUwMEI2XFx1MDBCN1xcdTAwQkJcXHUwMEJGXFx1MDM3RVxcdTAzODdcXHUwNTVBLVxcdTA1NUZcXHUwNTg5XFx1MDU4QVxcdTA1QkVcXHUwNUMwXFx1MDVDM1xcdTA1QzZcXHUwNUYzXFx1MDVGNFxcdTA2MDlcXHUwNjBBXFx1MDYwQ1xcdTA2MERcXHUwNjFCXFx1MDYxRVxcdTA2MUZcXHUwNjZBLVxcdTA2NkRcXHUwNkQ0XFx1MDcwMC1cXHUwNzBEXFx1MDdGNy1cXHUwN0Y5XFx1MDgzMC1cXHUwODNFXFx1MDg1RVxcdTA5NjRcXHUwOTY1XFx1MDk3MFxcdTBBRjBcXHUwREY0XFx1MEU0RlxcdTBFNUFcXHUwRTVCXFx1MEYwNC1cXHUwRjEyXFx1MEYxNFxcdTBGM0EtXFx1MEYzRFxcdTBGODVcXHUwRkQwLVxcdTBGRDRcXHUwRkQ5XFx1MEZEQVxcdTEwNEEtXFx1MTA0RlxcdTEwRkJcXHUxMzYwLVxcdTEzNjhcXHUxNDAwXFx1MTY2RFxcdTE2NkVcXHUxNjlCXFx1MTY5Q1xcdTE2RUItXFx1MTZFRFxcdTE3MzVcXHUxNzM2XFx1MTdENC1cXHUxN0Q2XFx1MTdEOC1cXHUxN0RBXFx1MTgwMC1cXHUxODBBXFx1MTk0NFxcdTE5NDVcXHUxQTFFXFx1MUExRlxcdTFBQTAtXFx1MUFBNlxcdTFBQTgtXFx1MUFBRFxcdTFCNUEtXFx1MUI2MFxcdTFCRkMtXFx1MUJGRlxcdTFDM0ItXFx1MUMzRlxcdTFDN0VcXHUxQzdGXFx1MUNDMC1cXHUxQ0M3XFx1MUNEM1xcdTIwMTAtXFx1MjAyN1xcdTIwMzAtXFx1MjA0M1xcdTIwNDUtXFx1MjA1MVxcdTIwNTMtXFx1MjA1RVxcdTIwN0RcXHUyMDdFXFx1MjA4RFxcdTIwOEVcXHUyMzI5XFx1MjMyQVxcdTI3NjgtXFx1Mjc3NVxcdTI3QzVcXHUyN0M2XFx1MjdFNi1cXHUyN0VGXFx1Mjk4My1cXHUyOTk4XFx1MjlEOC1cXHUyOURCXFx1MjlGQ1xcdTI5RkRcXHUyQ0Y5LVxcdTJDRkNcXHUyQ0ZFXFx1MkNGRlxcdTJENzBcXHUyRTAwLVxcdTJFMkVcXHUyRTMwLVxcdTJFM0JcXHUzMDAxLVxcdTMwMDNcXHUzMDA4LVxcdTMwMTFcXHUzMDE0LVxcdTMwMUZcXHUzMDMwXFx1MzAzRFxcdTMwQTBcXHUzMEZCXFx1QTRGRVxcdUE0RkZcXHVBNjBELVxcdUE2MEZcXHVBNjczXFx1QTY3RVxcdUE2RjItXFx1QTZGN1xcdUE4NzQtXFx1QTg3N1xcdUE4Q0VcXHVBOENGXFx1QThGOC1cXHVBOEZBXFx1QTkyRVxcdUE5MkZcXHVBOTVGXFx1QTlDMS1cXHVBOUNEXFx1QTlERVxcdUE5REZcXHVBQTVDLVxcdUFBNUZcXHVBQURFXFx1QUFERlxcdUFBRjBcXHVBQUYxXFx1QUJFQlxcdUZEM0VcXHVGRDNGXFx1RkUxMC1cXHVGRTE5XFx1RkUzMC1cXHVGRTUyXFx1RkU1NC1cXHVGRTYxXFx1RkU2M1xcdUZFNjhcXHVGRTZBXFx1RkU2QlxcdUZGMDEtXFx1RkYwM1xcdUZGMDUtXFx1RkYwQVxcdUZGMEMtXFx1RkYwRlxcdUZGMUFcXHVGRjFCXFx1RkYxRlxcdUZGMjBcXHVGRjNCLVxcdUZGM0RcXHVGRjNGXFx1RkY1QlxcdUZGNURcXHVGRjVGLVxcdUZGNjVdLztcbnZhciBDSEFNRUxFT04gPSAvWydcXHUyMDE4XFx1MjAxOV0vO1xuLyoqXHJcbiAqIEdldCB0aGUgZGlzdGFuY2UgdG8gdGhlIGVuZCBvZiB0aGUgZmlyc3Qgd29yZCBpbiBhIHN0cmluZyBvZiB0ZXh0LlxyXG4gKi9cblxudmFyIGdldFdvcmREaXN0YW5jZSA9IGZ1bmN0aW9uIGdldFdvcmREaXN0YW5jZSh0ZXh0KSB7XG4gIHZhciBpc1JUTCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIHZhciBkaXN0ID0gMDtcbiAgdmFyIHN0YXJ0ZWQgPSBmYWxzZTtcblxuICB3aGlsZSAodGV4dC5sZW5ndGggPiAwKSB7XG4gICAgdmFyIGNoYXJEaXN0ID0gZ2V0Q2hhcmFjdGVyRGlzdGFuY2UodGV4dCwgaXNSVEwpO1xuICAgIHZhciBbY2hhciwgcmVtYWluaW5nXSA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCBjaGFyRGlzdCwgaXNSVEwpO1xuXG4gICAgaWYgKGlzV29yZENoYXJhY3RlcihjaGFyLCByZW1haW5pbmcsIGlzUlRMKSkge1xuICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICBkaXN0ICs9IGNoYXJEaXN0O1xuICAgIH0gZWxzZSBpZiAoIXN0YXJ0ZWQpIHtcbiAgICAgIGRpc3QgKz0gY2hhckRpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cblxuICAgIHRleHQgPSByZW1haW5pbmc7XG4gIH1cblxuICByZXR1cm4gZGlzdDtcbn07XG4vKipcclxuICogU3BsaXQgYSBzdHJpbmcgaW4gdHdvIHBhcnRzIGF0IGEgZ2l2ZW4gZGlzdGFuY2Ugc3RhcnRpbmcgZnJvbSB0aGUgZW5kIHdoZW5cclxuICogYGlzUlRMYCBpcyBzZXQgdG8gYHRydWVgLlxyXG4gKi9cblxudmFyIHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZSA9IChzdHIsIGRpc3QsIGlzUlRMKSA9PiB7XG4gIGlmIChpc1JUTCkge1xuICAgIHZhciBhdCA9IHN0ci5sZW5ndGggLSBkaXN0O1xuICAgIHJldHVybiBbc3RyLnNsaWNlKGF0LCBzdHIubGVuZ3RoKSwgc3RyLnNsaWNlKDAsIGF0KV07XG4gIH1cblxuICByZXR1cm4gW3N0ci5zbGljZSgwLCBkaXN0KSwgc3RyLnNsaWNlKGRpc3QpXTtcbn07XG4vKipcclxuICogQ2hlY2sgaWYgYSBjaGFyYWN0ZXIgaXMgYSB3b3JkIGNoYXJhY3Rlci4gVGhlIGByZW1haW5pbmdgIGFyZ3VtZW50IGlzIHVzZWRcclxuICogYmVjYXVzZSBzb21ldGltZXMgeW91IG11c3QgcmVhZCBzdWJzZXF1ZW50IGNoYXJhY3RlcnMgdG8gdHJ1bHkgZGV0ZXJtaW5lIGl0LlxyXG4gKi9cblxudmFyIGlzV29yZENoYXJhY3RlciA9IGZ1bmN0aW9uIGlzV29yZENoYXJhY3RlcihjaGFyLCByZW1haW5pbmcpIHtcbiAgdmFyIGlzUlRMID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcblxuICBpZiAoU1BBQ0UudGVzdChjaGFyKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSAvLyBDaGFtZWxlb25zIGNvdW50IGFzIHdvcmQgY2hhcmFjdGVycyBhcyBsb25nIGFzIHRoZXkncmUgaW4gYSB3b3JkLCBzb1xuICAvLyByZWN1cnNlIHRvIHNlZSBpZiB0aGUgbmV4dCBvbmUgaXMgYSB3b3JkIGNoYXJhY3RlciBvciBub3QuXG5cblxuICBpZiAoQ0hBTUVMRU9OLnRlc3QoY2hhcikpIHtcbiAgICB2YXIgY2hhckRpc3QgPSBnZXRDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGlzUlRMKTtcbiAgICB2YXIgW25leHRDaGFyLCBuZXh0UmVtYWluaW5nXSA9IHNwbGl0QnlDaGFyYWN0ZXJEaXN0YW5jZShyZW1haW5pbmcsIGNoYXJEaXN0LCBpc1JUTCk7XG5cbiAgICBpZiAoaXNXb3JkQ2hhcmFjdGVyKG5leHRDaGFyLCBuZXh0UmVtYWluaW5nLCBpc1JUTCkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmIChQVU5DVFVBVElPTi50ZXN0KGNoYXIpKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuLyoqXHJcbiAqIEl0ZXJhdGUgb24gY29kZXBvaW50cyBmcm9tIHJpZ2h0IHRvIGxlZnQuXHJcbiAqL1xuXG5cbnZhciBjb2RlcG9pbnRzSXRlcmF0b3JSVEwgPSBmdW5jdGlvbiogY29kZXBvaW50c0l0ZXJhdG9yUlRMKHN0cikge1xuICB2YXIgZW5kID0gc3RyLmxlbmd0aCAtIDE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgY2hhcjEgPSBzdHIuY2hhckF0KGVuZCAtIGkpO1xuXG4gICAgaWYgKGlzTG93U3Vycm9nYXRlKGNoYXIxLmNoYXJDb2RlQXQoMCkpKSB7XG4gICAgICB2YXIgY2hhcjIgPSBzdHIuY2hhckF0KGVuZCAtIGkgLSAxKTtcblxuICAgICAgaWYgKGlzSGlnaFN1cnJvZ2F0ZShjaGFyMi5jaGFyQ29kZUF0KDApKSkge1xuICAgICAgICB5aWVsZCBjaGFyMiArIGNoYXIxO1xuICAgICAgICBpKys7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHlpZWxkIGNoYXIxO1xuICB9XG59O1xuLyoqXHJcbiAqIElzIGBjaGFyQ29kZWAgYSBoaWdoIHN1cnJvZ2F0ZS5cclxuICpcclxuICogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVW5pdmVyc2FsX0NoYXJhY3Rlcl9TZXRfY2hhcmFjdGVycyNTdXJyb2dhdGVzXHJcbiAqL1xuXG52YXIgaXNIaWdoU3Vycm9nYXRlID0gY2hhckNvZGUgPT4ge1xuICByZXR1cm4gY2hhckNvZGUgPj0gMHhkODAwICYmIGNoYXJDb2RlIDw9IDB4ZGJmZjtcbn07XG4vKipcclxuICogSXMgYGNoYXJDb2RlYCBhIGxvdyBzdXJyb2dhdGUuXHJcbiAqXHJcbiAqIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1VuaXZlcnNhbF9DaGFyYWN0ZXJfU2V0X2NoYXJhY3RlcnMjU3Vycm9nYXRlc1xyXG4gKi9cblxuXG52YXIgaXNMb3dTdXJyb2dhdGUgPSBjaGFyQ29kZSA9PiB7XG4gIHJldHVybiBjaGFyQ29kZSA+PSAweGRjMDAgJiYgY2hhckNvZGUgPD0gMHhkZmZmO1xufTtcblxudmFyIENvZGVwb2ludFR5cGU7XG5cbihmdW5jdGlvbiAoQ29kZXBvaW50VHlwZSkge1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJOb25lXCJdID0gMF0gPSBcIk5vbmVcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiRXh0ZW5kXCJdID0gMV0gPSBcIkV4dGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJaV0pcIl0gPSAyXSA9IFwiWldKXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlJJXCJdID0gNF0gPSBcIlJJXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlByZXBlbmRcIl0gPSA4XSA9IFwiUHJlcGVuZFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJTcGFjaW5nTWFya1wiXSA9IDE2XSA9IFwiU3BhY2luZ01hcmtcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFwiXSA9IDMyXSA9IFwiTFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJWXCJdID0gNjRdID0gXCJWXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIlRcIl0gPSAxMjhdID0gXCJUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkxWXCJdID0gMjU2XSA9IFwiTFZcIjtcbiAgQ29kZXBvaW50VHlwZVtDb2RlcG9pbnRUeXBlW1wiTFZUXCJdID0gNTEyXSA9IFwiTFZUXCI7XG4gIENvZGVwb2ludFR5cGVbQ29kZXBvaW50VHlwZVtcIkV4dFBpY3RcIl0gPSAxMDI0XSA9IFwiRXh0UGljdFwiO1xuICBDb2RlcG9pbnRUeXBlW0NvZGVwb2ludFR5cGVbXCJBbnlcIl0gPSAyMDQ4XSA9IFwiQW55XCI7XG59KShDb2RlcG9pbnRUeXBlIHx8IChDb2RlcG9pbnRUeXBlID0ge30pKTtcblxudmFyIHJlRXh0ZW5kID0gL14oPzpbXFx1MDMwMC1cXHUwMzZGXFx1MDQ4My1cXHUwNDg5XFx1MDU5MS1cXHUwNUJEXFx1MDVCRlxcdTA1QzFcXHUwNUMyXFx1MDVDNFxcdTA1QzVcXHUwNUM3XFx1MDYxMC1cXHUwNjFBXFx1MDY0Qi1cXHUwNjVGXFx1MDY3MFxcdTA2RDYtXFx1MDZEQ1xcdTA2REYtXFx1MDZFNFxcdTA2RTdcXHUwNkU4XFx1MDZFQS1cXHUwNkVEXFx1MDcxMVxcdTA3MzAtXFx1MDc0QVxcdTA3QTYtXFx1MDdCMFxcdTA3RUItXFx1MDdGM1xcdTA3RkRcXHUwODE2LVxcdTA4MTlcXHUwODFCLVxcdTA4MjNcXHUwODI1LVxcdTA4MjdcXHUwODI5LVxcdTA4MkRcXHUwODU5LVxcdTA4NUJcXHUwOEQzLVxcdTA4RTFcXHUwOEUzLVxcdTA5MDJcXHUwOTNBXFx1MDkzQ1xcdTA5NDEtXFx1MDk0OFxcdTA5NERcXHUwOTUxLVxcdTA5NTdcXHUwOTYyXFx1MDk2M1xcdTA5ODFcXHUwOUJDXFx1MDlCRVxcdTA5QzEtXFx1MDlDNFxcdTA5Q0RcXHUwOUQ3XFx1MDlFMlxcdTA5RTNcXHUwOUZFXFx1MEEwMVxcdTBBMDJcXHUwQTNDXFx1MEE0MVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTcwXFx1MEE3MVxcdTBBNzVcXHUwQTgxXFx1MEE4MlxcdTBBQkNcXHUwQUMxLVxcdTBBQzVcXHUwQUM3XFx1MEFDOFxcdTBBQ0RcXHUwQUUyXFx1MEFFM1xcdTBBRkEtXFx1MEFGRlxcdTBCMDFcXHUwQjNDXFx1MEIzRVxcdTBCM0ZcXHUwQjQxLVxcdTBCNDRcXHUwQjREXFx1MEI1NS1cXHUwQjU3XFx1MEI2MlxcdTBCNjNcXHUwQjgyXFx1MEJCRVxcdTBCQzBcXHUwQkNEXFx1MEJEN1xcdTBDMDBcXHUwQzA0XFx1MEMzRS1cXHUwQzQwXFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzYyXFx1MEM2M1xcdTBDODFcXHUwQ0JDXFx1MENCRlxcdTBDQzJcXHUwQ0M2XFx1MENDQ1xcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDRTJcXHUwQ0UzXFx1MEQwMFxcdTBEMDFcXHUwRDNCXFx1MEQzQ1xcdTBEM0VcXHUwRDQxLVxcdTBENDRcXHUwRDREXFx1MEQ1N1xcdTBENjJcXHUwRDYzXFx1MEQ4MVxcdTBEQ0FcXHUwRENGXFx1MEREMi1cXHUwREQ0XFx1MERENlxcdTBEREZcXHUwRTMxXFx1MEUzNC1cXHUwRTNBXFx1MEU0Ny1cXHUwRTRFXFx1MEVCMVxcdTBFQjQtXFx1MEVCQ1xcdTBFQzgtXFx1MEVDRFxcdTBGMThcXHUwRjE5XFx1MEYzNVxcdTBGMzdcXHUwRjM5XFx1MEY3MS1cXHUwRjdFXFx1MEY4MC1cXHUwRjg0XFx1MEY4NlxcdTBGODdcXHUwRjhELVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAyRC1cXHUxMDMwXFx1MTAzMi1cXHUxMDM3XFx1MTAzOVxcdTEwM0FcXHUxMDNEXFx1MTAzRVxcdTEwNThcXHUxMDU5XFx1MTA1RS1cXHUxMDYwXFx1MTA3MS1cXHUxMDc0XFx1MTA4MlxcdTEwODVcXHUxMDg2XFx1MTA4RFxcdTEwOURcXHUxMzVELVxcdTEzNUZcXHUxNzEyLVxcdTE3MTRcXHUxNzMyLVxcdTE3MzRcXHUxNzUyXFx1MTc1M1xcdTE3NzJcXHUxNzczXFx1MTdCNFxcdTE3QjVcXHUxN0I3LVxcdTE3QkRcXHUxN0M2XFx1MTdDOS1cXHUxN0QzXFx1MTdERFxcdTE4MEItXFx1MTgwRFxcdTE4ODVcXHUxODg2XFx1MThBOVxcdTE5MjAtXFx1MTkyMlxcdTE5MjdcXHUxOTI4XFx1MTkzMlxcdTE5MzktXFx1MTkzQlxcdTFBMTdcXHUxQTE4XFx1MUExQlxcdTFBNTZcXHUxQTU4LVxcdTFBNUVcXHUxQTYwXFx1MUE2MlxcdTFBNjUtXFx1MUE2Q1xcdTFBNzMtXFx1MUE3Q1xcdTFBN0ZcXHUxQUIwLVxcdTFBQzBcXHUxQjAwLVxcdTFCMDNcXHUxQjM0LVxcdTFCM0FcXHUxQjNDXFx1MUI0MlxcdTFCNkItXFx1MUI3M1xcdTFCODBcXHUxQjgxXFx1MUJBMi1cXHUxQkE1XFx1MUJBOFxcdTFCQTlcXHUxQkFCLVxcdTFCQURcXHUxQkU2XFx1MUJFOFxcdTFCRTlcXHUxQkVEXFx1MUJFRi1cXHUxQkYxXFx1MUMyQy1cXHUxQzMzXFx1MUMzNlxcdTFDMzdcXHUxQ0QwLVxcdTFDRDJcXHUxQ0Q0LVxcdTFDRTBcXHUxQ0UyLVxcdTFDRThcXHUxQ0VEXFx1MUNGNFxcdTFDRjhcXHUxQ0Y5XFx1MURDMC1cXHUxREY5XFx1MURGQi1cXHUxREZGXFx1MjAwQ1xcdTIwRDAtXFx1MjBGMFxcdTJDRUYtXFx1MkNGMVxcdTJEN0ZcXHUyREUwLVxcdTJERkZcXHUzMDJBLVxcdTMwMkZcXHUzMDk5XFx1MzA5QVxcdUE2NkYtXFx1QTY3MlxcdUE2NzQtXFx1QTY3RFxcdUE2OUVcXHVBNjlGXFx1QTZGMFxcdUE2RjFcXHVBODAyXFx1QTgwNlxcdUE4MEJcXHVBODI1XFx1QTgyNlxcdUE4MkNcXHVBOEM0XFx1QThDNVxcdUE4RTAtXFx1QThGMVxcdUE4RkZcXHVBOTI2LVxcdUE5MkRcXHVBOTQ3LVxcdUE5NTFcXHVBOTgwLVxcdUE5ODJcXHVBOUIzXFx1QTlCNi1cXHVBOUI5XFx1QTlCQ1xcdUE5QkRcXHVBOUU1XFx1QUEyOS1cXHVBQTJFXFx1QUEzMVxcdUFBMzJcXHVBQTM1XFx1QUEzNlxcdUFBNDNcXHVBQTRDXFx1QUE3Q1xcdUFBQjBcXHVBQUIyLVxcdUFBQjRcXHVBQUI3XFx1QUFCOFxcdUFBQkVcXHVBQUJGXFx1QUFDMVxcdUFBRUNcXHVBQUVEXFx1QUFGNlxcdUFCRTVcXHVBQkU4XFx1QUJFRFxcdUZCMUVcXHVGRTAwLVxcdUZFMEZcXHVGRTIwLVxcdUZFMkZcXHVGRjlFXFx1RkY5Rl18XFx1RDgwMFtcXHVEREZEXFx1REVFMFxcdURGNzYtXFx1REY3QV18XFx1RDgwMltcXHVERTAxLVxcdURFMDNcXHVERTA1XFx1REUwNlxcdURFMEMtXFx1REUwRlxcdURFMzgtXFx1REUzQVxcdURFM0ZcXHVERUU1XFx1REVFNl18XFx1RDgwM1tcXHVERDI0LVxcdUREMjdcXHVERUFCXFx1REVBQ1xcdURGNDYtXFx1REY1MF18XFx1RDgwNFtcXHVEQzAxXFx1REMzOC1cXHVEQzQ2XFx1REM3Ri1cXHVEQzgxXFx1RENCMy1cXHVEQ0I2XFx1RENCOVxcdURDQkFcXHVERDAwLVxcdUREMDJcXHVERDI3LVxcdUREMkJcXHVERDJELVxcdUREMzRcXHVERDczXFx1REQ4MFxcdUREODFcXHVEREI2LVxcdUREQkVcXHVEREM5LVxcdUREQ0NcXHVERENGXFx1REUyRi1cXHVERTMxXFx1REUzNFxcdURFMzZcXHVERTM3XFx1REUzRVxcdURFREZcXHVERUUzLVxcdURFRUFcXHVERjAwXFx1REYwMVxcdURGM0JcXHVERjNDXFx1REYzRVxcdURGNDBcXHVERjU3XFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMzgtXFx1REMzRlxcdURDNDItXFx1REM0NFxcdURDNDZcXHVEQzVFXFx1RENCMFxcdURDQjMtXFx1RENCOFxcdURDQkFcXHVEQ0JEXFx1RENCRlxcdURDQzBcXHVEQ0MyXFx1RENDM1xcdUREQUZcXHVEREIyLVxcdUREQjVcXHVEREJDXFx1RERCRFxcdUREQkZcXHVEREMwXFx1REREQ1xcdURERERcXHVERTMzLVxcdURFM0FcXHVERTNEXFx1REUzRlxcdURFNDBcXHVERUFCXFx1REVBRFxcdURFQjAtXFx1REVCNVxcdURFQjdcXHVERjFELVxcdURGMUZcXHVERjIyLVxcdURGMjVcXHVERjI3LVxcdURGMkJdfFxcdUQ4MDZbXFx1REMyRi1cXHVEQzM3XFx1REMzOVxcdURDM0FcXHVERDMwXFx1REQzQlxcdUREM0NcXHVERDNFXFx1REQ0M1xcdURERDQtXFx1REREN1xcdUREREFcXHVERERCXFx1RERFMFxcdURFMDEtXFx1REUwQVxcdURFMzMtXFx1REUzOFxcdURFM0ItXFx1REUzRVxcdURFNDdcXHVERTUxLVxcdURFNTZcXHVERTU5LVxcdURFNUJcXHVERThBLVxcdURFOTZcXHVERTk4XFx1REU5OV18XFx1RDgwN1tcXHVEQzMwLVxcdURDMzZcXHVEQzM4LVxcdURDM0RcXHVEQzNGXFx1REM5Mi1cXHVEQ0E3XFx1RENBQS1cXHVEQ0IwXFx1RENCMlxcdURDQjNcXHVEQ0I1XFx1RENCNlxcdUREMzEtXFx1REQzNlxcdUREM0FcXHVERDNDXFx1REQzRFxcdUREM0YtXFx1REQ0NVxcdURENDdcXHVERDkwXFx1REQ5MVxcdUREOTVcXHVERDk3XFx1REVGM1xcdURFRjRdfFxcdUQ4MUFbXFx1REVGMC1cXHVERUY0XFx1REYzMC1cXHVERjM2XXxcXHVEODFCW1xcdURGNEZcXHVERjhGLVxcdURGOTJcXHVERkU0XXxcXHVEODJGW1xcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjVcXHVERDY3LVxcdURENjlcXHVERDZFLVxcdURENzJcXHVERDdCLVxcdUREODJcXHVERDg1LVxcdUREOEJcXHVEREFBLVxcdUREQURcXHVERTQyLVxcdURFNDRdfFxcdUQ4MzZbXFx1REUwMC1cXHVERTM2XFx1REUzQi1cXHVERTZDXFx1REU3NVxcdURFODRcXHVERTlCLVxcdURFOUZcXHVERUExLVxcdURFQUZdfFxcdUQ4MzhbXFx1REMwMC1cXHVEQzA2XFx1REMwOC1cXHVEQzE4XFx1REMxQi1cXHVEQzIxXFx1REMyM1xcdURDMjRcXHVEQzI2LVxcdURDMkFcXHVERDMwLVxcdUREMzZcXHVERUVDLVxcdURFRUZdfFxcdUQ4M0FbXFx1RENEMC1cXHVEQ0Q2XFx1REQ0NC1cXHVERDRBXXxcXHVEODNDW1xcdURGRkItXFx1REZGRl18XFx1REI0MFtcXHVEQzIwLVxcdURDN0ZcXHVERDAwLVxcdURERUZdKSQvO1xudmFyIHJlUHJlcGVuZCA9IC9eKD86W1xcdTA2MDAtXFx1MDYwNVxcdTA2RERcXHUwNzBGXFx1MDg5MFxcdTA4OTFcXHUwOEUyXFx1MEQ0RV18XFx1RDgwNFtcXHVEQ0JEXFx1RENDRFxcdUREQzJcXHVEREMzXXxcXHVEODA2W1xcdUREM0ZcXHVERDQxXFx1REUzQVxcdURFODQtXFx1REU4OV18XFx1RDgwN1xcdURENDYpJC87XG52YXIgcmVTcGFjaW5nTWFyayA9IC9eKD86W1xcdTA5MDNcXHUwOTNCXFx1MDkzRS1cXHUwOTQwXFx1MDk0OS1cXHUwOTRDXFx1MDk0RVxcdTA5NEZcXHUwOTgyXFx1MDk4M1xcdTA5QkZcXHUwOUMwXFx1MDlDN1xcdTA5QzhcXHUwOUNCXFx1MDlDQ1xcdTBBMDNcXHUwQTNFLVxcdTBBNDBcXHUwQTgzXFx1MEFCRS1cXHUwQUMwXFx1MEFDOVxcdTBBQ0JcXHUwQUNDXFx1MEIwMlxcdTBCMDNcXHUwQjQwXFx1MEI0N1xcdTBCNDhcXHUwQjRCXFx1MEI0Q1xcdTBCQkZcXHUwQkMxXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDQ1xcdTBDMDEtXFx1MEMwM1xcdTBDNDEtXFx1MEM0NFxcdTBDODJcXHUwQzgzXFx1MENCRVxcdTBDQzBcXHUwQ0MxXFx1MENDM1xcdTBDQzRcXHUwQ0M3XFx1MENDOFxcdTBDQ0FcXHUwQ0NCXFx1MEQwMlxcdTBEMDNcXHUwRDNGXFx1MEQ0MFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0Q1xcdTBEODJcXHUwRDgzXFx1MEREMFxcdTBERDFcXHUwREQ4LVxcdTBEREVcXHUwREYyXFx1MERGM1xcdTBFMzNcXHUwRUIzXFx1MEYzRVxcdTBGM0ZcXHUwRjdGXFx1MTAzMVxcdTEwM0JcXHUxMDNDXFx1MTA1NlxcdTEwNTdcXHUxMDg0XFx1MTcxNVxcdTE3MzRcXHUxN0I2XFx1MTdCRS1cXHUxN0M1XFx1MTdDN1xcdTE3QzhcXHUxOTIzLVxcdTE5MjZcXHUxOTI5LVxcdTE5MkJcXHUxOTMwXFx1MTkzMVxcdTE5MzMtXFx1MTkzOFxcdTFBMTlcXHUxQTFBXFx1MUE1NVxcdTFBNTdcXHUxQTZELVxcdTFBNzJcXHUxQjA0XFx1MUIzQlxcdTFCM0QtXFx1MUI0MVxcdTFCNDNcXHUxQjQ0XFx1MUI4MlxcdTFCQTFcXHUxQkE2XFx1MUJBN1xcdTFCQUFcXHUxQkU3XFx1MUJFQS1cXHUxQkVDXFx1MUJFRVxcdTFCRjJcXHUxQkYzXFx1MUMyNC1cXHUxQzJCXFx1MUMzNFxcdTFDMzVcXHUxQ0UxXFx1MUNGN1xcdUE4MjNcXHVBODI0XFx1QTgyN1xcdUE4ODBcXHVBODgxXFx1QThCNC1cXHVBOEMzXFx1QTk1MlxcdUE5NTNcXHVBOTgzXFx1QTlCNFxcdUE5QjVcXHVBOUJBXFx1QTlCQlxcdUE5QkUtXFx1QTlDMFxcdUFBMkZcXHVBQTMwXFx1QUEzM1xcdUFBMzRcXHVBQTREXFx1QUFFQlxcdUFBRUVcXHVBQUVGXFx1QUFGNVxcdUFCRTNcXHVBQkU0XFx1QUJFNlxcdUFCRTdcXHVBQkU5XFx1QUJFQVxcdUFCRUNdfFxcdUQ4MDRbXFx1REMwMFxcdURDMDJcXHVEQzgyXFx1RENCMC1cXHVEQ0IyXFx1RENCN1xcdURDQjhcXHVERDJDXFx1REQ0NVxcdURENDZcXHVERDgyXFx1RERCMy1cXHVEREI1XFx1RERCRlxcdUREQzBcXHVERENFXFx1REUyQy1cXHVERTJFXFx1REUzMlxcdURFMzNcXHVERTM1XFx1REVFMC1cXHVERUUyXFx1REYwMlxcdURGMDNcXHVERjNGXFx1REY0MS1cXHVERjQ0XFx1REY0N1xcdURGNDhcXHVERjRCLVxcdURGNERcXHVERjYyXFx1REY2M118XFx1RDgwNVtcXHVEQzM1LVxcdURDMzdcXHVEQzQwXFx1REM0MVxcdURDNDVcXHVEQ0IxXFx1RENCMlxcdURDQjlcXHVEQ0JCXFx1RENCQ1xcdURDQkVcXHVEQ0MxXFx1RERCMFxcdUREQjFcXHVEREI4LVxcdUREQkJcXHVEREJFXFx1REUzMC1cXHVERTMyXFx1REUzQlxcdURFM0NcXHVERTNFXFx1REVBQ1xcdURFQUVcXHVERUFGXFx1REVCNlxcdURGMjZdfFxcdUQ4MDZbXFx1REMyQy1cXHVEQzJFXFx1REMzOFxcdUREMzEtXFx1REQzNVxcdUREMzdcXHVERDM4XFx1REQzRFxcdURENDBcXHVERDQyXFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERGXFx1RERFNFxcdURFMzlcXHVERTU3XFx1REU1OFxcdURFOTddfFxcdUQ4MDdbXFx1REMyRlxcdURDM0VcXHVEQ0E5XFx1RENCMVxcdURDQjRcXHVERDhBLVxcdUREOEVcXHVERDkzXFx1REQ5NFxcdUREOTZcXHVERUY1XFx1REVGNl18XFx1RDgxQltcXHVERjUxLVxcdURGODdcXHVERkYwXFx1REZGMV18XFx1RDgzNFtcXHVERDY2XFx1REQ2RF0pJC87XG52YXIgcmVMID0gL15bXFx1MTEwMC1cXHUxMTVGXFx1QTk2MC1cXHVBOTdDXSQvO1xudmFyIHJlViA9IC9eW1xcdTExNjAtXFx1MTFBN1xcdUQ3QjAtXFx1RDdDNl0kLztcbnZhciByZVQgPSAvXltcXHUxMUE4LVxcdTExRkZcXHVEN0NCLVxcdUQ3RkJdJC87XG52YXIgcmVMViA9IC9eW1xcdUFDMDBcXHVBQzFDXFx1QUMzOFxcdUFDNTRcXHVBQzcwXFx1QUM4Q1xcdUFDQThcXHVBQ0M0XFx1QUNFMFxcdUFDRkNcXHVBRDE4XFx1QUQzNFxcdUFENTBcXHVBRDZDXFx1QUQ4OFxcdUFEQTRcXHVBREMwXFx1QUREQ1xcdUFERjhcXHVBRTE0XFx1QUUzMFxcdUFFNENcXHVBRTY4XFx1QUU4NFxcdUFFQTBcXHVBRUJDXFx1QUVEOFxcdUFFRjRcXHVBRjEwXFx1QUYyQ1xcdUFGNDhcXHVBRjY0XFx1QUY4MFxcdUFGOUNcXHVBRkI4XFx1QUZENFxcdUFGRjBcXHVCMDBDXFx1QjAyOFxcdUIwNDRcXHVCMDYwXFx1QjA3Q1xcdUIwOThcXHVCMEI0XFx1QjBEMFxcdUIwRUNcXHVCMTA4XFx1QjEyNFxcdUIxNDBcXHVCMTVDXFx1QjE3OFxcdUIxOTRcXHVCMUIwXFx1QjFDQ1xcdUIxRThcXHVCMjA0XFx1QjIyMFxcdUIyM0NcXHVCMjU4XFx1QjI3NFxcdUIyOTBcXHVCMkFDXFx1QjJDOFxcdUIyRTRcXHVCMzAwXFx1QjMxQ1xcdUIzMzhcXHVCMzU0XFx1QjM3MFxcdUIzOENcXHVCM0E4XFx1QjNDNFxcdUIzRTBcXHVCM0ZDXFx1QjQxOFxcdUI0MzRcXHVCNDUwXFx1QjQ2Q1xcdUI0ODhcXHVCNEE0XFx1QjRDMFxcdUI0RENcXHVCNEY4XFx1QjUxNFxcdUI1MzBcXHVCNTRDXFx1QjU2OFxcdUI1ODRcXHVCNUEwXFx1QjVCQ1xcdUI1RDhcXHVCNUY0XFx1QjYxMFxcdUI2MkNcXHVCNjQ4XFx1QjY2NFxcdUI2ODBcXHVCNjlDXFx1QjZCOFxcdUI2RDRcXHVCNkYwXFx1QjcwQ1xcdUI3MjhcXHVCNzQ0XFx1Qjc2MFxcdUI3N0NcXHVCNzk4XFx1QjdCNFxcdUI3RDBcXHVCN0VDXFx1QjgwOFxcdUI4MjRcXHVCODQwXFx1Qjg1Q1xcdUI4NzhcXHVCODk0XFx1QjhCMFxcdUI4Q0NcXHVCOEU4XFx1QjkwNFxcdUI5MjBcXHVCOTNDXFx1Qjk1OFxcdUI5NzRcXHVCOTkwXFx1QjlBQ1xcdUI5QzhcXHVCOUU0XFx1QkEwMFxcdUJBMUNcXHVCQTM4XFx1QkE1NFxcdUJBNzBcXHVCQThDXFx1QkFBOFxcdUJBQzRcXHVCQUUwXFx1QkFGQ1xcdUJCMThcXHVCQjM0XFx1QkI1MFxcdUJCNkNcXHVCQjg4XFx1QkJBNFxcdUJCQzBcXHVCQkRDXFx1QkJGOFxcdUJDMTRcXHVCQzMwXFx1QkM0Q1xcdUJDNjhcXHVCQzg0XFx1QkNBMFxcdUJDQkNcXHVCQ0Q4XFx1QkNGNFxcdUJEMTBcXHVCRDJDXFx1QkQ0OFxcdUJENjRcXHVCRDgwXFx1QkQ5Q1xcdUJEQjhcXHVCREQ0XFx1QkRGMFxcdUJFMENcXHVCRTI4XFx1QkU0NFxcdUJFNjBcXHVCRTdDXFx1QkU5OFxcdUJFQjRcXHVCRUQwXFx1QkVFQ1xcdUJGMDhcXHVCRjI0XFx1QkY0MFxcdUJGNUNcXHVCRjc4XFx1QkY5NFxcdUJGQjBcXHVCRkNDXFx1QkZFOFxcdUMwMDRcXHVDMDIwXFx1QzAzQ1xcdUMwNThcXHVDMDc0XFx1QzA5MFxcdUMwQUNcXHVDMEM4XFx1QzBFNFxcdUMxMDBcXHVDMTFDXFx1QzEzOFxcdUMxNTRcXHVDMTcwXFx1QzE4Q1xcdUMxQThcXHVDMUM0XFx1QzFFMFxcdUMxRkNcXHVDMjE4XFx1QzIzNFxcdUMyNTBcXHVDMjZDXFx1QzI4OFxcdUMyQTRcXHVDMkMwXFx1QzJEQ1xcdUMyRjhcXHVDMzE0XFx1QzMzMFxcdUMzNENcXHVDMzY4XFx1QzM4NFxcdUMzQTBcXHVDM0JDXFx1QzNEOFxcdUMzRjRcXHVDNDEwXFx1QzQyQ1xcdUM0NDhcXHVDNDY0XFx1QzQ4MFxcdUM0OUNcXHVDNEI4XFx1QzRENFxcdUM0RjBcXHVDNTBDXFx1QzUyOFxcdUM1NDRcXHVDNTYwXFx1QzU3Q1xcdUM1OThcXHVDNUI0XFx1QzVEMFxcdUM1RUNcXHVDNjA4XFx1QzYyNFxcdUM2NDBcXHVDNjVDXFx1QzY3OFxcdUM2OTRcXHVDNkIwXFx1QzZDQ1xcdUM2RThcXHVDNzA0XFx1QzcyMFxcdUM3M0NcXHVDNzU4XFx1Qzc3NFxcdUM3OTBcXHVDN0FDXFx1QzdDOFxcdUM3RTRcXHVDODAwXFx1QzgxQ1xcdUM4MzhcXHVDODU0XFx1Qzg3MFxcdUM4OENcXHVDOEE4XFx1QzhDNFxcdUM4RTBcXHVDOEZDXFx1QzkxOFxcdUM5MzRcXHVDOTUwXFx1Qzk2Q1xcdUM5ODhcXHVDOUE0XFx1QzlDMFxcdUM5RENcXHVDOUY4XFx1Q0ExNFxcdUNBMzBcXHVDQTRDXFx1Q0E2OFxcdUNBODRcXHVDQUEwXFx1Q0FCQ1xcdUNBRDhcXHVDQUY0XFx1Q0IxMFxcdUNCMkNcXHVDQjQ4XFx1Q0I2NFxcdUNCODBcXHVDQjlDXFx1Q0JCOFxcdUNCRDRcXHVDQkYwXFx1Q0MwQ1xcdUNDMjhcXHVDQzQ0XFx1Q0M2MFxcdUNDN0NcXHVDQzk4XFx1Q0NCNFxcdUNDRDBcXHVDQ0VDXFx1Q0QwOFxcdUNEMjRcXHVDRDQwXFx1Q0Q1Q1xcdUNENzhcXHVDRDk0XFx1Q0RCMFxcdUNEQ0NcXHVDREU4XFx1Q0UwNFxcdUNFMjBcXHVDRTNDXFx1Q0U1OFxcdUNFNzRcXHVDRTkwXFx1Q0VBQ1xcdUNFQzhcXHVDRUU0XFx1Q0YwMFxcdUNGMUNcXHVDRjM4XFx1Q0Y1NFxcdUNGNzBcXHVDRjhDXFx1Q0ZBOFxcdUNGQzRcXHVDRkUwXFx1Q0ZGQ1xcdUQwMThcXHVEMDM0XFx1RDA1MFxcdUQwNkNcXHVEMDg4XFx1RDBBNFxcdUQwQzBcXHVEMERDXFx1RDBGOFxcdUQxMTRcXHVEMTMwXFx1RDE0Q1xcdUQxNjhcXHVEMTg0XFx1RDFBMFxcdUQxQkNcXHVEMUQ4XFx1RDFGNFxcdUQyMTBcXHVEMjJDXFx1RDI0OFxcdUQyNjRcXHVEMjgwXFx1RDI5Q1xcdUQyQjhcXHVEMkQ0XFx1RDJGMFxcdUQzMENcXHVEMzI4XFx1RDM0NFxcdUQzNjBcXHVEMzdDXFx1RDM5OFxcdUQzQjRcXHVEM0QwXFx1RDNFQ1xcdUQ0MDhcXHVENDI0XFx1RDQ0MFxcdUQ0NUNcXHVENDc4XFx1RDQ5NFxcdUQ0QjBcXHVENENDXFx1RDRFOFxcdUQ1MDRcXHVENTIwXFx1RDUzQ1xcdUQ1NThcXHVENTc0XFx1RDU5MFxcdUQ1QUNcXHVENUM4XFx1RDVFNFxcdUQ2MDBcXHVENjFDXFx1RDYzOFxcdUQ2NTRcXHVENjcwXFx1RDY4Q1xcdUQ2QThcXHVENkM0XFx1RDZFMFxcdUQ2RkNcXHVENzE4XFx1RDczNFxcdUQ3NTBcXHVENzZDXFx1RDc4OF0kLztcbnZhciByZUxWVCA9IC9eW1xcdUFDMDEtXFx1QUMxQlxcdUFDMUQtXFx1QUMzN1xcdUFDMzktXFx1QUM1M1xcdUFDNTUtXFx1QUM2RlxcdUFDNzEtXFx1QUM4QlxcdUFDOEQtXFx1QUNBN1xcdUFDQTktXFx1QUNDM1xcdUFDQzUtXFx1QUNERlxcdUFDRTEtXFx1QUNGQlxcdUFDRkQtXFx1QUQxN1xcdUFEMTktXFx1QUQzM1xcdUFEMzUtXFx1QUQ0RlxcdUFENTEtXFx1QUQ2QlxcdUFENkQtXFx1QUQ4N1xcdUFEODktXFx1QURBM1xcdUFEQTUtXFx1QURCRlxcdUFEQzEtXFx1QUREQlxcdUFEREQtXFx1QURGN1xcdUFERjktXFx1QUUxM1xcdUFFMTUtXFx1QUUyRlxcdUFFMzEtXFx1QUU0QlxcdUFFNEQtXFx1QUU2N1xcdUFFNjktXFx1QUU4M1xcdUFFODUtXFx1QUU5RlxcdUFFQTEtXFx1QUVCQlxcdUFFQkQtXFx1QUVEN1xcdUFFRDktXFx1QUVGM1xcdUFFRjUtXFx1QUYwRlxcdUFGMTEtXFx1QUYyQlxcdUFGMkQtXFx1QUY0N1xcdUFGNDktXFx1QUY2M1xcdUFGNjUtXFx1QUY3RlxcdUFGODEtXFx1QUY5QlxcdUFGOUQtXFx1QUZCN1xcdUFGQjktXFx1QUZEM1xcdUFGRDUtXFx1QUZFRlxcdUFGRjEtXFx1QjAwQlxcdUIwMEQtXFx1QjAyN1xcdUIwMjktXFx1QjA0M1xcdUIwNDUtXFx1QjA1RlxcdUIwNjEtXFx1QjA3QlxcdUIwN0QtXFx1QjA5N1xcdUIwOTktXFx1QjBCM1xcdUIwQjUtXFx1QjBDRlxcdUIwRDEtXFx1QjBFQlxcdUIwRUQtXFx1QjEwN1xcdUIxMDktXFx1QjEyM1xcdUIxMjUtXFx1QjEzRlxcdUIxNDEtXFx1QjE1QlxcdUIxNUQtXFx1QjE3N1xcdUIxNzktXFx1QjE5M1xcdUIxOTUtXFx1QjFBRlxcdUIxQjEtXFx1QjFDQlxcdUIxQ0QtXFx1QjFFN1xcdUIxRTktXFx1QjIwM1xcdUIyMDUtXFx1QjIxRlxcdUIyMjEtXFx1QjIzQlxcdUIyM0QtXFx1QjI1N1xcdUIyNTktXFx1QjI3M1xcdUIyNzUtXFx1QjI4RlxcdUIyOTEtXFx1QjJBQlxcdUIyQUQtXFx1QjJDN1xcdUIyQzktXFx1QjJFM1xcdUIyRTUtXFx1QjJGRlxcdUIzMDEtXFx1QjMxQlxcdUIzMUQtXFx1QjMzN1xcdUIzMzktXFx1QjM1M1xcdUIzNTUtXFx1QjM2RlxcdUIzNzEtXFx1QjM4QlxcdUIzOEQtXFx1QjNBN1xcdUIzQTktXFx1QjNDM1xcdUIzQzUtXFx1QjNERlxcdUIzRTEtXFx1QjNGQlxcdUIzRkQtXFx1QjQxN1xcdUI0MTktXFx1QjQzM1xcdUI0MzUtXFx1QjQ0RlxcdUI0NTEtXFx1QjQ2QlxcdUI0NkQtXFx1QjQ4N1xcdUI0ODktXFx1QjRBM1xcdUI0QTUtXFx1QjRCRlxcdUI0QzEtXFx1QjREQlxcdUI0REQtXFx1QjRGN1xcdUI0RjktXFx1QjUxM1xcdUI1MTUtXFx1QjUyRlxcdUI1MzEtXFx1QjU0QlxcdUI1NEQtXFx1QjU2N1xcdUI1NjktXFx1QjU4M1xcdUI1ODUtXFx1QjU5RlxcdUI1QTEtXFx1QjVCQlxcdUI1QkQtXFx1QjVEN1xcdUI1RDktXFx1QjVGM1xcdUI1RjUtXFx1QjYwRlxcdUI2MTEtXFx1QjYyQlxcdUI2MkQtXFx1QjY0N1xcdUI2NDktXFx1QjY2M1xcdUI2NjUtXFx1QjY3RlxcdUI2ODEtXFx1QjY5QlxcdUI2OUQtXFx1QjZCN1xcdUI2QjktXFx1QjZEM1xcdUI2RDUtXFx1QjZFRlxcdUI2RjEtXFx1QjcwQlxcdUI3MEQtXFx1QjcyN1xcdUI3MjktXFx1Qjc0M1xcdUI3NDUtXFx1Qjc1RlxcdUI3NjEtXFx1Qjc3QlxcdUI3N0QtXFx1Qjc5N1xcdUI3OTktXFx1QjdCM1xcdUI3QjUtXFx1QjdDRlxcdUI3RDEtXFx1QjdFQlxcdUI3RUQtXFx1QjgwN1xcdUI4MDktXFx1QjgyM1xcdUI4MjUtXFx1QjgzRlxcdUI4NDEtXFx1Qjg1QlxcdUI4NUQtXFx1Qjg3N1xcdUI4NzktXFx1Qjg5M1xcdUI4OTUtXFx1QjhBRlxcdUI4QjEtXFx1QjhDQlxcdUI4Q0QtXFx1QjhFN1xcdUI4RTktXFx1QjkwM1xcdUI5MDUtXFx1QjkxRlxcdUI5MjEtXFx1QjkzQlxcdUI5M0QtXFx1Qjk1N1xcdUI5NTktXFx1Qjk3M1xcdUI5NzUtXFx1Qjk4RlxcdUI5OTEtXFx1QjlBQlxcdUI5QUQtXFx1QjlDN1xcdUI5QzktXFx1QjlFM1xcdUI5RTUtXFx1QjlGRlxcdUJBMDEtXFx1QkExQlxcdUJBMUQtXFx1QkEzN1xcdUJBMzktXFx1QkE1M1xcdUJBNTUtXFx1QkE2RlxcdUJBNzEtXFx1QkE4QlxcdUJBOEQtXFx1QkFBN1xcdUJBQTktXFx1QkFDM1xcdUJBQzUtXFx1QkFERlxcdUJBRTEtXFx1QkFGQlxcdUJBRkQtXFx1QkIxN1xcdUJCMTktXFx1QkIzM1xcdUJCMzUtXFx1QkI0RlxcdUJCNTEtXFx1QkI2QlxcdUJCNkQtXFx1QkI4N1xcdUJCODktXFx1QkJBM1xcdUJCQTUtXFx1QkJCRlxcdUJCQzEtXFx1QkJEQlxcdUJCREQtXFx1QkJGN1xcdUJCRjktXFx1QkMxM1xcdUJDMTUtXFx1QkMyRlxcdUJDMzEtXFx1QkM0QlxcdUJDNEQtXFx1QkM2N1xcdUJDNjktXFx1QkM4M1xcdUJDODUtXFx1QkM5RlxcdUJDQTEtXFx1QkNCQlxcdUJDQkQtXFx1QkNEN1xcdUJDRDktXFx1QkNGM1xcdUJDRjUtXFx1QkQwRlxcdUJEMTEtXFx1QkQyQlxcdUJEMkQtXFx1QkQ0N1xcdUJENDktXFx1QkQ2M1xcdUJENjUtXFx1QkQ3RlxcdUJEODEtXFx1QkQ5QlxcdUJEOUQtXFx1QkRCN1xcdUJEQjktXFx1QkREM1xcdUJERDUtXFx1QkRFRlxcdUJERjEtXFx1QkUwQlxcdUJFMEQtXFx1QkUyN1xcdUJFMjktXFx1QkU0M1xcdUJFNDUtXFx1QkU1RlxcdUJFNjEtXFx1QkU3QlxcdUJFN0QtXFx1QkU5N1xcdUJFOTktXFx1QkVCM1xcdUJFQjUtXFx1QkVDRlxcdUJFRDEtXFx1QkVFQlxcdUJFRUQtXFx1QkYwN1xcdUJGMDktXFx1QkYyM1xcdUJGMjUtXFx1QkYzRlxcdUJGNDEtXFx1QkY1QlxcdUJGNUQtXFx1QkY3N1xcdUJGNzktXFx1QkY5M1xcdUJGOTUtXFx1QkZBRlxcdUJGQjEtXFx1QkZDQlxcdUJGQ0QtXFx1QkZFN1xcdUJGRTktXFx1QzAwM1xcdUMwMDUtXFx1QzAxRlxcdUMwMjEtXFx1QzAzQlxcdUMwM0QtXFx1QzA1N1xcdUMwNTktXFx1QzA3M1xcdUMwNzUtXFx1QzA4RlxcdUMwOTEtXFx1QzBBQlxcdUMwQUQtXFx1QzBDN1xcdUMwQzktXFx1QzBFM1xcdUMwRTUtXFx1QzBGRlxcdUMxMDEtXFx1QzExQlxcdUMxMUQtXFx1QzEzN1xcdUMxMzktXFx1QzE1M1xcdUMxNTUtXFx1QzE2RlxcdUMxNzEtXFx1QzE4QlxcdUMxOEQtXFx1QzFBN1xcdUMxQTktXFx1QzFDM1xcdUMxQzUtXFx1QzFERlxcdUMxRTEtXFx1QzFGQlxcdUMxRkQtXFx1QzIxN1xcdUMyMTktXFx1QzIzM1xcdUMyMzUtXFx1QzI0RlxcdUMyNTEtXFx1QzI2QlxcdUMyNkQtXFx1QzI4N1xcdUMyODktXFx1QzJBM1xcdUMyQTUtXFx1QzJCRlxcdUMyQzEtXFx1QzJEQlxcdUMyREQtXFx1QzJGN1xcdUMyRjktXFx1QzMxM1xcdUMzMTUtXFx1QzMyRlxcdUMzMzEtXFx1QzM0QlxcdUMzNEQtXFx1QzM2N1xcdUMzNjktXFx1QzM4M1xcdUMzODUtXFx1QzM5RlxcdUMzQTEtXFx1QzNCQlxcdUMzQkQtXFx1QzNEN1xcdUMzRDktXFx1QzNGM1xcdUMzRjUtXFx1QzQwRlxcdUM0MTEtXFx1QzQyQlxcdUM0MkQtXFx1QzQ0N1xcdUM0NDktXFx1QzQ2M1xcdUM0NjUtXFx1QzQ3RlxcdUM0ODEtXFx1QzQ5QlxcdUM0OUQtXFx1QzRCN1xcdUM0QjktXFx1QzREM1xcdUM0RDUtXFx1QzRFRlxcdUM0RjEtXFx1QzUwQlxcdUM1MEQtXFx1QzUyN1xcdUM1MjktXFx1QzU0M1xcdUM1NDUtXFx1QzU1RlxcdUM1NjEtXFx1QzU3QlxcdUM1N0QtXFx1QzU5N1xcdUM1OTktXFx1QzVCM1xcdUM1QjUtXFx1QzVDRlxcdUM1RDEtXFx1QzVFQlxcdUM1RUQtXFx1QzYwN1xcdUM2MDktXFx1QzYyM1xcdUM2MjUtXFx1QzYzRlxcdUM2NDEtXFx1QzY1QlxcdUM2NUQtXFx1QzY3N1xcdUM2NzktXFx1QzY5M1xcdUM2OTUtXFx1QzZBRlxcdUM2QjEtXFx1QzZDQlxcdUM2Q0QtXFx1QzZFN1xcdUM2RTktXFx1QzcwM1xcdUM3MDUtXFx1QzcxRlxcdUM3MjEtXFx1QzczQlxcdUM3M0QtXFx1Qzc1N1xcdUM3NTktXFx1Qzc3M1xcdUM3NzUtXFx1Qzc4RlxcdUM3OTEtXFx1QzdBQlxcdUM3QUQtXFx1QzdDN1xcdUM3QzktXFx1QzdFM1xcdUM3RTUtXFx1QzdGRlxcdUM4MDEtXFx1QzgxQlxcdUM4MUQtXFx1QzgzN1xcdUM4MzktXFx1Qzg1M1xcdUM4NTUtXFx1Qzg2RlxcdUM4NzEtXFx1Qzg4QlxcdUM4OEQtXFx1QzhBN1xcdUM4QTktXFx1QzhDM1xcdUM4QzUtXFx1QzhERlxcdUM4RTEtXFx1QzhGQlxcdUM4RkQtXFx1QzkxN1xcdUM5MTktXFx1QzkzM1xcdUM5MzUtXFx1Qzk0RlxcdUM5NTEtXFx1Qzk2QlxcdUM5NkQtXFx1Qzk4N1xcdUM5ODktXFx1QzlBM1xcdUM5QTUtXFx1QzlCRlxcdUM5QzEtXFx1QzlEQlxcdUM5REQtXFx1QzlGN1xcdUM5RjktXFx1Q0ExM1xcdUNBMTUtXFx1Q0EyRlxcdUNBMzEtXFx1Q0E0QlxcdUNBNEQtXFx1Q0E2N1xcdUNBNjktXFx1Q0E4M1xcdUNBODUtXFx1Q0E5RlxcdUNBQTEtXFx1Q0FCQlxcdUNBQkQtXFx1Q0FEN1xcdUNBRDktXFx1Q0FGM1xcdUNBRjUtXFx1Q0IwRlxcdUNCMTEtXFx1Q0IyQlxcdUNCMkQtXFx1Q0I0N1xcdUNCNDktXFx1Q0I2M1xcdUNCNjUtXFx1Q0I3RlxcdUNCODEtXFx1Q0I5QlxcdUNCOUQtXFx1Q0JCN1xcdUNCQjktXFx1Q0JEM1xcdUNCRDUtXFx1Q0JFRlxcdUNCRjEtXFx1Q0MwQlxcdUNDMEQtXFx1Q0MyN1xcdUNDMjktXFx1Q0M0M1xcdUNDNDUtXFx1Q0M1RlxcdUNDNjEtXFx1Q0M3QlxcdUNDN0QtXFx1Q0M5N1xcdUNDOTktXFx1Q0NCM1xcdUNDQjUtXFx1Q0NDRlxcdUNDRDEtXFx1Q0NFQlxcdUNDRUQtXFx1Q0QwN1xcdUNEMDktXFx1Q0QyM1xcdUNEMjUtXFx1Q0QzRlxcdUNENDEtXFx1Q0Q1QlxcdUNENUQtXFx1Q0Q3N1xcdUNENzktXFx1Q0Q5M1xcdUNEOTUtXFx1Q0RBRlxcdUNEQjEtXFx1Q0RDQlxcdUNEQ0QtXFx1Q0RFN1xcdUNERTktXFx1Q0UwM1xcdUNFMDUtXFx1Q0UxRlxcdUNFMjEtXFx1Q0UzQlxcdUNFM0QtXFx1Q0U1N1xcdUNFNTktXFx1Q0U3M1xcdUNFNzUtXFx1Q0U4RlxcdUNFOTEtXFx1Q0VBQlxcdUNFQUQtXFx1Q0VDN1xcdUNFQzktXFx1Q0VFM1xcdUNFRTUtXFx1Q0VGRlxcdUNGMDEtXFx1Q0YxQlxcdUNGMUQtXFx1Q0YzN1xcdUNGMzktXFx1Q0Y1M1xcdUNGNTUtXFx1Q0Y2RlxcdUNGNzEtXFx1Q0Y4QlxcdUNGOEQtXFx1Q0ZBN1xcdUNGQTktXFx1Q0ZDM1xcdUNGQzUtXFx1Q0ZERlxcdUNGRTEtXFx1Q0ZGQlxcdUNGRkQtXFx1RDAxN1xcdUQwMTktXFx1RDAzM1xcdUQwMzUtXFx1RDA0RlxcdUQwNTEtXFx1RDA2QlxcdUQwNkQtXFx1RDA4N1xcdUQwODktXFx1RDBBM1xcdUQwQTUtXFx1RDBCRlxcdUQwQzEtXFx1RDBEQlxcdUQwREQtXFx1RDBGN1xcdUQwRjktXFx1RDExM1xcdUQxMTUtXFx1RDEyRlxcdUQxMzEtXFx1RDE0QlxcdUQxNEQtXFx1RDE2N1xcdUQxNjktXFx1RDE4M1xcdUQxODUtXFx1RDE5RlxcdUQxQTEtXFx1RDFCQlxcdUQxQkQtXFx1RDFEN1xcdUQxRDktXFx1RDFGM1xcdUQxRjUtXFx1RDIwRlxcdUQyMTEtXFx1RDIyQlxcdUQyMkQtXFx1RDI0N1xcdUQyNDktXFx1RDI2M1xcdUQyNjUtXFx1RDI3RlxcdUQyODEtXFx1RDI5QlxcdUQyOUQtXFx1RDJCN1xcdUQyQjktXFx1RDJEM1xcdUQyRDUtXFx1RDJFRlxcdUQyRjEtXFx1RDMwQlxcdUQzMEQtXFx1RDMyN1xcdUQzMjktXFx1RDM0M1xcdUQzNDUtXFx1RDM1RlxcdUQzNjEtXFx1RDM3QlxcdUQzN0QtXFx1RDM5N1xcdUQzOTktXFx1RDNCM1xcdUQzQjUtXFx1RDNDRlxcdUQzRDEtXFx1RDNFQlxcdUQzRUQtXFx1RDQwN1xcdUQ0MDktXFx1RDQyM1xcdUQ0MjUtXFx1RDQzRlxcdUQ0NDEtXFx1RDQ1QlxcdUQ0NUQtXFx1RDQ3N1xcdUQ0NzktXFx1RDQ5M1xcdUQ0OTUtXFx1RDRBRlxcdUQ0QjEtXFx1RDRDQlxcdUQ0Q0QtXFx1RDRFN1xcdUQ0RTktXFx1RDUwM1xcdUQ1MDUtXFx1RDUxRlxcdUQ1MjEtXFx1RDUzQlxcdUQ1M0QtXFx1RDU1N1xcdUQ1NTktXFx1RDU3M1xcdUQ1NzUtXFx1RDU4RlxcdUQ1OTEtXFx1RDVBQlxcdUQ1QUQtXFx1RDVDN1xcdUQ1QzktXFx1RDVFM1xcdUQ1RTUtXFx1RDVGRlxcdUQ2MDEtXFx1RDYxQlxcdUQ2MUQtXFx1RDYzN1xcdUQ2MzktXFx1RDY1M1xcdUQ2NTUtXFx1RDY2RlxcdUQ2NzEtXFx1RDY4QlxcdUQ2OEQtXFx1RDZBN1xcdUQ2QTktXFx1RDZDM1xcdUQ2QzUtXFx1RDZERlxcdUQ2RTEtXFx1RDZGQlxcdUQ2RkQtXFx1RDcxN1xcdUQ3MTktXFx1RDczM1xcdUQ3MzUtXFx1RDc0RlxcdUQ3NTEtXFx1RDc2QlxcdUQ3NkQtXFx1RDc4N1xcdUQ3ODktXFx1RDdBM10kLztcbnZhciByZUV4dFBpY3QgPSAvXig/OltcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMxQVxcdTIzMUJcXHUyMzI4XFx1MjM4OFxcdTIzQ0ZcXHUyM0U5LVxcdTIzRjNcXHUyM0Y4LVxcdTIzRkFcXHUyNEMyXFx1MjVBQVxcdTI1QUJcXHUyNUI2XFx1MjVDMFxcdTI1RkItXFx1MjVGRVxcdTI2MDAtXFx1MjYwNVxcdTI2MDctXFx1MjYxMlxcdTI2MTQtXFx1MjY4NVxcdTI2OTAtXFx1MjcwNVxcdTI3MDgtXFx1MjcxMlxcdTI3MTRcXHUyNzE2XFx1MjcxRFxcdTI3MjFcXHUyNzI4XFx1MjczM1xcdTI3MzRcXHUyNzQ0XFx1Mjc0N1xcdTI3NENcXHUyNzRFXFx1Mjc1My1cXHUyNzU1XFx1Mjc1N1xcdTI3NjMtXFx1Mjc2N1xcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwMC1cXHVEQ0ZGXFx1REQwRC1cXHVERDBGXFx1REQyRlxcdURENkMtXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdUREQUQtXFx1RERFNVxcdURFMDEtXFx1REUwRlxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTNBXFx1REUzQy1cXHVERTNGXFx1REU0OS1cXHVERkZBXXxcXHVEODNEW1xcdURDMDAtXFx1REQzRFxcdURENDYtXFx1REU0RlxcdURFODAtXFx1REVGRlxcdURGNzQtXFx1REY3RlxcdURGRDUtXFx1REZGRl18XFx1RDgzRVtcXHVEQzBDLVxcdURDMEZcXHVEQzQ4LVxcdURDNEZcXHVEQzVBLVxcdURDNUZcXHVEQzg4LVxcdURDOEZcXHVEQ0FFLVxcdURDRkZcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURFRkZdfFxcdUQ4M0ZbXFx1REMwMC1cXHVERkZEXSkkLztcblxudmFyIGdldENvZGVwb2ludFR5cGUgPSAoY2hhciwgY29kZSkgPT4ge1xuICB2YXIgdHlwZSA9IENvZGVwb2ludFR5cGUuQW55O1xuXG4gIGlmIChjaGFyLnNlYXJjaChyZUV4dGVuZCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dGVuZDtcbiAgfVxuXG4gIGlmIChjb2RlID09PSAweDIwMGQpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuWldKO1xuICB9XG5cbiAgaWYgKGNvZGUgPj0gMHgxZjFlNiAmJiBjb2RlIDw9IDB4MWYxZmYpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUkk7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVQcmVwZW5kKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuUHJlcGVuZDtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZVNwYWNpbmdNYXJrKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuU3BhY2luZ01hcms7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVMKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTDtcbiAgfVxuXG4gIGlmIChjaGFyLnNlYXJjaChyZVYpICE9PSAtMSkge1xuICAgIHR5cGUgfD0gQ29kZXBvaW50VHlwZS5WO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlVCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLlQ7XG4gIH1cblxuICBpZiAoY2hhci5zZWFyY2gocmVMVikgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkxWO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlTFZUKSAhPT0gLTEpIHtcbiAgICB0eXBlIHw9IENvZGVwb2ludFR5cGUuTFZUO1xuICB9XG5cbiAgaWYgKGNoYXIuc2VhcmNoKHJlRXh0UGljdCkgIT09IC0xKSB7XG4gICAgdHlwZSB8PSBDb2RlcG9pbnRUeXBlLkV4dFBpY3Q7XG4gIH1cblxuICByZXR1cm4gdHlwZTtcbn07XG5cbmZ1bmN0aW9uIGludGVyc2VjdHMoeCwgeSkge1xuICByZXR1cm4gKHggJiB5KSAhPT0gMDtcbn1cblxudmFyIE5vbkJvdW5kYXJ5UGFpcnMgPSBbLy8gR0I2XG5bQ29kZXBvaW50VHlwZS5MLCBDb2RlcG9pbnRUeXBlLkwgfCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5MVlRdLCAvLyBHQjdcbltDb2RlcG9pbnRUeXBlLkxWIHwgQ29kZXBvaW50VHlwZS5WLCBDb2RlcG9pbnRUeXBlLlYgfCBDb2RlcG9pbnRUeXBlLlRdLCAvLyBHQjhcbltDb2RlcG9pbnRUeXBlLkxWVCB8IENvZGVwb2ludFR5cGUuVCwgQ29kZXBvaW50VHlwZS5UXSwgLy8gR0I5XG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuRXh0ZW5kIHwgQ29kZXBvaW50VHlwZS5aV0pdLCAvLyBHQjlhXG5bQ29kZXBvaW50VHlwZS5BbnksIENvZGVwb2ludFR5cGUuU3BhY2luZ01hcmtdLCAvLyBHQjliXG5bQ29kZXBvaW50VHlwZS5QcmVwZW5kLCBDb2RlcG9pbnRUeXBlLkFueV0sIC8vIEdCMTFcbltDb2RlcG9pbnRUeXBlLlpXSiwgQ29kZXBvaW50VHlwZS5FeHRQaWN0XSwgLy8gR0IxMiBhbmQgR0IxM1xuW0NvZGVwb2ludFR5cGUuUkksIENvZGVwb2ludFR5cGUuUkldXTtcblxuZnVuY3Rpb24gaXNCb3VuZGFyeVBhaXIobGVmdCwgcmlnaHQpIHtcbiAgcmV0dXJuIE5vbkJvdW5kYXJ5UGFpcnMuZmluZEluZGV4KHIgPT4gaW50ZXJzZWN0cyhsZWZ0LCByWzBdKSAmJiBpbnRlcnNlY3RzKHJpZ2h0LCByWzFdKSkgPT09IC0xO1xufVxuXG52YXIgZW5kaW5nRW1vamlaV0ogPSAvKD86W1xceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyMzg4XFx1MjNDRlxcdTIzRTktXFx1MjNGM1xcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQi1cXHUyNUZFXFx1MjYwMC1cXHUyNjA1XFx1MjYwNy1cXHUyNjEyXFx1MjYxNC1cXHUyNjg1XFx1MjY5MC1cXHUyNzA1XFx1MjcwOC1cXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MjhcXHUyNzMzXFx1MjczNFxcdTI3NDRcXHUyNzQ3XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc2My1cXHUyNzY3XFx1Mjc5NS1cXHUyNzk3XFx1MjdBMVxcdTI3QjBcXHUyN0JGXFx1MjkzNFxcdTI5MzVcXHUyQjA1LVxcdTJCMDdcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVEQzAwLVxcdURDRkZcXHVERDBELVxcdUREMEZcXHVERDJGXFx1REQ2Qy1cXHVERDcxXFx1REQ3RVxcdUREN0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1RERBRC1cXHVEREU1XFx1REUwMS1cXHVERTBGXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTNDLVxcdURFM0ZcXHVERTQ5LVxcdURGRkFdfFxcdUQ4M0RbXFx1REMwMC1cXHVERDNEXFx1REQ0Ni1cXHVERTRGXFx1REU4MC1cXHVERUZGXFx1REY3NC1cXHVERjdGXFx1REZENS1cXHVERkZGXXxcXHVEODNFW1xcdURDMEMtXFx1REMwRlxcdURDNDgtXFx1REM0RlxcdURDNUEtXFx1REM1RlxcdURDODgtXFx1REM4RlxcdURDQUUtXFx1RENGRlxcdUREMEMtXFx1REQzQVxcdUREM0MtXFx1REQ0NVxcdURENDctXFx1REVGRl18XFx1RDgzRltcXHVEQzAwLVxcdURGRkRdKSg/OltcXHUwMzAwLVxcdTAzNkZcXHUwNDgzLVxcdTA0ODlcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNjEwLVxcdTA2MUFcXHUwNjRCLVxcdTA2NUZcXHUwNjcwXFx1MDZENi1cXHUwNkRDXFx1MDZERi1cXHUwNkU0XFx1MDZFN1xcdTA2RThcXHUwNkVBLVxcdTA2RURcXHUwNzExXFx1MDczMC1cXHUwNzRBXFx1MDdBNi1cXHUwN0IwXFx1MDdFQi1cXHUwN0YzXFx1MDdGRFxcdTA4MTYtXFx1MDgxOVxcdTA4MUItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyRFxcdTA4NTktXFx1MDg1QlxcdTA4RDMtXFx1MDhFMVxcdTA4RTMtXFx1MDkwMlxcdTA5M0FcXHUwOTNDXFx1MDk0MS1cXHUwOTQ4XFx1MDk0RFxcdTA5NTEtXFx1MDk1N1xcdTA5NjJcXHUwOTYzXFx1MDk4MVxcdTA5QkNcXHUwOUJFXFx1MDlDMS1cXHUwOUM0XFx1MDlDRFxcdTA5RDdcXHUwOUUyXFx1MDlFM1xcdTA5RkVcXHUwQTAxXFx1MEEwMlxcdTBBM0NcXHUwQTQxXFx1MEE0MlxcdTBBNDdcXHUwQTQ4XFx1MEE0Qi1cXHUwQTREXFx1MEE1MVxcdTBBNzBcXHUwQTcxXFx1MEE3NVxcdTBBODFcXHUwQTgyXFx1MEFCQ1xcdTBBQzEtXFx1MEFDNVxcdTBBQzdcXHUwQUM4XFx1MEFDRFxcdTBBRTJcXHUwQUUzXFx1MEFGQS1cXHUwQUZGXFx1MEIwMVxcdTBCM0NcXHUwQjNFXFx1MEIzRlxcdTBCNDEtXFx1MEI0NFxcdTBCNERcXHUwQjU1LVxcdTBCNTdcXHUwQjYyXFx1MEI2M1xcdTBCODJcXHUwQkJFXFx1MEJDMFxcdTBCQ0RcXHUwQkQ3XFx1MEMwMFxcdTBDMDRcXHUwQzNFLVxcdTBDNDBcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNjJcXHUwQzYzXFx1MEM4MVxcdTBDQkNcXHUwQ0JGXFx1MENDMlxcdTBDQzZcXHUwQ0NDXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENFMlxcdTBDRTNcXHUwRDAwXFx1MEQwMVxcdTBEM0JcXHUwRDNDXFx1MEQzRVxcdTBENDEtXFx1MEQ0NFxcdTBENERcXHUwRDU3XFx1MEQ2MlxcdTBENjNcXHUwRDgxXFx1MERDQVxcdTBEQ0ZcXHUwREQyLVxcdTBERDRcXHUwREQ2XFx1MERERlxcdTBFMzFcXHUwRTM0LVxcdTBFM0FcXHUwRTQ3LVxcdTBFNEVcXHUwRUIxXFx1MEVCNC1cXHUwRUJDXFx1MEVDOC1cXHUwRUNEXFx1MEYxOFxcdTBGMTlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjcxLVxcdTBGN0VcXHUwRjgwLVxcdTBGODRcXHUwRjg2XFx1MEY4N1xcdTBGOEQtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDJELVxcdTEwMzBcXHUxMDMyLVxcdTEwMzdcXHUxMDM5XFx1MTAzQVxcdTEwM0RcXHUxMDNFXFx1MTA1OFxcdTEwNTlcXHUxMDVFLVxcdTEwNjBcXHUxMDcxLVxcdTEwNzRcXHUxMDgyXFx1MTA4NVxcdTEwODZcXHUxMDhEXFx1MTA5RFxcdTEzNUQtXFx1MTM1RlxcdTE3MTItXFx1MTcxNFxcdTE3MzItXFx1MTczNFxcdTE3NTJcXHUxNzUzXFx1MTc3MlxcdTE3NzNcXHUxN0I0XFx1MTdCNVxcdTE3QjctXFx1MTdCRFxcdTE3QzZcXHUxN0M5LVxcdTE3RDNcXHUxN0REXFx1MTgwQi1cXHUxODBEXFx1MTg4NVxcdTE4ODZcXHUxOEE5XFx1MTkyMC1cXHUxOTIyXFx1MTkyN1xcdTE5MjhcXHUxOTMyXFx1MTkzOS1cXHUxOTNCXFx1MUExN1xcdTFBMThcXHUxQTFCXFx1MUE1NlxcdTFBNTgtXFx1MUE1RVxcdTFBNjBcXHUxQTYyXFx1MUE2NS1cXHUxQTZDXFx1MUE3My1cXHUxQTdDXFx1MUE3RlxcdTFBQjAtXFx1MUFDMFxcdTFCMDAtXFx1MUIwM1xcdTFCMzQtXFx1MUIzQVxcdTFCM0NcXHUxQjQyXFx1MUI2Qi1cXHUxQjczXFx1MUI4MFxcdTFCODFcXHUxQkEyLVxcdTFCQTVcXHUxQkE4XFx1MUJBOVxcdTFCQUItXFx1MUJBRFxcdTFCRTZcXHUxQkU4XFx1MUJFOVxcdTFCRURcXHUxQkVGLVxcdTFCRjFcXHUxQzJDLVxcdTFDMzNcXHUxQzM2XFx1MUMzN1xcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNFMFxcdTFDRTItXFx1MUNFOFxcdTFDRURcXHUxQ0Y0XFx1MUNGOFxcdTFDRjlcXHUxREMwLVxcdTFERjlcXHUxREZCLVxcdTFERkZcXHUyMDBDXFx1MjBEMC1cXHUyMEYwXFx1MkNFRi1cXHUyQ0YxXFx1MkQ3RlxcdTJERTAtXFx1MkRGRlxcdTMwMkEtXFx1MzAyRlxcdTMwOTlcXHUzMDlBXFx1QTY2Ri1cXHVBNjcyXFx1QTY3NC1cXHVBNjdEXFx1QTY5RVxcdUE2OUZcXHVBNkYwXFx1QTZGMVxcdUE4MDJcXHVBODA2XFx1QTgwQlxcdUE4MjVcXHVBODI2XFx1QTgyQ1xcdUE4QzRcXHVBOEM1XFx1QThFMC1cXHVBOEYxXFx1QThGRlxcdUE5MjYtXFx1QTkyRFxcdUE5NDctXFx1QTk1MVxcdUE5ODAtXFx1QTk4MlxcdUE5QjNcXHVBOUI2LVxcdUE5QjlcXHVBOUJDXFx1QTlCRFxcdUE5RTVcXHVBQTI5LVxcdUFBMkVcXHVBQTMxXFx1QUEzMlxcdUFBMzVcXHVBQTM2XFx1QUE0M1xcdUFBNENcXHVBQTdDXFx1QUFCMFxcdUFBQjItXFx1QUFCNFxcdUFBQjdcXHVBQUI4XFx1QUFCRVxcdUFBQkZcXHVBQUMxXFx1QUFFQ1xcdUFBRURcXHVBQUY2XFx1QUJFNVxcdUFCRThcXHVBQkVEXFx1RkIxRVxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZGOUVcXHVGRjlGXXxcXHVEODAwW1xcdURERkRcXHVERUUwXFx1REY3Ni1cXHVERjdBXXxcXHVEODAyW1xcdURFMDEtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTBGXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFRTVcXHVERUU2XXxcXHVEODAzW1xcdUREMjQtXFx1REQyN1xcdURFQUJcXHVERUFDXFx1REY0Ni1cXHVERjUwXXxcXHVEODA0W1xcdURDMDFcXHVEQzM4LVxcdURDNDZcXHVEQzdGLVxcdURDODFcXHVEQ0IzLVxcdURDQjZcXHVEQ0I5XFx1RENCQVxcdUREMDAtXFx1REQwMlxcdUREMjctXFx1REQyQlxcdUREMkQtXFx1REQzNFxcdURENzNcXHVERDgwXFx1REQ4MVxcdUREQjYtXFx1RERCRVxcdUREQzktXFx1RERDQ1xcdUREQ0ZcXHVERTJGLVxcdURFMzFcXHVERTM0XFx1REUzNlxcdURFMzdcXHVERTNFXFx1REVERlxcdURFRTMtXFx1REVFQVxcdURGMDBcXHVERjAxXFx1REYzQlxcdURGM0NcXHVERjNFXFx1REY0MFxcdURGNTdcXHVERjY2LVxcdURGNkNcXHVERjcwLVxcdURGNzRdfFxcdUQ4MDVbXFx1REMzOC1cXHVEQzNGXFx1REM0Mi1cXHVEQzQ0XFx1REM0NlxcdURDNUVcXHVEQ0IwXFx1RENCMy1cXHVEQ0I4XFx1RENCQVxcdURDQkRcXHVEQ0JGXFx1RENDMFxcdURDQzJcXHVEQ0MzXFx1RERBRlxcdUREQjItXFx1RERCNVxcdUREQkNcXHVEREJEXFx1RERCRlxcdUREQzBcXHVERERDXFx1RERERFxcdURFMzMtXFx1REUzQVxcdURFM0RcXHVERTNGXFx1REU0MFxcdURFQUJcXHVERUFEXFx1REVCMC1cXHVERUI1XFx1REVCN1xcdURGMUQtXFx1REYxRlxcdURGMjItXFx1REYyNVxcdURGMjctXFx1REYyQl18XFx1RDgwNltcXHVEQzJGLVxcdURDMzdcXHVEQzM5XFx1REMzQVxcdUREMzBcXHVERDNCXFx1REQzQ1xcdUREM0VcXHVERDQzXFx1RERENC1cXHVEREQ3XFx1REREQVxcdUREREJcXHVEREUwXFx1REUwMS1cXHVERTBBXFx1REUzMy1cXHVERTM4XFx1REUzQi1cXHVERTNFXFx1REU0N1xcdURFNTEtXFx1REU1NlxcdURFNTktXFx1REU1QlxcdURFOEEtXFx1REU5NlxcdURFOThcXHVERTk5XXxcXHVEODA3W1xcdURDMzAtXFx1REMzNlxcdURDMzgtXFx1REMzRFxcdURDM0ZcXHVEQzkyLVxcdURDQTdcXHVEQ0FBLVxcdURDQjBcXHVEQ0IyXFx1RENCM1xcdURDQjVcXHVEQ0I2XFx1REQzMS1cXHVERDM2XFx1REQzQVxcdUREM0NcXHVERDNEXFx1REQzRi1cXHVERDQ1XFx1REQ0N1xcdUREOTBcXHVERDkxXFx1REQ5NVxcdUREOTdcXHVERUYzXFx1REVGNF18XFx1RDgxQVtcXHVERUYwLVxcdURFRjRcXHVERjMwLVxcdURGMzZdfFxcdUQ4MUJbXFx1REY0RlxcdURGOEYtXFx1REY5MlxcdURGRTRdfFxcdUQ4MkZbXFx1REM5RFxcdURDOUVdfFxcdUQ4MzRbXFx1REQ2NVxcdURENjctXFx1REQ2OVxcdURENkUtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNltcXHVERTAwLVxcdURFMzZcXHVERTNCLVxcdURFNkNcXHVERTc1XFx1REU4NFxcdURFOUItXFx1REU5RlxcdURFQTEtXFx1REVBRl18XFx1RDgzOFtcXHVEQzAwLVxcdURDMDZcXHVEQzA4LVxcdURDMThcXHVEQzFCLVxcdURDMjFcXHVEQzIzXFx1REMyNFxcdURDMjYtXFx1REMyQVxcdUREMzAtXFx1REQzNlxcdURFRUMtXFx1REVFRl18XFx1RDgzQVtcXHVEQ0QwLVxcdURDRDZcXHVERDQ0LVxcdURENEFdfFxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXXxcXHVEQjQwW1xcdURDMjAtXFx1REM3RlxcdUREMDAtXFx1RERFRl0pKlxcdTIwMEQkLztcblxudmFyIGVuZHNXaXRoRW1vamlaV0ogPSBzdHIgPT4ge1xuICByZXR1cm4gc3RyLnNlYXJjaChlbmRpbmdFbW9qaVpXSikgIT09IC0xO1xufTtcblxudmFyIGVuZGluZ1JJcyA9IC8oPzpcXHVEODNDW1xcdURERTYtXFx1RERGRl0pKyQvZztcblxudmFyIGVuZHNXaXRoT2RkTnVtYmVyT2ZSSXMgPSBzdHIgPT4ge1xuICB2YXIgbWF0Y2ggPSBzdHIubWF0Y2goZW5kaW5nUklzKTtcblxuICBpZiAobWF0Y2ggPT09IG51bGwpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH0gZWxzZSB7XG4gICAgLy8gQSBSSSBpcyByZXByZXNlbnRlZCBieSBhIHN1cnJvZ2F0ZSBwYWlyLlxuICAgIHZhciBudW1SSXMgPSBtYXRjaFswXS5sZW5ndGggLyAyO1xuICAgIHJldHVybiBudW1SSXMgJSAyID09PSAxO1xuICB9XG59O1xuXG4vKipcclxuICogU2hhcmVkIHRoZSBmdW5jdGlvbiB3aXRoIGlzRWxlbWVudFR5cGUgdXRpbGl0eVxyXG4gKi9cblxudmFyIGlzRWxlbWVudCA9IHZhbHVlID0+IHtcbiAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgIUVkaXRvci5pc0VkaXRvcih2YWx1ZSk7XG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cblxudmFyIEVsZW1lbnQgPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgJ0FuY2VzdG9yJyBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzQW5jZXN0b3IodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgTm9kZS5pc05vZGVMaXN0KHZhbHVlLmNoaWxkcmVuKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBFbGVtZW50YCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzRWxlbWVudCxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGFuIGFycmF5IG9mIGBFbGVtZW50YCBvYmplY3RzLlxyXG4gICAqL1xuICBpc0VsZW1lbnRMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBFbGVtZW50LmlzRWxlbWVudCh2YWwpKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHNldCBvZiBwcm9wcyBpcyBhIHBhcnRpYWwgb2YgRWxlbWVudC5cclxuICAgKi9cbiAgaXNFbGVtZW50UHJvcHMocHJvcHMpIHtcbiAgICByZXR1cm4gcHJvcHMuY2hpbGRyZW4gIT09IHVuZGVmaW5lZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBFbGVtZW50YCBpbnRlcmZhY2UgYW5kIGhhcyBlbGVtZW50S2V5IHdpdGggc2VsZWN0ZWQgdmFsdWUuXHJcbiAgICogRGVmYXVsdCBpdCBjaGVjayB0byBgdHlwZWAga2V5IHZhbHVlXHJcbiAgICovXG4gIGlzRWxlbWVudFR5cGU6IGZ1bmN0aW9uIGlzRWxlbWVudFR5cGUodmFsdWUsIGVsZW1lbnRWYWwpIHtcbiAgICB2YXIgZWxlbWVudEtleSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogJ3R5cGUnO1xuICAgIHJldHVybiBpc0VsZW1lbnQodmFsdWUpICYmIHZhbHVlW2VsZW1lbnRLZXldID09PSBlbGVtZW50VmFsO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGFuIGVsZW1lbnQgbWF0Y2hlcyBzZXQgb2YgcHJvcGVydGllcy5cclxuICAgKlxyXG4gICAqIE5vdGU6IHRoaXMgY2hlY2tzIGN1c3RvbSBwcm9wZXJ0aWVzLCBhbmQgaXQgZG9lcyBub3QgZW5zdXJlIHRoYXQgYW55XHJcbiAgICogY2hpbGRyZW4gYXJlIGVxdWl2YWxlbnQuXHJcbiAgICovXG4gIG1hdGNoZXMoZWxlbWVudCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjaGlsZHJlbicpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbGVtZW50W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkNCA9IFtcInRleHRcIl0sXG4gICAgX2V4Y2x1ZGVkMiQzID0gW1widGV4dFwiXTtcblxuZnVuY3Rpb24gb3duS2V5cyQ4KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ4KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkOChPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDgoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgSVNfRURJVE9SX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgRWRpdG9yID0ge1xuICAvKipcclxuICAgKiBHZXQgdGhlIGFuY2VzdG9yIGFib3ZlIGEgbG9jYXRpb24gaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICBhYm92ZShlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCk7XG4gICAgdmFyIHJldmVyc2UgPSBtb2RlID09PSAnbG93ZXN0JztcblxuICAgIGZvciAodmFyIFtuLCBwXSBvZiBFZGl0b3IubGV2ZWxzKGVkaXRvciwge1xuICAgICAgYXQ6IHBhdGgsXG4gICAgICB2b2lkcyxcbiAgICAgIG1hdGNoLFxuICAgICAgcmV2ZXJzZVxuICAgIH0pKSB7XG4gICAgICBpZiAoIVRleHQuaXNUZXh0KG4pICYmICFQYXRoLmVxdWFscyhwYXRoLCBwKSkge1xuICAgICAgICByZXR1cm4gW24sIHBdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBBZGQgYSBjdXN0b20gcHJvcGVydHkgdG8gdGhlIGxlYWYgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBjb2xsYXBzZWQsIHRoZSBtYXJrcyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxyXG4gICAqIGBlZGl0b3IubWFya3NgIHByb3BlcnR5IGluc3RlYWQsIGFuZCBhcHBsaWVkIHdoZW4gdGV4dCBpcyBpbnNlcnRlZCBuZXh0LlxyXG4gICAqL1xuICBhZGRNYXJrKGVkaXRvciwga2V5LCB2YWx1ZSkge1xuICAgIGVkaXRvci5hZGRNYXJrKGtleSwgdmFsdWUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYWZ0ZXIgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgYWZ0ZXIoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgYW5jaG9yID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgdmFyIHtcbiAgICAgIGRpc3RhbmNlID0gMVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2VcbiAgICB9KSkpIHtcbiAgICAgIGlmIChkID4gZGlzdGFuY2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmIChkICE9PSAwKSB7XG4gICAgICAgIHRhcmdldCA9IHA7XG4gICAgICB9XG5cbiAgICAgIGQrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgcG9pbnQgYmVmb3JlIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGJlZm9yZShlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBhbmNob3IgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBbXSk7XG4gICAgdmFyIGZvY3VzID0gRWRpdG9yLnBvaW50KGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICB9KTtcbiAgICB2YXIgcmFuZ2UgPSB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH07XG4gICAgdmFyIHtcbiAgICAgIGRpc3RhbmNlID0gMVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBkID0gMDtcbiAgICB2YXIgdGFyZ2V0O1xuXG4gICAgZm9yICh2YXIgcCBvZiBFZGl0b3IucG9zaXRpb25zKGVkaXRvciwgX29iamVjdFNwcmVhZCQ4KF9vYmplY3RTcHJlYWQkOCh7fSwgb3B0aW9ucyksIHt9LCB7XG4gICAgICBhdDogcmFuZ2UsXG4gICAgICByZXZlcnNlOiB0cnVlXG4gICAgfSkpKSB7XG4gICAgICBpZiAoZCA+IGRpc3RhbmNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBpZiAoZCAhPT0gMCkge1xuICAgICAgICB0YXJnZXQgPSBwO1xuICAgICAgfVxuXG4gICAgICBkKys7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRhcmdldDtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGJhY2t3YXJkIGZyb20gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVCYWNrd2FyZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHVuaXQgPSAnY2hhcmFjdGVyJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVCYWNrd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgY29udGVudCBpbiB0aGUgZWRpdG9yIGZvcndhcmQgZnJvbSB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICovXG4gIGRlbGV0ZUZvcndhcmQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICBlZGl0b3IuZGVsZXRlRm9yd2FyZCh1bml0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBEZWxldGUgdGhlIGNvbnRlbnQgaW4gdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqL1xuICBkZWxldGVGcmFnbWVudChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGRpcmVjdGlvbiA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIGVkaXRvci5kZWxldGVGcmFnbWVudChkaXJlY3Rpb24pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZWRnZXMoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBbRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpLCBFZGl0b3IuZW5kKGVkaXRvciwgYXQpXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBlbmQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ2VuZCdcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGZpcnN0IG5vZGUgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZmlyc3QoZWRpdG9yLCBhdCkge1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICAgIHJldHVybiBFZGl0b3Iubm9kZShlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgZnJhZ21lbnQgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgZnJhZ21lbnQoZWRpdG9yLCBhdCkge1xuICAgIHZhciByYW5nZSA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICB2YXIgZnJhZ21lbnQgPSBOb2RlLmZyYWdtZW50KGVkaXRvciwgcmFuZ2UpO1xuICAgIHJldHVybiBmcmFnbWVudDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgaGFzIGJsb2NrIGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNCbG9ja3MoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgcmV0dXJuIGVsZW1lbnQuY2hpbGRyZW4uc29tZShuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbikpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgbm9kZSBoYXMgaW5saW5lIGFuZCB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNJbmxpbmVzKGVkaXRvciwgZWxlbWVudCkge1xuICAgIHJldHVybiBlbGVtZW50LmNoaWxkcmVuLnNvbWUobiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBub2RlIGhhcyB0ZXh0IGNoaWxkcmVuLlxyXG4gICAqL1xuICBoYXNUZXh0cyhlZGl0b3IsIGVsZW1lbnQpIHtcbiAgICByZXR1cm4gZWxlbWVudC5jaGlsZHJlbi5ldmVyeShuID0+IFRleHQuaXNUZXh0KG4pKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBibG9jayBicmVhayBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0QnJlYWsoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBzb2Z0IGJyZWFrIGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFNvZnRCcmVhayhlZGl0b3IpIHtcbiAgICBlZGl0b3IuaW5zZXJ0U29mdEJyZWFrKCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgZnJhZ21lbnQgYXQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIHNlbGVjdGlvbiBpcyBjdXJyZW50bHkgZXhwYW5kZWQsIGl0IHdpbGwgYmUgZGVsZXRlZCBmaXJzdC5cclxuICAgKi9cbiAgaW5zZXJ0RnJhZ21lbnQoZWRpdG9yLCBmcmFnbWVudCkge1xuICAgIGVkaXRvci5pbnNlcnRGcmFnbWVudChmcmFnbWVudCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgbm9kZSBhdCB0aGUgY3VycmVudCBzZWxlY3Rpb24uXHJcbiAgICpcclxuICAgKiBJZiB0aGUgc2VsZWN0aW9uIGlzIGN1cnJlbnRseSBleHBhbmRlZCwgaXQgd2lsbCBiZSBkZWxldGVkIGZpcnN0LlxyXG4gICAqL1xuICBpbnNlcnROb2RlKGVkaXRvciwgbm9kZSkge1xuICAgIGVkaXRvci5pbnNlcnROb2RlKG5vZGUpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEluc2VydCB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGV4cGFuZGVkLCBpdCB3aWxsIGJlIGRlbGV0ZWQgZmlyc3QuXHJcbiAgICovXG4gIGluc2VydFRleHQoZWRpdG9yLCB0ZXh0KSB7XG4gICAgZWRpdG9yLmluc2VydFRleHQodGV4dCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGJsb2NrIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzQmxvY2soZWRpdG9yLCB2YWx1ZSkge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgJiYgIWVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhbiBgRWRpdG9yYCBvYmplY3QuXHJcbiAgICovXG4gIGlzRWRpdG9yKHZhbHVlKSB7XG4gICAgdmFyIGNhY2hlZElzRWRpdG9yID0gSVNfRURJVE9SX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoY2FjaGVkSXNFZGl0b3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGNhY2hlZElzRWRpdG9yO1xuICAgIH1cblxuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgaXNFZGl0b3IgPSB0eXBlb2YgdmFsdWUuYWRkTWFyayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuYXBwbHkgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmRlbGV0ZUJhY2t3YXJkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVGb3J3YXJkID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5kZWxldGVGcmFnbWVudCA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0QnJlYWsgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFNvZnRCcmVhayA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgdmFsdWUuaW5zZXJ0RnJhZ21lbnQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydE5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmluc2VydFRleHQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLmlzSW5saW5lID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5pc1ZvaWQgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm5vcm1hbGl6ZU5vZGUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIHZhbHVlLm9uQ2hhbmdlID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiB2YWx1ZS5yZW1vdmVNYXJrID09PSAnZnVuY3Rpb24nICYmICh2YWx1ZS5tYXJrcyA9PT0gbnVsbCB8fCBpc1BsYWluT2JqZWN0KHZhbHVlLm1hcmtzKSkgJiYgKHZhbHVlLnNlbGVjdGlvbiA9PT0gbnVsbCB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlLnNlbGVjdGlvbikpICYmIE5vZGUuaXNOb2RlTGlzdCh2YWx1ZS5jaGlsZHJlbikgJiYgT3BlcmF0aW9uLmlzT3BlcmF0aW9uTGlzdCh2YWx1ZS5vcGVyYXRpb25zKTtcbiAgICBJU19FRElUT1JfQ0FDSEUuc2V0KHZhbHVlLCBpc0VkaXRvcik7XG4gICAgcmV0dXJuIGlzRWRpdG9yO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgdGhlIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBpc0VuZChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHZhciBlbmQgPSBFZGl0b3IuZW5kKGVkaXRvciwgYXQpO1xuICAgIHJldHVybiBQb2ludC5lcXVhbHMocG9pbnQsIGVuZCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBhbiBlZGdlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIGlzRWRnZShlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkgfHwgRWRpdG9yLmlzRW5kKGVkaXRvciwgcG9pbnQsIGF0KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhbiBlbGVtZW50IGlzIGVtcHR5LCBhY2NvdW50aW5nIGZvciB2b2lkIG5vZGVzLlxyXG4gICAqL1xuICBpc0VtcHR5KGVkaXRvciwgZWxlbWVudCkge1xuICAgIHZhciB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBlbGVtZW50O1xuICAgIHZhciBbZmlyc3RdID0gY2hpbGRyZW47XG4gICAgcmV0dXJuIGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBjaGlsZHJlbi5sZW5ndGggPT09IDEgJiYgVGV4dC5pc1RleHQoZmlyc3QpICYmIGZpcnN0LnRleHQgPT09ICcnICYmICFlZGl0b3IuaXNWb2lkKGVsZW1lbnQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYW4gaW5saW5lIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzSW5saW5lKGVkaXRvciwgdmFsdWUpIHtcbiAgICByZXR1cm4gRWxlbWVudC5pc0VsZW1lbnQodmFsdWUpICYmIGVkaXRvci5pc0lubGluZSh2YWx1ZSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGVkaXRvciBpcyBjdXJyZW50bHkgbm9ybWFsaXppbmcgYWZ0ZXIgZWFjaCBvcGVyYXRpb24uXHJcbiAgICovXG4gIGlzTm9ybWFsaXppbmcoZWRpdG9yKSB7XG4gICAgdmFyIGlzTm9ybWFsaXppbmcgPSBOT1JNQUxJWklORy5nZXQoZWRpdG9yKTtcbiAgICByZXR1cm4gaXNOb3JtYWxpemluZyA9PT0gdW5kZWZpbmVkID8gdHJ1ZSA6IGlzTm9ybWFsaXppbmc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyB0aGUgc3RhcnQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgaXNTdGFydChlZGl0b3IsIHBvaW50LCBhdCkge1xuICAgIC8vIFBFUkY6IElmIHRoZSBvZmZzZXQgaXNuJ3QgYDBgIHdlIGtub3cgaXQncyBub3QgdGhlIHN0YXJ0LlxuICAgIGlmIChwb2ludC5vZmZzZXQgIT09IDApIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnQgPSBFZGl0b3Iuc3RhcnQoZWRpdG9yLCBhdCk7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhwb2ludCwgc3RhcnQpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaXMgYSB2b2lkIGBFbGVtZW50YCBvYmplY3QuXHJcbiAgICovXG4gIGlzVm9pZChlZGl0b3IsIHZhbHVlKSB7XG4gICAgcmV0dXJuIEVsZW1lbnQuaXNFbGVtZW50KHZhbHVlKSAmJiBlZGl0b3IuaXNWb2lkKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGxhc3Qgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsYXN0KGVkaXRvciwgYXQpIHtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIHtcbiAgICAgIGVkZ2U6ICdlbmQnXG4gICAgfSk7XG4gICAgcmV0dXJuIEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsZWFmIHRleHQgbm9kZSBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBsZWFmKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCBvcHRpb25zKTtcbiAgICB2YXIgbm9kZSA9IE5vZGUubGVhZihlZGl0b3IsIHBhdGgpO1xuICAgIHJldHVybiBbbm9kZSwgcGF0aF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSXRlcmF0ZSB0aHJvdWdoIGFsbCBvZiB0aGUgbGV2ZWxzIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gICpsZXZlbHMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICByZXZlcnNlID0gZmFsc2UsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgbGV2ZWxzID0gW107XG4gICAgdmFyIHBhdGggPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0KTtcblxuICAgIGZvciAodmFyIFtuLCBwXSBvZiBOb2RlLmxldmVscyhlZGl0b3IsIHBhdGgpKSB7XG4gICAgICBpZiAoIW1hdGNoKG4sIHApKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBsZXZlbHMucHVzaChbbiwgcF0pO1xuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocmV2ZXJzZSkge1xuICAgICAgbGV2ZWxzLnJldmVyc2UoKTtcbiAgICB9XG5cbiAgICB5aWVsZCogbGV2ZWxzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWFya3MgdGhhdCB3b3VsZCBiZSBhZGRlZCB0byB0ZXh0IGF0IHRoZSBjdXJyZW50IHNlbGVjdGlvbi5cclxuICAgKi9cbiAgbWFya3MoZWRpdG9yKSB7XG4gICAgdmFyIHtcbiAgICAgIG1hcmtzLFxuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAobWFya3MpIHtcbiAgICAgIHJldHVybiBtYXJrcztcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNFeHBhbmRlZChzZWxlY3Rpb24pKSB7XG4gICAgICB2YXIgW21hdGNoXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0XG4gICAgICB9KTtcblxuICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgIHZhciBbX25vZGVdID0gbWF0Y2g7XG5cbiAgICAgICAgdmFyIF9yZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKF9ub2RlLCBfZXhjbHVkZWQkNCk7XG5cbiAgICAgICAgcmV0dXJuIF9yZXN0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBhbmNob3JcbiAgICB9ID0gc2VsZWN0aW9uO1xuICAgIHZhciB7XG4gICAgICBwYXRoXG4gICAgfSA9IGFuY2hvcjtcbiAgICB2YXIgW25vZGVdID0gRWRpdG9yLmxlYWYoZWRpdG9yLCBwYXRoKTtcblxuICAgIGlmIChhbmNob3Iub2Zmc2V0ID09PSAwKSB7XG4gICAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dFxuICAgICAgfSk7XG4gICAgICB2YXIgYmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbilcbiAgICAgIH0pO1xuXG4gICAgICBpZiAocHJldiAmJiBibG9jaykge1xuICAgICAgICB2YXIgW3ByZXZOb2RlLCBwcmV2UGF0aF0gPSBwcmV2O1xuICAgICAgICB2YXIgWywgYmxvY2tQYXRoXSA9IGJsb2NrO1xuXG4gICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoYmxvY2tQYXRoLCBwcmV2UGF0aCkpIHtcbiAgICAgICAgICBub2RlID0gcHJldk5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyJDMpO1xuXG4gICAgcmV0dXJuIHJlc3Q7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBtYXRjaGluZyBub2RlIGluIHRoZSBicmFuY2ggb2YgdGhlIGRvY3VtZW50IGFmdGVyIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIG5leHQoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50QWZ0ZXJMb2NhdGlvbiA9IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCB7XG4gICAgICB2b2lkc1xuICAgIH0pO1xuICAgIGlmICghcG9pbnRBZnRlckxvY2F0aW9uKSByZXR1cm47XG4gICAgdmFyIFssIHRvXSA9IEVkaXRvci5sYXN0KGVkaXRvciwgW10pO1xuICAgIHZhciBzcGFuID0gW3BvaW50QWZ0ZXJMb2NhdGlvbi5wYXRoLCB0b107XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgbmV4dCBub2RlIGZyb20gdGhlIHJvb3Qgbm9kZSFcIik7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgdmFyIFtwYXJlbnRdID0gRWRpdG9yLnBhcmVudChlZGl0b3IsIGF0KTtcblxuICAgICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBbbmV4dF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogc3BhbixcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBub2RlIGF0IGEgbG9jYXRpb24uXHJcbiAgICovXG4gIG5vZGUoZWRpdG9yLCBhdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGF0aCA9IEVkaXRvci5wYXRoKGVkaXRvciwgYXQsIG9wdGlvbnMpO1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcbiAgICByZXR1cm4gW25vZGUsIHBhdGhdO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIG5vZGVzIGluIHRoZSBFZGl0b3IuXHJcbiAgICovXG4gICpub2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgIG1vZGUgPSAnYWxsJyxcbiAgICAgIHVuaXZlcnNhbCA9IGZhbHNlLFxuICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBtYXRjaFxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFtYXRjaCkge1xuICAgICAgbWF0Y2ggPSAoKSA9PiB0cnVlO1xuICAgIH1cblxuICAgIGlmICghYXQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZnJvbTtcbiAgICB2YXIgdG87XG5cbiAgICBpZiAoU3Bhbi5pc1NwYW4oYXQpKSB7XG4gICAgICBmcm9tID0gYXRbMF07XG4gICAgICB0byA9IGF0WzFdO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgZmlyc3QgPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICAgIGVkZ2U6ICdzdGFydCdcbiAgICAgIH0pO1xuICAgICAgdmFyIGxhc3QgPSBFZGl0b3IucGF0aChlZGl0b3IsIGF0LCB7XG4gICAgICAgIGVkZ2U6ICdlbmQnXG4gICAgICB9KTtcbiAgICAgIGZyb20gPSByZXZlcnNlID8gbGFzdCA6IGZpcnN0O1xuICAgICAgdG8gPSByZXZlcnNlID8gZmlyc3QgOiBsYXN0O1xuICAgIH1cblxuICAgIHZhciBub2RlRW50cmllcyA9IE5vZGUubm9kZXMoZWRpdG9yLCB7XG4gICAgICByZXZlcnNlLFxuICAgICAgZnJvbSxcbiAgICAgIHRvLFxuICAgICAgcGFzczogX3JlZiA9PiB7XG4gICAgICAgIHZhciBbbl0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gdm9pZHMgPyBmYWxzZSA6IEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBuKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuICAgIHZhciBoaXQ7XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2Ygbm9kZUVudHJpZXMpIHtcbiAgICAgIHZhciBpc0xvd2VyID0gaGl0ICYmIFBhdGguY29tcGFyZShwYXRoLCBoaXRbMV0pID09PSAwOyAvLyBJbiBoaWdoZXN0IG1vZGUgYW55IG5vZGUgbG93ZXIgdGhhbiB0aGUgbGFzdCBoaXQgaXMgbm90IGEgbWF0Y2guXG5cbiAgICAgIGlmIChtb2RlID09PSAnaGlnaGVzdCcgJiYgaXNMb3dlcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFtYXRjaChub2RlLCBwYXRoKSkge1xuICAgICAgICAvLyBJZiB3ZSd2ZSBhcnJpdmVkIGF0IGEgbGVhZiB0ZXh0IG5vZGUgdGhhdCBpcyBub3QgbG93ZXIgdGhhbiB0aGUgbGFzdFxuICAgICAgICAvLyBoaXQsIHRoZW4gd2UndmUgZm91bmQgYSBicmFuY2ggdGhhdCBkb2Vzbid0IGluY2x1ZGUgYSBtYXRjaCwgd2hpY2hcbiAgICAgICAgLy8gbWVhbnMgdGhlIG1hdGNoIGlzIG5vdCB1bml2ZXJzYWwuXG4gICAgICAgIGlmICh1bml2ZXJzYWwgJiYgIWlzTG93ZXIgJiYgVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgIH0gLy8gSWYgdGhlcmUncyBhIG1hdGNoIGFuZCBpdCdzIGxvd2VyIHRoYW4gdGhlIGxhc3QsIHVwZGF0ZSB0aGUgaGl0LlxuXG5cbiAgICAgIGlmIChtb2RlID09PSAnbG93ZXN0JyAmJiBpc0xvd2VyKSB7XG4gICAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9IC8vIEluIGxvd2VzdCBtb2RlIHdlIGVtaXQgdGhlIGxhc3QgaGl0LCBvbmNlIGl0J3MgZ3VhcmFudGVlZCBsb3dlc3QuXG5cblxuICAgICAgdmFyIGVtaXQgPSBtb2RlID09PSAnbG93ZXN0JyA/IGhpdCA6IFtub2RlLCBwYXRoXTtcblxuICAgICAgaWYgKGVtaXQpIHtcbiAgICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbWl0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB5aWVsZCBlbWl0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGhpdCA9IFtub2RlLCBwYXRoXTtcbiAgICB9IC8vIFNpbmNlIGxvd2VzdCBpcyBhbHdheXMgZW1pdHRpbmcgb25lIGJlaGluZCwgY2F0Y2ggdXAgYXQgdGhlIGVuZC5cblxuXG4gICAgaWYgKG1vZGUgPT09ICdsb3dlc3QnICYmIGhpdCkge1xuICAgICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgICBtYXRjaGVzLnB1c2goaGl0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHlpZWxkIGhpdDtcbiAgICAgIH1cbiAgICB9IC8vIFVuaXZlcnNhbCBkZWZlcnMgdG8gZW5zdXJlIHRoYXQgdGhlIG1hdGNoIG9jY3VycyBpbiBldmVyeSBicmFuY2gsIHNvIHdlXG4gICAgLy8geWllbGQgYWxsIG9mIHRoZSBtYXRjaGVzIGFmdGVyIGl0ZXJhdGluZy5cblxuXG4gICAgaWYgKHVuaXZlcnNhbCkge1xuICAgICAgeWllbGQqIG1hdGNoZXM7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIE5vcm1hbGl6ZSBhbnkgZGlydHkgb2JqZWN0cyBpbiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBub3JtYWxpemUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBmb3JjZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICB2YXIgZ2V0RGlydHlQYXRocyA9IGVkaXRvciA9PiB7XG4gICAgICByZXR1cm4gRElSVFlfUEFUSFMuZ2V0KGVkaXRvcikgfHwgW107XG4gICAgfTtcblxuICAgIHZhciBnZXREaXJ0eVBhdGhLZXlzID0gZWRpdG9yID0+IHtcbiAgICAgIHJldHVybiBESVJUWV9QQVRIX0tFWVMuZ2V0KGVkaXRvcikgfHwgbmV3IFNldCgpO1xuICAgIH07XG5cbiAgICB2YXIgcG9wRGlydHlQYXRoID0gZWRpdG9yID0+IHtcbiAgICAgIHZhciBwYXRoID0gZ2V0RGlydHlQYXRocyhlZGl0b3IpLnBvcCgpO1xuICAgICAgdmFyIGtleSA9IHBhdGguam9pbignLCcpO1xuICAgICAgZ2V0RGlydHlQYXRoS2V5cyhlZGl0b3IpLmRlbGV0ZShrZXkpO1xuICAgICAgcmV0dXJuIHBhdGg7XG4gICAgfTtcblxuICAgIGlmICghRWRpdG9yLmlzTm9ybWFsaXppbmcoZWRpdG9yKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChmb3JjZSkge1xuICAgICAgdmFyIGFsbFBhdGhzID0gQXJyYXkuZnJvbShOb2RlLm5vZGVzKGVkaXRvciksIF9yZWYyID0+IHtcbiAgICAgICAgdmFyIFssIHBdID0gX3JlZjI7XG4gICAgICAgIHJldHVybiBwO1xuICAgICAgfSk7XG4gICAgICB2YXIgYWxsUGF0aEtleXMgPSBuZXcgU2V0KGFsbFBhdGhzLm1hcChwID0+IHAuam9pbignLCcpKSk7XG4gICAgICBESVJUWV9QQVRIUy5zZXQoZWRpdG9yLCBhbGxQYXRocyk7XG4gICAgICBESVJUWV9QQVRIX0tFWVMuc2V0KGVkaXRvciwgYWxsUGF0aEtleXMpO1xuICAgIH1cblxuICAgIGlmIChnZXREaXJ0eVBhdGhzKGVkaXRvcikubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIC8qXHJcbiAgICAgICAgRml4IGRpcnR5IGVsZW1lbnRzIHdpdGggbm8gY2hpbGRyZW4uXHJcbiAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoKSBkb2VzIGZpeCB0aGlzLCBidXQgc29tZSBub3JtYWxpemF0aW9uIGZpeGVzIGFsc28gcmVxdWlyZSBpdCB0byB3b3JrLlxyXG4gICAgICAgIFJ1bm5pbmcgYW4gaW5pdGlhbCBwYXNzIGF2b2lkcyB0aGUgY2F0Y2gtMjIgcmFjZSBjb25kaXRpb24uXHJcbiAgICAgICovXG4gICAgICBmb3IgKHZhciBkaXJ0eVBhdGggb2YgZ2V0RGlydHlQYXRocyhlZGl0b3IpKSB7XG4gICAgICAgIGlmIChOb2RlLmhhcyhlZGl0b3IsIGRpcnR5UGF0aCkpIHtcbiAgICAgICAgICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIGRpcnR5UGF0aCk7XG4gICAgICAgICAgdmFyIFtub2RlLCBfXSA9IGVudHJ5O1xuICAgICAgICAgIC8qXHJcbiAgICAgICAgICAgIFRoZSBkZWZhdWx0IG5vcm1hbGl6ZXIgaW5zZXJ0cyBhbiBlbXB0eSB0ZXh0IG5vZGUgaW4gdGhpcyBzY2VuYXJpbywgYnV0IGl0IGNhbiBiZSBjdXN0b21pc2VkLlxyXG4gICAgICAgICAgICBTbyB0aGVyZSBpcyBzb21lIHJpc2sgaGVyZS5cclxuICAgICAgICAgICAgICAgICAgICAgICBBcyBsb25nIGFzIHRoZSBub3JtYWxpemVyIG9ubHkgaW5zZXJ0cyBjaGlsZCBub2RlcyBmb3IgdGhpcyBjYXNlIGl0IGlzIHNhZmUgdG8gZG8gaW4gYW55IG9yZGVyO1xyXG4gICAgICAgICAgICBieSBkZWZpbml0aW9uIGFkZGluZyBjaGlsZHJlbiB0byBhbiBlbXB0eSBub2RlIGNhbid0IGNhdXNlIG90aGVyIHBhdGhzIHRvIGNoYW5nZS5cclxuICAgICAgICAgICovXG5cbiAgICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgbm9kZS5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGVkaXRvci5ub3JtYWxpemVOb2RlKGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG1heCA9IGdldERpcnR5UGF0aHMoZWRpdG9yKS5sZW5ndGggKiA0MjsgLy8gSEFDSzogYmV0dGVyIHdheT9cblxuICAgICAgdmFyIG0gPSAwO1xuXG4gICAgICB3aGlsZSAoZ2V0RGlydHlQYXRocyhlZGl0b3IpLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICBpZiAobSA+IG1heCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlxcbiAgICAgICAgICAgIENvdWxkIG5vdCBjb21wbGV0ZWx5IG5vcm1hbGl6ZSB0aGUgZWRpdG9yIGFmdGVyIFwiLmNvbmNhdChtYXgsIFwiIGl0ZXJhdGlvbnMhIFRoaXMgaXMgdXN1YWxseSBkdWUgdG8gaW5jb3JyZWN0IG5vcm1hbGl6YXRpb24gbG9naWMgdGhhdCBsZWF2ZXMgYSBub2RlIGluIGFuIGludmFsaWQgc3RhdGUuXFxuICAgICAgICAgIFwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX2RpcnR5UGF0aCA9IHBvcERpcnR5UGF0aChlZGl0b3IpOyAvLyBJZiB0aGUgbm9kZSBkb2Vzbid0IGV4aXN0IGluIHRoZSB0cmVlLCBpdCBkb2VzIG5vdCBuZWVkIHRvIGJlIG5vcm1hbGl6ZWQuXG5cblxuICAgICAgICBpZiAoTm9kZS5oYXMoZWRpdG9yLCBfZGlydHlQYXRoKSkge1xuICAgICAgICAgIHZhciBfZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIF9kaXJ0eVBhdGgpO1xuXG4gICAgICAgICAgZWRpdG9yLm5vcm1hbGl6ZU5vZGUoX2VudHJ5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIG0rKztcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhcmVudCBub2RlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHBhcmVudChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciBwYXRoID0gRWRpdG9yLnBhdGgoZWRpdG9yLCBhdCwgb3B0aW9ucyk7XG4gICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChwYXRoKTtcbiAgICB2YXIgZW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIHBhcmVudFBhdGgpO1xuICAgIHJldHVybiBlbnRyeTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhdGggb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcGF0aChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBkZXB0aCxcbiAgICAgIGVkZ2VcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgIGlmIChlZGdlID09PSAnc3RhcnQnKSB7XG4gICAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gTm9kZS5maXJzdChlZGl0b3IsIGF0KTtcbiAgICAgICAgYXQgPSBmaXJzdFBhdGg7XG4gICAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICAgIHZhciBbLCBsYXN0UGF0aF0gPSBOb2RlLmxhc3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIGF0ID0gbGFzdFBhdGg7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgICBhdCA9IFJhbmdlLnN0YXJ0KGF0KTtcbiAgICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgICAgYXQgPSBSYW5nZS5lbmQoYXQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYXQgPSBQYXRoLmNvbW1vbihhdC5hbmNob3IucGF0aCwgYXQuZm9jdXMucGF0aCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKFBvaW50LmlzUG9pbnQoYXQpKSB7XG4gICAgICBhdCA9IGF0LnBhdGg7XG4gICAgfVxuXG4gICAgaWYgKGRlcHRoICE9IG51bGwpIHtcbiAgICAgIGF0ID0gYXQuc2xpY2UoMCwgZGVwdGgpO1xuICAgIH1cblxuICAgIHJldHVybiBhdDtcbiAgfSxcblxuICBoYXNQYXRoKGVkaXRvciwgcGF0aCkge1xuICAgIHJldHVybiBOb2RlLmhhcyhlZGl0b3IsIHBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG11dGFibGUgcmVmIGZvciBhIGBQYXRoYCBvYmplY3QsIHdoaWNoIHdpbGwgc3RheSBpbiBzeW5jIGFzIG5ld1xyXG4gICAqIG9wZXJhdGlvbnMgYXJlIGFwcGxpZWQgdG8gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcGF0aFJlZihlZGl0b3IsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IHBhdGgsXG4gICAgICBhZmZpbml0eSxcblxuICAgICAgdW5yZWYoKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgY3VycmVudFxuICAgICAgICB9ID0gcmVmO1xuICAgICAgICB2YXIgcGF0aFJlZnMgPSBFZGl0b3IucGF0aFJlZnMoZWRpdG9yKTtcbiAgICAgICAgcGF0aFJlZnMuZGVsZXRlKHJlZik7XG4gICAgICAgIHJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnQ7XG4gICAgICB9XG5cbiAgICB9O1xuICAgIHZhciByZWZzID0gRWRpdG9yLnBhdGhSZWZzKGVkaXRvcik7XG4gICAgcmVmcy5hZGQocmVmKTtcbiAgICByZXR1cm4gcmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSB0cmFja2VkIHBhdGggcmVmcyBvZiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBwYXRoUmVmcyhlZGl0b3IpIHtcbiAgICB2YXIgcmVmcyA9IFBBVEhfUkVGUy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghcmVmcykge1xuICAgICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgIFBBVEhfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmcztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHN0YXJ0IG9yIGVuZCBwb2ludCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBwb2ludChlZGl0b3IsIGF0KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBlZGdlID0gJ3N0YXJ0J1xuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgdmFyIHBhdGg7XG5cbiAgICAgIGlmIChlZGdlID09PSAnZW5kJykge1xuICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KGVkaXRvciwgYXQpO1xuICAgICAgICBwYXRoID0gbGFzdFBhdGg7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgWywgZmlyc3RQYXRoXSA9IE5vZGUuZmlyc3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIHBhdGggPSBmaXJzdFBhdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBub2RlID0gTm9kZS5nZXQoZWRpdG9yLCBwYXRoKTtcblxuICAgICAgaWYgKCFUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBcIi5jb25jYXQoZWRnZSwgXCIgcG9pbnQgaW4gdGhlIG5vZGUgYXQgcGF0aCBbXCIpLmNvbmNhdChhdCwgXCJdIGJlY2F1c2UgaXQgaGFzIG5vIFwiKS5jb25jYXQoZWRnZSwgXCIgdGV4dCBub2RlLlwiKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldDogZWRnZSA9PT0gJ2VuZCcgPyBub2RlLnRleHQubGVuZ3RoIDogMFxuICAgICAgfTtcbiAgICB9XG5cbiAgICBpZiAoUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICByZXR1cm4gZWRnZSA9PT0gJ3N0YXJ0JyA/IHN0YXJ0IDogZW5kO1xuICAgIH1cblxuICAgIHJldHVybiBhdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDcmVhdGUgYSBtdXRhYmxlIHJlZiBmb3IgYSBgUG9pbnRgIG9iamVjdCwgd2hpY2ggd2lsbCBzdGF5IGluIHN5bmMgYXMgbmV3XHJcbiAgICogb3BlcmF0aW9ucyBhcmUgYXBwbGllZCB0byB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICBwb2ludFJlZihlZGl0b3IsIHBvaW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBhZmZpbml0eSA9ICdmb3J3YXJkJ1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciByZWYgPSB7XG4gICAgICBjdXJyZW50OiBwb2ludCxcbiAgICAgIGFmZmluaXR5LFxuXG4gICAgICB1bnJlZigpIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBjdXJyZW50XG4gICAgICAgIH0gPSByZWY7XG4gICAgICAgIHZhciBwb2ludFJlZnMgPSBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcik7XG4gICAgICAgIHBvaW50UmVmcy5kZWxldGUocmVmKTtcbiAgICAgICAgcmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICByZXR1cm4gY3VycmVudDtcbiAgICAgIH1cblxuICAgIH07XG4gICAgdmFyIHJlZnMgPSBFZGl0b3IucG9pbnRSZWZzKGVkaXRvcik7XG4gICAgcmVmcy5hZGQocmVmKTtcbiAgICByZXR1cm4gcmVmO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc2V0IG9mIGN1cnJlbnRseSB0cmFja2VkIHBvaW50IHJlZnMgb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgcG9pbnRSZWZzKGVkaXRvcikge1xuICAgIHZhciByZWZzID0gUE9JTlRfUkVGUy5nZXQoZWRpdG9yKTtcblxuICAgIGlmICghcmVmcykge1xuICAgICAgcmVmcyA9IG5ldyBTZXQoKTtcbiAgICAgIFBPSU5UX1JFRlMuc2V0KGVkaXRvciwgcmVmcyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlZnM7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGFsbCB0aGUgcG9zaXRpb25zIGluIGBhdGAgcmFuZ2Ugd2hlcmUgYSBgUG9pbnRgIGNhbiBiZSBwbGFjZWQuXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0LCBtb3ZlcyBmb3J3YXJkIGJ5IGluZGl2aWR1YWwgb2Zmc2V0cyBhdCBhIHRpbWUsIGJ1dFxyXG4gICAqIHRoZSBgdW5pdGAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIHRvIG1vdmUgYnkgY2hhcmFjdGVyLCB3b3JkLCBsaW5lLCBvciBibG9jay5cclxuICAgKlxyXG4gICAqIFRoZSBgcmV2ZXJzZWAgb3B0aW9uIGNhbiBiZSB1c2VkIHRvIGNoYW5nZSBpdGVyYXRpb24gZGlyZWN0aW9uLlxyXG4gICAqXHJcbiAgICogTm90ZTogQnkgZGVmYXVsdCB2b2lkIG5vZGVzIGFyZSB0cmVhdGVkIGFzIGEgc2luZ2xlIHBvaW50IGFuZCBpdGVyYXRpb25cclxuICAgKiB3aWxsIG5vdCBoYXBwZW4gaW5zaWRlIHRoZWlyIGNvbnRlbnQgdW5sZXNzIHlvdSBwYXNzIGluIHRydWUgZm9yIHRoZVxyXG4gICAqIGB2b2lkc2Agb3B0aW9uLCB0aGVuIGl0ZXJhdGlvbiB3aWxsIG9jY3VyLlxyXG4gICAqL1xuICAqcG9zaXRpb25zKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgdW5pdCA9ICdvZmZzZXQnLFxuICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgdm9pZHMgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFhdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICAvKipcclxuICAgICAqIEFsZ29yaXRobSBub3RlczpcclxuICAgICAqXHJcbiAgICAgKiBFYWNoIHN0ZXAgYGRpc3RhbmNlYCBpcyBkeW5hbWljIGRlcGVuZGluZyBvbiB0aGUgdW5kZXJseWluZyB0ZXh0XHJcbiAgICAgKiBhbmQgdGhlIGB1bml0YCBzcGVjaWZpZWQuICBFYWNoIHN0ZXAsIGUuZy4sIGEgbGluZSBvciB3b3JkLCBtYXlcclxuICAgICAqIHNwYW4gbXVsdGlwbGUgdGV4dCBub2Rlcywgc28gd2UgaXRlcmF0ZSB0aHJvdWdoIHRoZSB0ZXh0IGJvdGggb25cclxuICAgICAqIHR3byBsZXZlbHMgaW4gc3RlcC1zeW5jOlxyXG4gICAgICpcclxuICAgICAqIGBsZWFmVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgdGV4dCBsZWFmIGxldmVsLCBhbmQgaXMgYWR2YW5jZWRcclxuICAgICAqIHRocm91Z2ggdXNpbmcgdGhlIGNvdW50ZXJzIGBsZWFmVGV4dE9mZnNldGAgYW5kIGBsZWFmVGV4dFJlbWFpbmluZ2AuXHJcbiAgICAgKlxyXG4gICAgICogYGJsb2NrVGV4dGAgc3RvcmVzIHRoZSB0ZXh0IG9uIGEgYmxvY2sgbGV2ZWwsIGFuZCBpcyBzaG9ydGVuZWRcclxuICAgICAqIGJ5IGBkaXN0YW5jZWAgZXZlcnkgdGltZSBpdCBpcyBhZHZhbmNlZC5cclxuICAgICAqXHJcbiAgICAgKiBXZSBvbmx5IG1haW50YWluIGEgd2luZG93IG9mIG9uZSBibG9ja1RleHQgYW5kIG9uZSBsZWFmVGV4dCBiZWNhdXNlXHJcbiAgICAgKiBhIGJsb2NrIG5vZGUgYWx3YXlzIGFwcGVhcnMgYmVmb3JlIGFsbCBvZiBpdHMgbGVhZiBub2Rlcy5cclxuICAgICAqL1xuXG5cbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgZmlyc3QgPSByZXZlcnNlID8gZW5kIDogc3RhcnQ7XG4gICAgdmFyIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICB2YXIgYmxvY2tUZXh0ID0gJyc7XG4gICAgdmFyIGRpc3RhbmNlID0gMDsgLy8gRGlzdGFuY2UgZm9yIGxlYWZUZXh0IHRvIGNhdGNoIHVwIHRvIGJsb2NrVGV4dC5cblxuICAgIHZhciBsZWFmVGV4dFJlbWFpbmluZyA9IDA7XG4gICAgdmFyIGxlYWZUZXh0T2Zmc2V0ID0gMDsgLy8gSXRlcmF0ZSB0aHJvdWdoIGFsbCBub2RlcyBpbiByYW5nZSwgZ3JhYmJpbmcgZW50aXJlIHRleHR1YWwgY29udGVudFxuICAgIC8vIG9mIGJsb2NrIG5vZGVzIGluIGJsb2NrVGV4dCwgYW5kIHRleHQgbm9kZXMgaW4gbGVhZlRleHQuXG4gICAgLy8gRXhwbG9pdHMgdGhlIGZhY3QgdGhhdCBub2RlcyBhcmUgc2VxdWVuY2VkIGluIHN1Y2ggYSB3YXkgdGhhdCB3ZSBmaXJzdFxuICAgIC8vIGVuY291bnRlciB0aGUgYmxvY2sgbm9kZSwgdGhlbiBhbGwgb2YgaXRzIHRleHQgbm9kZXMsIHNvIHdoZW4gaXRlcmF0aW5nXG4gICAgLy8gdGhyb3VnaCB0aGUgYmxvY2tUZXh0IGFuZCBsZWFmVGV4dCB3ZSBqdXN0IG5lZWQgdG8gcmVtZW1iZXIgYSB3aW5kb3cgb2ZcbiAgICAvLyBvbmUgYmxvY2sgbm9kZSBhbmQgbGVhZiBub2RlLCByZXNwZWN0aXZlbHkuXG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgYXQsXG4gICAgICByZXZlcnNlLFxuICAgICAgdm9pZHNcbiAgICB9KSkge1xuICAgICAgLypcclxuICAgICAgICogRUxFTUVOVCBOT0RFIC0gWWllbGQgcG9zaXRpb24ocykgZm9yIHZvaWRzLCBjb2xsZWN0IGJsb2NrVGV4dCBmb3IgYmxvY2tzXHJcbiAgICAgICAqL1xuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIC8vIFZvaWQgbm9kZXMgYXJlIGEgc3BlY2lhbCBjYXNlLCBzbyBieSBkZWZhdWx0IHdlIHdpbGwgYWx3YXlzXG4gICAgICAgIC8vIHlpZWxkIHRoZWlyIGZpcnN0IHBvaW50LiBJZiB0aGUgYHZvaWRzYCBvcHRpb24gaXMgc2V0IHRvIHRydWUsXG4gICAgICAgIC8vIHRoZW4gd2Ugd2lsbCBpdGVyYXRlIG92ZXIgdGhlaXIgY29udGVudC5cbiAgICAgICAgaWYgKCF2b2lkcyAmJiBlZGl0b3IuaXNWb2lkKG5vZGUpKSB7XG4gICAgICAgICAgeWllbGQgRWRpdG9yLnN0YXJ0KGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH0gLy8gSW5saW5lIGVsZW1lbnQgbm9kZXMgYXJlIGlnbm9yZWQgYXMgdGhleSBkb24ndCB0aGVtc2VsdmVzXG4gICAgICAgIC8vIGNvbnRyaWJ1dGUgdG8gYGJsb2NrVGV4dGAgb3IgYGxlYWZUZXh0YCAtIHRoZWlyIHBhcmVudCBhbmRcbiAgICAgICAgLy8gY2hpbGRyZW4gZG8uXG5cblxuICAgICAgICBpZiAoZWRpdG9yLmlzSW5saW5lKG5vZGUpKSBjb250aW51ZTsgLy8gQmxvY2sgZWxlbWVudCBub2RlIC0gc2V0IGBibG9ja1RleHRgIHRvIGl0cyB0ZXh0IGNvbnRlbnQuXG5cbiAgICAgICAgaWYgKEVkaXRvci5oYXNJbmxpbmVzKGVkaXRvciwgbm9kZSkpIHtcbiAgICAgICAgICAvLyBXZSBhbHdheXMgZXhoYXVzdCBibG9jayBub2RlcyBiZWZvcmUgZW5jb3VudGVyaW5nIGEgbmV3IG9uZTpcbiAgICAgICAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGJsb2NrVGV4dCA9PT0gJycsXG4gICAgICAgICAgLy8gICAgIGBibG9ja1RleHQ9JyR7YmxvY2tUZXh0fScgLSBgK1xuICAgICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGJsb2NrIG5vZGVgLCBwYXRoKVxuICAgICAgICAgIC8vIEVuc3VyZSByYW5nZSBjb25zaWRlcmVkIGlzIGNhcHBlZCB0byBgcmFuZ2VgLCBpbiB0aGVcbiAgICAgICAgICAvLyBzdGFydC9lbmQgZWRnZSBjYXNlcyB3aGVyZSBibG9jayBleHRlbmRzIGJleW9uZCByYW5nZS5cbiAgICAgICAgICAvLyBFcXVpdmFsZW50IHRvIHRoaXMsIGJ1dCBwcmVzdW1hYmx5IG1vcmUgcGVyZm9ybWFudDpcbiAgICAgICAgICAvLyAgIGJsb2NrUmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCAuLi5FZGl0b3IuZWRnZXMoZWRpdG9yLCBwYXRoKSlcbiAgICAgICAgICAvLyAgIGJsb2NrUmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2UsIGJsb2NrUmFuZ2UpIC8vIGludGVyc2VjdFxuICAgICAgICAgIC8vICAgYmxvY2tUZXh0ID0gRWRpdG9yLnN0cmluZyhlZGl0b3IsIGJsb2NrUmFuZ2UsIHsgdm9pZHMgfSlcbiAgICAgICAgICB2YXIgZSA9IFBhdGguaXNBbmNlc3RvcihwYXRoLCBlbmQucGF0aCkgPyBlbmQgOiBFZGl0b3IuZW5kKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgdmFyIHMgPSBQYXRoLmlzQW5jZXN0b3IocGF0aCwgc3RhcnQucGF0aCkgPyBzdGFydCA6IEVkaXRvci5zdGFydChlZGl0b3IsIHBhdGgpO1xuICAgICAgICAgIGJsb2NrVGV4dCA9IEVkaXRvci5zdHJpbmcoZWRpdG9yLCB7XG4gICAgICAgICAgICBhbmNob3I6IHMsXG4gICAgICAgICAgICBmb2N1czogZVxuICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgaXNOZXdCbG9jayA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8qXHJcbiAgICAgICAqIFRFWFQgTEVBRiBOT0RFIC0gSXRlcmF0ZSB0aHJvdWdoIHRleHQgY29udGVudCwgeWllbGRpbmdcclxuICAgICAgICogcG9zaXRpb25zIGV2ZXJ5IGBkaXN0YW5jZWAgb2Zmc2V0IGFjY29yZGluZyB0byBgdW5pdGAuXHJcbiAgICAgICAqL1xuXG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgICB2YXIgaXNGaXJzdCA9IFBhdGguZXF1YWxzKHBhdGgsIGZpcnN0LnBhdGgpOyAvLyBQcm9vZiB0aGF0IHdlIGFsd2F5cyBleGhhdXN0IHRleHQgbm9kZXMgYmVmb3JlIGVuY291bnRlcmluZyBhIG5ldyBvbmU6XG4gICAgICAgIC8vICAgY29uc29sZS5hc3NlcnQobGVhZlRleHRSZW1haW5pbmcgPD0gMCxcbiAgICAgICAgLy8gICAgIGBsZWFmVGV4dFJlbWFpbmluZz0ke2xlYWZUZXh0UmVtYWluaW5nfSAtIGArXG4gICAgICAgIC8vICAgICBgbm90IGV4aGF1c3RlZCBiZWZvcmUgbmV3IGxlYWYgdGV4dCBub2RlYCwgcGF0aClcbiAgICAgICAgLy8gUmVzZXQgYGxlYWZUZXh0YCBjb3VudGVycyBmb3IgbmV3IHRleHQgbm9kZS5cblxuICAgICAgICBpZiAoaXNGaXJzdCkge1xuICAgICAgICAgIGxlYWZUZXh0UmVtYWluaW5nID0gcmV2ZXJzZSA/IGZpcnN0Lm9mZnNldCA6IG5vZGUudGV4dC5sZW5ndGggLSBmaXJzdC5vZmZzZXQ7XG4gICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSBmaXJzdC5vZmZzZXQ7IC8vIFdvcmtzIGZvciByZXZlcnNlIHRvby5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsZWFmVGV4dFJlbWFpbmluZyA9IG5vZGUudGV4dC5sZW5ndGg7XG4gICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSByZXZlcnNlID8gbGVhZlRleHRSZW1haW5pbmcgOiAwO1xuICAgICAgICB9IC8vIFlpZWxkIHBvc2l0aW9uIGF0IHRoZSBzdGFydCBvZiBub2RlIChwb3RlbnRpYWxseSkuXG5cblxuICAgICAgICBpZiAoaXNGaXJzdCB8fCBpc05ld0Jsb2NrIHx8IHVuaXQgPT09ICdvZmZzZXQnKSB7XG4gICAgICAgICAgeWllbGQge1xuICAgICAgICAgICAgcGF0aCxcbiAgICAgICAgICAgIG9mZnNldDogbGVhZlRleHRPZmZzZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGlzTmV3QmxvY2sgPSBmYWxzZTtcbiAgICAgICAgfSAvLyBZaWVsZCBwb3NpdGlvbnMgZXZlcnkgKGR5bmFtaWNhbGx5IGNhbGN1bGF0ZWQpIGBkaXN0YW5jZWAgb2Zmc2V0LlxuXG5cbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAvLyBJZiBgbGVhZlRleHRgIGhhcyBjYXVnaHQgdXAgd2l0aCBgYmxvY2tUZXh0YCAoZGlzdGFuY2U9MCksXG4gICAgICAgICAgLy8gYW5kIGlmIGJsb2NrVGV4dCBpcyBleGhhdXN0ZWQsIGJyZWFrIHRvIGdldCBhbm90aGVyIGJsb2NrIG5vZGUsXG4gICAgICAgICAgLy8gb3RoZXJ3aXNlIGFkdmFuY2UgYmxvY2tUZXh0IGZvcndhcmQgYnkgdGhlIG5ldyBgZGlzdGFuY2VgLlxuICAgICAgICAgIGlmIChkaXN0YW5jZSA9PT0gMCkge1xuICAgICAgICAgICAgaWYgKGJsb2NrVGV4dCA9PT0gJycpIGJyZWFrO1xuICAgICAgICAgICAgZGlzdGFuY2UgPSBjYWxjRGlzdGFuY2UoYmxvY2tUZXh0LCB1bml0LCByZXZlcnNlKTsgLy8gU3BsaXQgdGhlIHN0cmluZyBhdCB0aGUgcHJldmlvdXNseSBmb3VuZCBkaXN0YW5jZSBhbmQgdXNlIHRoZVxuICAgICAgICAgICAgLy8gcmVtYWluaW5nIHN0cmluZyBmb3IgdGhlIG5leHQgaXRlcmF0aW9uLlxuXG4gICAgICAgICAgICBibG9ja1RleHQgPSBzcGxpdEJ5Q2hhcmFjdGVyRGlzdGFuY2UoYmxvY2tUZXh0LCBkaXN0YW5jZSwgcmV2ZXJzZSlbMV07XG4gICAgICAgICAgfSAvLyBBZHZhbmNlIGBsZWFmVGV4dGAgYnkgdGhlIGN1cnJlbnQgYGRpc3RhbmNlYC5cblxuXG4gICAgICAgICAgbGVhZlRleHRPZmZzZXQgPSByZXZlcnNlID8gbGVhZlRleHRPZmZzZXQgLSBkaXN0YW5jZSA6IGxlYWZUZXh0T2Zmc2V0ICsgZGlzdGFuY2U7XG4gICAgICAgICAgbGVhZlRleHRSZW1haW5pbmcgPSBsZWFmVGV4dFJlbWFpbmluZyAtIGRpc3RhbmNlOyAvLyBJZiBgbGVhZlRleHRgIGlzIGV4aGF1c3RlZCwgYnJlYWsgdG8gZ2V0IGEgbmV3IGxlYWYgbm9kZVxuICAgICAgICAgIC8vIGFuZCBzZXQgZGlzdGFuY2UgdG8gdGhlIG92ZXJmbG93IGFtb3VudCwgc28gd2UnbGwgKG1heWJlKVxuICAgICAgICAgIC8vIGNhdGNoIHVwIHRvIGJsb2NrVGV4dCBpbiB0aGUgbmV4dCBsZWFmIHRleHQgbm9kZS5cblxuICAgICAgICAgIGlmIChsZWFmVGV4dFJlbWFpbmluZyA8IDApIHtcbiAgICAgICAgICAgIGRpc3RhbmNlID0gLWxlYWZUZXh0UmVtYWluaW5nO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfSAvLyBTdWNjZXNzZnVsbHkgd2Fsa2VkIGBkaXN0YW5jZWAgb2Zmc2V0cyB0aHJvdWdoIGBsZWFmVGV4dGBcbiAgICAgICAgICAvLyB0byBjYXRjaCB1cCB3aXRoIGBibG9ja1RleHRgLCBzbyB3ZSBjYW4gcmVzZXQgYGRpc3RhbmNlYFxuICAgICAgICAgIC8vIGFuZCB5aWVsZCB0aGlzIHBvc2l0aW9uIGluIHRoaXMgbm9kZS5cblxuXG4gICAgICAgICAgZGlzdGFuY2UgPSAwO1xuICAgICAgICAgIHlpZWxkIHtcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBvZmZzZXQ6IGxlYWZUZXh0T2Zmc2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gLy8gUHJvb2YgdGhhdCB1cG9uIGNvbXBsZXRpb24sIHdlJ3ZlIGV4YWh1c3RlZCBib3RoIGxlYWYgYW5kIGJsb2NrIHRleHQ6XG4gICAgLy8gICBjb25zb2xlLmFzc2VydChsZWFmVGV4dFJlbWFpbmluZyA8PSAwLCBcImxlYWZUZXh0IHdhc24ndCBleGhhdXN0ZWRcIilcbiAgICAvLyAgIGNvbnNvbGUuYXNzZXJ0KGJsb2NrVGV4dCA9PT0gJycsIFwiYmxvY2tUZXh0IHdhc24ndCBleGhhdXN0ZWRcIilcbiAgICAvLyBIZWxwZXI6XG4gICAgLy8gUmV0dXJuIHRoZSBkaXN0YW5jZSBpbiBvZmZzZXRzIGZvciBhIHN0ZXAgb2Ygc2l6ZSBgdW5pdGAgb24gZ2l2ZW4gc3RyaW5nLlxuXG5cbiAgICBmdW5jdGlvbiBjYWxjRGlzdGFuY2UodGV4dCwgdW5pdCwgcmV2ZXJzZSkge1xuICAgICAgaWYgKHVuaXQgPT09ICdjaGFyYWN0ZXInKSB7XG4gICAgICAgIHJldHVybiBnZXRDaGFyYWN0ZXJEaXN0YW5jZSh0ZXh0LCByZXZlcnNlKTtcbiAgICAgIH0gZWxzZSBpZiAodW5pdCA9PT0gJ3dvcmQnKSB7XG4gICAgICAgIHJldHVybiBnZXRXb3JkRGlzdGFuY2UodGV4dCwgcmV2ZXJzZSk7XG4gICAgICB9IGVsc2UgaWYgKHVuaXQgPT09ICdsaW5lJyB8fCB1bml0ID09PSAnYmxvY2snKSB7XG4gICAgICAgIHJldHVybiB0ZXh0Lmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbWF0Y2hpbmcgbm9kZSBpbiB0aGUgYnJhbmNoIG9mIHRoZSBkb2N1bWVudCBiZWZvcmUgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgcHJldmlvdXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIG1hdGNoLFxuICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBpZiAoIWF0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBvaW50QmVmb3JlTG9jYXRpb24gPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIHtcbiAgICAgIHZvaWRzXG4gICAgfSk7XG5cbiAgICBpZiAoIXBvaW50QmVmb3JlTG9jYXRpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgWywgdG9dID0gRWRpdG9yLmZpcnN0KGVkaXRvciwgW10pOyAvLyBUaGUgc2VhcmNoIGxvY2F0aW9uIGlzIGZyb20gdGhlIHN0YXJ0IG9mIHRoZSBkb2N1bWVudCB0byB0aGUgcGF0aCBvZlxuICAgIC8vIHRoZSBwb2ludCBiZWZvcmUgdGhlIGxvY2F0aW9uIHBhc3NlZCBpblxuXG4gICAgdmFyIHNwYW4gPSBbcG9pbnRCZWZvcmVMb2NhdGlvbi5wYXRoLCB0b107XG5cbiAgICBpZiAoUGF0aC5pc1BhdGgoYXQpICYmIGF0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgbm9kZSBmcm9tIHRoZSByb290IG5vZGUhXCIpO1xuICAgIH1cblxuICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgbWF0Y2ggPSBuID0+IHBhcmVudC5jaGlsZHJlbi5pbmNsdWRlcyhuKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG1hdGNoID0gKCkgPT4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgW3ByZXZpb3VzXSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICBhdDogc3BhbixcbiAgICAgIG1hdGNoLFxuICAgICAgbW9kZSxcbiAgICAgIHZvaWRzXG4gICAgfSk7XG4gICAgcmV0dXJuIHByZXZpb3VzO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHJhbmdlIG9mIGEgbG9jYXRpb24uXHJcbiAgICovXG4gIHJhbmdlKGVkaXRvciwgYXQsIHRvKSB7XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmICF0bykge1xuICAgICAgcmV0dXJuIGF0O1xuICAgIH1cblxuICAgIHZhciBzdGFydCA9IEVkaXRvci5zdGFydChlZGl0b3IsIGF0KTtcbiAgICB2YXIgZW5kID0gRWRpdG9yLmVuZChlZGl0b3IsIHRvIHx8IGF0KTtcbiAgICByZXR1cm4ge1xuICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG11dGFibGUgcmVmIGZvciBhIGBSYW5nZWAgb2JqZWN0LCB3aGljaCB3aWxsIHN0YXkgaW4gc3luYyBhcyBuZXdcclxuICAgKiBvcGVyYXRpb25zIGFyZSBhcHBsaWVkIHRvIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIHJhbmdlUmVmKGVkaXRvciwgcmFuZ2UpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHJlZiA9IHtcbiAgICAgIGN1cnJlbnQ6IHJhbmdlLFxuICAgICAgYWZmaW5pdHksXG5cbiAgICAgIHVucmVmKCkge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIGN1cnJlbnRcbiAgICAgICAgfSA9IHJlZjtcbiAgICAgICAgdmFyIHJhbmdlUmVmcyA9IEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKTtcbiAgICAgICAgcmFuZ2VSZWZzLmRlbGV0ZShyZWYpO1xuICAgICAgICByZWYuY3VycmVudCA9IG51bGw7XG4gICAgICAgIHJldHVybiBjdXJyZW50O1xuICAgICAgfVxuXG4gICAgfTtcbiAgICB2YXIgcmVmcyA9IEVkaXRvci5yYW5nZVJlZnMoZWRpdG9yKTtcbiAgICByZWZzLmFkZChyZWYpO1xuICAgIHJldHVybiByZWY7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzZXQgb2YgY3VycmVudGx5IHRyYWNrZWQgcmFuZ2UgcmVmcyBvZiB0aGUgZWRpdG9yLlxyXG4gICAqL1xuICByYW5nZVJlZnMoZWRpdG9yKSB7XG4gICAgdmFyIHJlZnMgPSBSQU5HRV9SRUZTLmdldChlZGl0b3IpO1xuXG4gICAgaWYgKCFyZWZzKSB7XG4gICAgICByZWZzID0gbmV3IFNldCgpO1xuICAgICAgUkFOR0VfUkVGUy5zZXQoZWRpdG9yLCByZWZzKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVmcztcbiAgfSxcblxuICAvKipcclxuICAgKiBSZW1vdmUgYSBjdXN0b20gcHJvcGVydHkgZnJvbSBhbGwgb2YgdGhlIGxlYWYgdGV4dCBub2RlcyBpbiB0aGUgY3VycmVudFxyXG4gICAqIHNlbGVjdGlvbi5cclxuICAgKlxyXG4gICAqIElmIHRoZSBzZWxlY3Rpb24gaXMgY3VycmVudGx5IGNvbGxhcHNlZCwgdGhlIHJlbW92YWwgd2lsbCBiZSBzdG9yZWQgb25cclxuICAgKiBgZWRpdG9yLm1hcmtzYCBhbmQgYXBwbGllZCB0byB0aGUgdGV4dCBpbnNlcnRlZCBuZXh0LlxyXG4gICAqL1xuICByZW1vdmVNYXJrKGVkaXRvciwga2V5KSB7XG4gICAgZWRpdG9yLnJlbW92ZU1hcmsoa2V5KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNYW51YWxseSBzZXQgaWYgdGhlIGVkaXRvciBzaG91bGQgY3VycmVudGx5IGJlIG5vcm1hbGl6aW5nLlxyXG4gICAqXHJcbiAgICogTm90ZTogVXNpbmcgdGhpcyBpbmNvcnJlY3RseSBjYW4gbGVhdmUgdGhlIGVkaXRvciBpbiBhbiBpbnZhbGlkIHN0YXRlLlxyXG4gICAqXHJcbiAgICovXG4gIHNldE5vcm1hbGl6aW5nKGVkaXRvciwgaXNOb3JtYWxpemluZykge1xuICAgIE5PUk1BTElaSU5HLnNldChlZGl0b3IsIGlzTm9ybWFsaXppbmcpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgcG9pbnQgb2YgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgc3RhcnQoZWRpdG9yLCBhdCkge1xuICAgIHJldHVybiBFZGl0b3IucG9pbnQoZWRpdG9yLCBhdCwge1xuICAgICAgZWRnZTogJ3N0YXJ0J1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgdGV4dCBzdHJpbmcgY29udGVudCBvZiBhIGxvY2F0aW9uLlxyXG4gICAqXHJcbiAgICogTm90ZTogYnkgZGVmYXVsdCB0aGUgdGV4dCBvZiB2b2lkIG5vZGVzIGlzIGNvbnNpZGVyZWQgdG8gYmUgYW4gZW1wdHlcclxuICAgKiBzdHJpbmcsIHJlZ2FyZGxlc3Mgb2YgY29udGVudCwgdW5sZXNzIHlvdSBwYXNzIGluIHRydWUgZm9yIHRoZSB2b2lkcyBvcHRpb25cclxuICAgKi9cbiAgc3RyaW5nKGVkaXRvciwgYXQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHZvaWRzID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgcmFuZ2UgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgdGV4dCA9ICcnO1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZSxcbiAgICAgIG1hdGNoOiBUZXh0LmlzVGV4dCxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIHZhciB0ID0gbm9kZS50ZXh0O1xuXG4gICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgIHQgPSB0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgc3RhcnQucGF0aCkpIHtcbiAgICAgICAgdCA9IHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgIH1cblxuICAgICAgdGV4dCArPSB0O1xuICAgIH1cblxuICAgIHJldHVybiB0ZXh0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENvbnZlcnQgYSByYW5nZSBpbnRvIGEgbm9uLWhhbmdpbmcgb25lLlxyXG4gICAqL1xuICB1bmhhbmdSYW5nZShlZGl0b3IsIHJhbmdlKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICB2b2lkcyA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTsgLy8gUEVSRjogZXhpdCBlYXJseSBpZiB3ZSBjYW4gZ3VhcmFudGVlIHRoYXQgdGhlIHJhbmdlIGlzbid0IGhhbmdpbmcuXG5cbiAgICBpZiAoc3RhcnQub2Zmc2V0ICE9PSAwIHx8IGVuZC5vZmZzZXQgIT09IDAgfHwgUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpKSB7XG4gICAgICByZXR1cm4gcmFuZ2U7XG4gICAgfVxuXG4gICAgdmFyIGVuZEJsb2NrID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgYXQ6IGVuZCxcbiAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbilcbiAgICB9KTtcbiAgICB2YXIgYmxvY2tQYXRoID0gZW5kQmxvY2sgPyBlbmRCbG9ja1sxXSA6IFtdO1xuICAgIHZhciBmaXJzdCA9IEVkaXRvci5zdGFydChlZGl0b3IsIHN0YXJ0KTtcbiAgICB2YXIgYmVmb3JlID0ge1xuICAgICAgYW5jaG9yOiBmaXJzdCxcbiAgICAgIGZvY3VzOiBlbmRcbiAgICB9O1xuICAgIHZhciBza2lwID0gdHJ1ZTtcblxuICAgIGZvciAodmFyIFtub2RlLCBwYXRoXSBvZiBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICBhdDogYmVmb3JlLFxuICAgICAgbWF0Y2g6IFRleHQuaXNUZXh0LFxuICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgIHZvaWRzXG4gICAgfSkpIHtcbiAgICAgIGlmIChza2lwKSB7XG4gICAgICAgIHNraXAgPSBmYWxzZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChub2RlLnRleHQgIT09ICcnIHx8IFBhdGguaXNCZWZvcmUocGF0aCwgYmxvY2tQYXRoKSkge1xuICAgICAgICBlbmQgPSB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBvZmZzZXQ6IG5vZGUudGV4dC5sZW5ndGhcbiAgICAgICAgfTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFuY2hvcjogc3RhcnQsXG4gICAgICBmb2N1czogZW5kXG4gICAgfTtcbiAgfSxcblxuICAvKipcclxuICAgKiBNYXRjaCBhIHZvaWQgbm9kZSBpbiB0aGUgY3VycmVudCBicmFuY2ggb2YgdGhlIGVkaXRvci5cclxuICAgKi9cbiAgdm9pZChlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgcmV0dXJuIEVkaXRvci5hYm92ZShlZGl0b3IsIF9vYmplY3RTcHJlYWQkOChfb2JqZWN0U3ByZWFkJDgoe30sIG9wdGlvbnMpLCB7fSwge1xuICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzVm9pZChlZGl0b3IsIG4pXG4gICAgfSkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENhbGwgYSBmdW5jdGlvbiwgZGVmZXJyaW5nIG5vcm1hbGl6YXRpb24gdW50aWwgYWZ0ZXIgaXQgY29tcGxldGVzLlxyXG4gICAqL1xuICB3aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCBmbikge1xuICAgIHZhciB2YWx1ZSA9IEVkaXRvci5pc05vcm1hbGl6aW5nKGVkaXRvcik7XG4gICAgRWRpdG9yLnNldE5vcm1hbGl6aW5nKGVkaXRvciwgZmFsc2UpO1xuXG4gICAgdHJ5IHtcbiAgICAgIGZuKCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIEVkaXRvci5zZXROb3JtYWxpemluZyhlZGl0b3IsIHZhbHVlKTtcbiAgICB9XG5cbiAgICBFZGl0b3Iubm9ybWFsaXplKGVkaXRvcik7XG4gIH1cblxufTtcblxudmFyIExvY2F0aW9uID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBMb2NhdGlvbmAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc0xvY2F0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlKSB8fCBQb2ludC5pc1BvaW50KHZhbHVlKSB8fCBSYW5nZS5pc1JhbmdlKHZhbHVlKTtcbiAgfVxuXG59OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbnZhciBTcGFuID0ge1xuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBTcGFuYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzU3Bhbih2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiB2YWx1ZS5sZW5ndGggPT09IDIgJiYgdmFsdWUuZXZlcnkoUGF0aC5pc1BhdGgpO1xuICB9XG5cbn07XG5cbnZhciBfZXhjbHVkZWQkMyA9IFtcImNoaWxkcmVuXCJdLFxuICAgIF9leGNsdWRlZDIkMiA9IFtcInRleHRcIl07XG52YXIgSVNfTk9ERV9MSVNUX0NBQ0hFID0gbmV3IFdlYWtNYXAoKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG52YXIgTm9kZSA9IHtcbiAgLyoqXHJcbiAgICogR2V0IHRoZSBub2RlIGF0IGEgc3BlY2lmaWMgcGF0aCwgYXNzZXJ0aW5nIHRoYXQgaXQncyBhbiBhbmNlc3RvciBub2RlLlxyXG4gICAqL1xuICBhbmNlc3Rvcihyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSBOb2RlLmdldChyb290LCBwYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgYW5jZXN0b3Igbm9kZSBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGJlY2F1c2UgaXQgcmVmZXJzIHRvIGEgdGV4dCBub2RlIGluc3RlYWQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgYW5jZXN0b3Igbm9kZXMgYWJvdmUgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqXHJcbiAgICogQnkgZGVmYXVsdCB0aGUgb3JkZXIgaXMgdG9wLWRvd24sIGZyb20gaGlnaGVzdCB0byBsb3dlc3QgYW5jZXN0b3IgaW5cclxuICAgKiB0aGUgdHJlZSwgYnV0IHlvdSBjYW4gcGFzcyB0aGUgYHJldmVyc2U6IHRydWVgIG9wdGlvbiB0byBnbyBib3R0b20tdXAuXHJcbiAgICovXG4gICphbmNlc3RvcnMocm9vdCwgcGF0aCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcblxuICAgIGZvciAodmFyIHAgb2YgUGF0aC5hbmNlc3RvcnMocGF0aCwgb3B0aW9ucykpIHtcbiAgICAgIHZhciBuID0gTm9kZS5hbmNlc3Rvcihyb290LCBwKTtcbiAgICAgIHZhciBlbnRyeSA9IFtuLCBwXTtcbiAgICAgIHlpZWxkIGVudHJ5O1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNoaWxkIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIGluZGV4LlxyXG4gICAqL1xuICBjaGlsZChyb290LCBpbmRleCkge1xuICAgIGlmIChUZXh0LmlzVGV4dChyb290KSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgY2hpbGQgb2YgYSB0ZXh0IG5vZGU6IFwiLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IHJvb3QuY2hpbGRyZW5baW5kZXhdO1xuXG4gICAgaWYgKGMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCBjaGlsZCBhdCBpbmRleCBgXCIuY29uY2F0KGluZGV4LCBcImAgaW4gbm9kZTogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkocm9vdCkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gYztcbiAgfSxcblxuICAvKipcclxuICAgKiBJdGVyYXRlIG92ZXIgdGhlIGNoaWxkcmVuIG9mIGEgbm9kZSBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gICpjaGlsZHJlbihyb290LCBwYXRoKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIgYW5jZXN0b3IgPSBOb2RlLmFuY2VzdG9yKHJvb3QsIHBhdGgpO1xuICAgIHZhciB7XG4gICAgICBjaGlsZHJlblxuICAgIH0gPSBhbmNlc3RvcjtcbiAgICB2YXIgaW5kZXggPSByZXZlcnNlID8gY2hpbGRyZW4ubGVuZ3RoIC0gMSA6IDA7XG5cbiAgICB3aGlsZSAocmV2ZXJzZSA/IGluZGV4ID49IDAgOiBpbmRleCA8IGNoaWxkcmVuLmxlbmd0aCkge1xuICAgICAgdmFyIGNoaWxkID0gTm9kZS5jaGlsZChhbmNlc3RvciwgaW5kZXgpO1xuICAgICAgdmFyIGNoaWxkUGF0aCA9IHBhdGguY29uY2F0KGluZGV4KTtcbiAgICAgIHlpZWxkIFtjaGlsZCwgY2hpbGRQYXRoXTtcbiAgICAgIGluZGV4ID0gcmV2ZXJzZSA/IGluZGV4IC0gMSA6IGluZGV4ICsgMTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGFuIGVudHJ5IGZvciB0aGUgY29tbW9uIGFuY2VzZXRvciBub2RlIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uKHJvb3QsIHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgcCA9IFBhdGguY29tbW9uKHBhdGgsIGFub3RoZXIpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBhc3NlcnRpbmcgdGhhdCBpdCdzIGEgZGVzY2VuZGFudCBub2RlLlxyXG4gICAqL1xuICBkZXNjZW5kYW50KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IE5vZGUuZ2V0KHJvb3QsIHBhdGgpO1xuXG4gICAgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgZGVzY2VuZGFudCBub2RlIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCByZWZlcnMgdG8gdGhlIHJvb3QgZWRpdG9yIG5vZGUgaW5zdGVhZDogXCIpLmNvbmNhdChTY3J1YmJlci5zdHJpbmdpZnkobm9kZSkpKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbm9kZTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBkZXNjZW5kYW50IG5vZGUgZW50cmllcyBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gICpkZXNjZW5kYW50cyhyb290KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuXG4gICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIE5vZGUubm9kZXMocm9vdCwgb3B0aW9ucykpIHtcbiAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAvLyBOT1RFOiB3ZSBoYXZlIHRvIGNvZXJjZSBoZXJlIGJlY2F1c2UgY2hlY2tpbmcgdGhlIHBhdGgncyBsZW5ndGggZG9lc1xuICAgICAgICAvLyBndWFyYW50ZWUgdGhhdCBgbm9kZWAgaXMgbm90IGEgYEVkaXRvcmAsIGJ1dCBUeXBlU2NyaXB0IGRvZXNuJ3Qga25vdy5cbiAgICAgICAgeWllbGQgW25vZGUsIHBhdGhdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIHRoZSBlbGVtZW50IG5vZGVzIGluc2lkZSBhIHJvb3Qgbm9kZS4gRWFjaCBpdGVyYXRpb25cclxuICAgKiB3aWxsIHJldHVybiBhbiBgRWxlbWVudEVudHJ5YCB0dXBsZSBjb25zaXN0aW5nIG9mIGBbRWxlbWVudCwgUGF0aF1gLiBJZiB0aGVcclxuICAgKiByb290IG5vZGUgaXMgYW4gZWxlbWVudCBpdCB3aWxsIGJlIGluY2x1ZGVkIGluIHRoZSBpdGVyYXRpb24gYXMgd2VsbC5cclxuICAgKi9cbiAgKmVsZW1lbnRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogRXh0cmFjdCBwcm9wcyBmcm9tIGEgTm9kZS5cclxuICAgKi9cbiAgZXh0cmFjdFByb3BzKG5vZGUpIHtcbiAgICBpZiAoRWxlbWVudC5pc0FuY2VzdG9yKG5vZGUpKSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQkMyk7XG5cbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJvcGVydGllcyA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyJDIpO1xuXG4gICAgICByZXR1cm4gcHJvcGVydGllcztcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBmaXJzdCBub2RlIGVudHJ5IGluIGEgcm9vdCBub2RlIGZyb20gYSBwYXRoLlxyXG4gICAqL1xuICBmaXJzdChyb290LCBwYXRoKSB7XG4gICAgdmFyIHAgPSBwYXRoLnNsaWNlKCk7XG4gICAgdmFyIG4gPSBOb2RlLmdldChyb290LCBwKTtcblxuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAoVGV4dC5pc1RleHQobikgfHwgbi5jaGlsZHJlbi5sZW5ndGggPT09IDApIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuID0gbi5jaGlsZHJlblswXTtcbiAgICAgICAgcC5wdXNoKDApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBbbiwgcF07XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBzbGljZWQgZnJhZ21lbnQgcmVwcmVzZW50ZWQgYnkgYSByYW5nZSBpbnNpZGUgYSByb290IG5vZGUuXHJcbiAgICovXG4gIGZyYWdtZW50KHJvb3QsIHJhbmdlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KHJvb3QpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IGEgZnJhZ21lbnQgc3RhcnRpbmcgZnJvbSBhIHJvb3QgdGV4dCBub2RlOiBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgfVxuXG4gICAgdmFyIG5ld1Jvb3QgPSBwcm9kdWNlKHtcbiAgICAgIGNoaWxkcmVuOiByb290LmNoaWxkcmVuXG4gICAgfSwgciA9PiB7XG4gICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgICAgdmFyIG5vZGVFbnRyaWVzID0gTm9kZS5ub2RlcyhyLCB7XG4gICAgICAgIHJldmVyc2U6IHRydWUsXG4gICAgICAgIHBhc3M6IF9yZWYgPT4ge1xuICAgICAgICAgIHZhciBbLCBwYXRoXSA9IF9yZWY7XG4gICAgICAgICAgcmV0dXJuICFSYW5nZS5pbmNsdWRlcyhyYW5nZSwgcGF0aCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBbLCBwYXRoXSBvZiBub2RlRW50cmllcykge1xuICAgICAgICBpZiAoIVJhbmdlLmluY2x1ZGVzKHJhbmdlLCBwYXRoKSkge1xuICAgICAgICAgIHZhciBwYXJlbnQgPSBOb2RlLnBhcmVudChyLCBwYXRoKTtcbiAgICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgcGFyZW50LmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoUGF0aC5lcXVhbHMocGF0aCwgZW5kLnBhdGgpKSB7XG4gICAgICAgICAgdmFyIGxlYWYgPSBOb2RlLmxlYWYociwgcGF0aCk7XG4gICAgICAgICAgbGVhZi50ZXh0ID0gbGVhZi50ZXh0LnNsaWNlKDAsIGVuZC5vZmZzZXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFBhdGguZXF1YWxzKHBhdGgsIHN0YXJ0LnBhdGgpKSB7XG4gICAgICAgICAgdmFyIF9sZWFmID0gTm9kZS5sZWFmKHIsIHBhdGgpO1xuXG4gICAgICAgICAgX2xlYWYudGV4dCA9IF9sZWFmLnRleHQuc2xpY2Uoc3RhcnQub2Zmc2V0KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoRWRpdG9yLmlzRWRpdG9yKHIpKSB7XG4gICAgICAgIHIuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV3Um9vdC5jaGlsZHJlbjtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGRlc2NlbmRhbnQgbm9kZSByZWZlcnJlZCB0byBieSBhIHNwZWNpZmljIHBhdGguIElmIHRoZSBwYXRoIGlzIGFuXHJcbiAgICogZW1wdHkgYXJyYXksIGl0IHJlZmVycyB0byB0aGUgcm9vdCBub2RlIGl0c2VsZi5cclxuICAgKi9cbiAgZ2V0KHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgbm9kZSA9IHJvb3Q7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBwID0gcGF0aFtpXTtcblxuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpIHx8ICFub2RlLmNoaWxkcmVuW3BdKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIGEgZGVzY2VuZGFudCBhdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdIGluIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHJvb3QpKSk7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiBub2RlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgZGVzY2VuZGFudCBub2RlIGV4aXN0cyBhdCBhIHNwZWNpZmljIHBhdGguXHJcbiAgICovXG4gIGhhcyhyb290LCBwYXRoKSB7XG4gICAgdmFyIG5vZGUgPSByb290O1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcCA9IHBhdGhbaV07XG5cbiAgICAgIGlmIChUZXh0LmlzVGV4dChub2RlKSB8fCAhbm9kZS5jaGlsZHJlbltwXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuW3BdO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgdmFsdWUgaW1wbGVtZW50cyB0aGUgYE5vZGVgIGludGVyZmFjZS5cclxuICAgKi9cbiAgaXNOb2RlKHZhbHVlKSB7XG4gICAgcmV0dXJuIFRleHQuaXNUZXh0KHZhbHVlKSB8fCBFbGVtZW50LmlzRWxlbWVudCh2YWx1ZSkgfHwgRWRpdG9yLmlzRWRpdG9yKHZhbHVlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGlzIGEgbGlzdCBvZiBgTm9kZWAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNOb2RlTGlzdCh2YWx1ZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICB2YXIgY2FjaGVkUmVzdWx0ID0gSVNfTk9ERV9MSVNUX0NBQ0hFLmdldCh2YWx1ZSk7XG5cbiAgICBpZiAoY2FjaGVkUmVzdWx0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBjYWNoZWRSZXN1bHQ7XG4gICAgfVxuXG4gICAgdmFyIGlzTm9kZUxpc3QgPSB2YWx1ZS5ldmVyeSh2YWwgPT4gTm9kZS5pc05vZGUodmFsKSk7XG4gICAgSVNfTk9ERV9MSVNUX0NBQ0hFLnNldCh2YWx1ZSwgaXNOb2RlTGlzdCk7XG4gICAgcmV0dXJuIGlzTm9kZUxpc3Q7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IHRoZSBsYXN0IG5vZGUgZW50cnkgaW4gYSByb290IG5vZGUgZnJvbSBhIHBhdGguXHJcbiAgICovXG4gIGxhc3Qocm9vdCwgcGF0aCkge1xuICAgIHZhciBwID0gcGF0aC5zbGljZSgpO1xuICAgIHZhciBuID0gTm9kZS5nZXQocm9vdCwgcCk7XG5cbiAgICB3aGlsZSAobikge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG4pIHx8IG4uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGkgPSBuLmNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgICAgIG4gPSBuLmNoaWxkcmVuW2ldO1xuICAgICAgICBwLnB1c2goaSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFtuLCBwXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLCBlbnN1cmluZyBpdCdzIGEgbGVhZiB0ZXh0IG5vZGUuXHJcbiAgICovXG4gIGxlYWYocm9vdCwgcGF0aCkge1xuICAgIHZhciBub2RlID0gTm9kZS5nZXQocm9vdCwgcGF0aCk7XG5cbiAgICBpZiAoIVRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBsZWFmIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IHJlZmVycyB0byBhIG5vbi1sZWFmIG5vZGU6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5vZGU7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIHRoZSBpbiBhIGJyYW5jaCBvZiB0aGUgdHJlZSwgZnJvbSBhIHNwZWNpZmljIHBhdGguXHJcbiAgICpcclxuICAgKiBCeSBkZWZhdWx0IHRoZSBvcmRlciBpcyB0b3AtZG93biwgZnJvbSBoaWdoZXN0IHRvIGxvd2VzdCBub2RlIGluIHRoZSB0cmVlLFxyXG4gICAqIGJ1dCB5b3UgY2FuIHBhc3MgdGhlIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gdG8gZ28gYm90dG9tLXVwLlxyXG4gICAqL1xuICAqbGV2ZWxzKHJvb3QsIHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG5cbiAgICBmb3IgKHZhciBwIG9mIFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpKSB7XG4gICAgICB2YXIgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgeWllbGQgW24sIHBdO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIG5vZGUgbWF0Y2hlcyBhIHNldCBvZiBwcm9wcy5cclxuICAgKi9cbiAgbWF0Y2hlcyhub2RlLCBwcm9wcykge1xuICAgIHJldHVybiBFbGVtZW50LmlzRWxlbWVudChub2RlKSAmJiBFbGVtZW50LmlzRWxlbWVudFByb3BzKHByb3BzKSAmJiBFbGVtZW50Lm1hdGNoZXMobm9kZSwgcHJvcHMpIHx8IFRleHQuaXNUZXh0KG5vZGUpICYmIFRleHQuaXNUZXh0UHJvcHMocHJvcHMpICYmIFRleHQubWF0Y2hlcyhub2RlLCBwcm9wcyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZ2VuZXJhdG9yIG9mIGFsbCB0aGUgbm9kZSBlbnRyaWVzIG9mIGEgcm9vdCBub2RlLiBFYWNoIGVudHJ5IGlzXHJcbiAgICogcmV0dXJuZWQgYXMgYSBgW05vZGUsIFBhdGhdYCB0dXBsZSwgd2l0aCB0aGUgcGF0aCByZWZlcnJpbmcgdG8gdGhlIG5vZGUnc1xyXG4gICAqIHBvc2l0aW9uIGluc2lkZSB0aGUgcm9vdCBub2RlLlxyXG4gICAqL1xuICAqbm9kZXMocm9vdCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcGFzcyxcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB7XG4gICAgICBmcm9tID0gW10sXG4gICAgICB0b1xuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciB2aXNpdGVkID0gbmV3IFNldCgpO1xuICAgIHZhciBwID0gW107XG4gICAgdmFyIG4gPSByb290O1xuXG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh0byAmJiAocmV2ZXJzZSA/IFBhdGguaXNCZWZvcmUocCwgdG8pIDogUGF0aC5pc0FmdGVyKHAsIHRvKSkpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikpIHtcbiAgICAgICAgeWllbGQgW24sIHBdO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBhbGxvd2VkIHRvIGdvIGRvd253YXJkIGFuZCB3ZSBoYXZlbid0IGRlc2NlbmRlZCB5ZXQsIGRvLlxuXG5cbiAgICAgIGlmICghdmlzaXRlZC5oYXMobikgJiYgIVRleHQuaXNUZXh0KG4pICYmIG4uY2hpbGRyZW4ubGVuZ3RoICE9PSAwICYmIChwYXNzID09IG51bGwgfHwgcGFzcyhbbiwgcF0pID09PSBmYWxzZSkpIHtcbiAgICAgICAgdmlzaXRlZC5hZGQobik7XG4gICAgICAgIHZhciBuZXh0SW5kZXggPSByZXZlcnNlID8gbi5jaGlsZHJlbi5sZW5ndGggLSAxIDogMDtcblxuICAgICAgICBpZiAoUGF0aC5pc0FuY2VzdG9yKHAsIGZyb20pKSB7XG4gICAgICAgICAgbmV4dEluZGV4ID0gZnJvbVtwLmxlbmd0aF07XG4gICAgICAgIH1cblxuICAgICAgICBwID0gcC5jb25jYXQobmV4dEluZGV4KTtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gSWYgd2UncmUgYXQgdGhlIHJvb3QgYW5kIHdlIGNhbid0IGdvIGRvd24sIHdlJ3JlIGRvbmUuXG5cblxuICAgICAgaWYgKHAubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBmb3J3YXJkLi4uXG5cblxuICAgICAgaWYgKCFyZXZlcnNlKSB7XG4gICAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHApO1xuXG4gICAgICAgIGlmIChOb2RlLmhhcyhyb290LCBuZXdQYXRoKSkge1xuICAgICAgICAgIHAgPSBuZXdQYXRoO1xuICAgICAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSAvLyBJZiB3ZSdyZSBnb2luZyBiYWNrd2FyZC4uLlxuXG5cbiAgICAgIGlmIChyZXZlcnNlICYmIHBbcC5sZW5ndGggLSAxXSAhPT0gMCkge1xuICAgICAgICB2YXIgX25ld1BhdGggPSBQYXRoLnByZXZpb3VzKHApO1xuXG4gICAgICAgIHAgPSBfbmV3UGF0aDtcbiAgICAgICAgbiA9IE5vZGUuZ2V0KHJvb3QsIHApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH0gLy8gT3RoZXJ3aXNlIHdlJ3JlIGdvaW5nIHVwd2FyZC4uLlxuXG5cbiAgICAgIHAgPSBQYXRoLnBhcmVudChwKTtcbiAgICAgIG4gPSBOb2RlLmdldChyb290LCBwKTtcbiAgICAgIHZpc2l0ZWQuYWRkKG4pO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIHBhcmVudCBvZiBhIG5vZGUgYXQgYSBzcGVjaWZpYyBwYXRoLlxyXG4gICAqL1xuICBwYXJlbnQocm9vdCwgcGF0aCkge1xuICAgIHZhciBwYXJlbnRQYXRoID0gUGF0aC5wYXJlbnQocGF0aCk7XG4gICAgdmFyIHAgPSBOb2RlLmdldChyb290LCBwYXJlbnRQYXRoKTtcblxuICAgIGlmIChUZXh0LmlzVGV4dChwKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IG9mIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgcm9vdC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgY29uY2F0ZW5hdGVkIHRleHQgc3RyaW5nIG9mIGEgbm9kZSdzIGNvbnRlbnQuXHJcbiAgICpcclxuICAgKiBOb3RlIHRoYXQgdGhpcyB3aWxsIG5vdCBpbmNsdWRlIHNwYWNlcyBvciBsaW5lIGJyZWFrcyBiZXR3ZWVuIGJsb2NrIG5vZGVzLlxyXG4gICAqIEl0IGlzIG5vdCBhIHVzZXItZmFjaW5nIHN0cmluZywgYnV0IGEgc3RyaW5nIGZvciBwZXJmb3JtaW5nIG9mZnNldC1yZWxhdGVkXHJcbiAgICogY29tcHV0YXRpb25zIGZvciBhIG5vZGUuXHJcbiAgICovXG4gIHN0cmluZyhub2RlKSB7XG4gICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICByZXR1cm4gbm9kZS50ZXh0O1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gbm9kZS5jaGlsZHJlbi5tYXAoTm9kZS5zdHJpbmcpLmpvaW4oJycpO1xuICAgIH1cbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm4gYSBnZW5lcmF0b3Igb2YgYWxsIGxlYWYgdGV4dCBub2RlcyBpbiBhIHJvb3Qgbm9kZS5cclxuICAgKi9cbiAgKnRleHRzKHJvb3QpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG5cbiAgICBmb3IgKHZhciBbbm9kZSwgcGF0aF0gb2YgTm9kZS5ub2Rlcyhyb290LCBvcHRpb25zKSkge1xuICAgICAgaWYgKFRleHQuaXNUZXh0KG5vZGUpKSB7XG4gICAgICAgIHlpZWxkIFtub2RlLCBwYXRoXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ3KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ3KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNyhPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDcoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBPcGVyYXRpb24gPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIG9mIGEgdmFsdWUgaXMgYSBgTm9kZU9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc05vZGVPcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfbm9kZScpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIG9mIGEgdmFsdWUgaXMgYW4gYE9wZXJhdGlvbmAgb2JqZWN0LlxyXG4gICAqL1xuICBpc09wZXJhdGlvbih2YWx1ZSkge1xuICAgIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICByZXR1cm4gdHlwZW9mIHZhbHVlLnBvc2l0aW9uID09PSAnbnVtYmVyJyAmJiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiBpc1BsYWluT2JqZWN0KHZhbHVlLnByb3BlcnRpZXMpO1xuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICByZXR1cm4gUGF0aC5pc1BhdGgodmFsdWUucGF0aCkgJiYgUGF0aC5pc1BhdGgodmFsdWUubmV3UGF0aCk7XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIE5vZGUuaXNOb2RlKHZhbHVlLm5vZGUpO1xuXG4gICAgICBjYXNlICdyZW1vdmVfdGV4dCc6XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUub2Zmc2V0ID09PSAnbnVtYmVyJyAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZycgJiYgUGF0aC5pc1BhdGgodmFsdWUucGF0aCk7XG5cbiAgICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgICAgcmV0dXJuIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICAgIHJldHVybiB2YWx1ZS5wcm9wZXJ0aWVzID09PSBudWxsICYmIFJhbmdlLmlzUmFuZ2UodmFsdWUubmV3UHJvcGVydGllcykgfHwgdmFsdWUubmV3UHJvcGVydGllcyA9PT0gbnVsbCAmJiBSYW5nZS5pc1JhbmdlKHZhbHVlLnByb3BlcnRpZXMpIHx8IGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcykgJiYgaXNQbGFpbk9iamVjdCh2YWx1ZS5uZXdQcm9wZXJ0aWVzKTtcblxuICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgIHJldHVybiBQYXRoLmlzUGF0aCh2YWx1ZS5wYXRoKSAmJiB0eXBlb2YgdmFsdWUucG9zaXRpb24gPT09ICdudW1iZXInICYmIGlzUGxhaW5PYmplY3QodmFsdWUucHJvcGVydGllcyk7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYE9wZXJhdGlvbmAgb2JqZWN0cy5cclxuICAgKi9cbiAgaXNPcGVyYXRpb25MaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodmFsdWUpICYmIHZhbHVlLmV2ZXJ5KHZhbCA9PiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsKSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgb2YgYSB2YWx1ZSBpcyBhIGBTZWxlY3Rpb25PcGVyYXRpb25gIG9iamVjdC5cclxuICAgKi9cbiAgaXNTZWxlY3Rpb25PcGVyYXRpb24odmFsdWUpIHtcbiAgICByZXR1cm4gT3BlcmF0aW9uLmlzT3BlcmF0aW9uKHZhbHVlKSAmJiB2YWx1ZS50eXBlLmVuZHNXaXRoKCdfc2VsZWN0aW9uJyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgb2YgYSB2YWx1ZSBpcyBhIGBUZXh0T3BlcmF0aW9uYCBvYmplY3QuXHJcbiAgICovXG4gIGlzVGV4dE9wZXJhdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBPcGVyYXRpb24uaXNPcGVyYXRpb24odmFsdWUpICYmIHZhbHVlLnR5cGUuZW5kc1dpdGgoJ190ZXh0Jyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW52ZXJ0IGFuIG9wZXJhdGlvbiwgcmV0dXJuaW5nIGEgbmV3IG9wZXJhdGlvbiB0aGF0IHdpbGwgZXhhY3RseSB1bmRvIHRoZVxyXG4gICAqIG9yaWdpbmFsIHdoZW4gYXBwbGllZC5cclxuICAgKi9cbiAgaW52ZXJzZShvcCkge1xuICAgIHN3aXRjaCAob3AudHlwZSkge1xuICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZSdcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdpbnNlcnRfdGV4dCc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0J1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHR5cGU6ICdzcGxpdF9ub2RlJyxcbiAgICAgICAgICAgIHBhdGg6IFBhdGgucHJldmlvdXMob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIG5ld1BhdGgsXG4gICAgICAgICAgICBwYXRoXG4gICAgICAgICAgfSA9IG9wOyAvLyBQRVJGOiBpbiB0aGlzIGNhc2UgdGhlIG1vdmUgb3BlcmF0aW9uIGlzIGEgbm8tb3AgYW55d2F5cy5cblxuICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhuZXdQYXRoLCBwYXRoKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9wO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgaGFwcGVucyBjb21wbGV0ZWx5IHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgdGhlIHBhdGggYW5kXG4gICAgICAgICAgLy8gbmV3UGF0aCBhcmUgc3RhYmxlIHdpdGggcmVzcGVjdCB0byBlYWNoIG90aGVyLlxuXG5cbiAgICAgICAgICBpZiAoUGF0aC5pc1NpYmxpbmcocGF0aCwgbmV3UGF0aCkpIHtcbiAgICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICAgIHBhdGg6IG5ld1BhdGgsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IHBhdGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gLy8gSWYgdGhlIG1vdmUgZG9lcyBub3QgaGFwcGVuIHdpdGhpbiBhIHNpbmdsZSBwYXJlbnQgaXQgaXMgcG9zc2libGVcbiAgICAgICAgICAvLyBmb3IgdGhlIG1vdmUgdG8gaW1wYWN0IHRoZSB0cnVlIHBhdGggdG8gdGhlIGxvY2F0aW9uIHdoZXJlIHRoZSBub2RlXG4gICAgICAgICAgLy8gd2FzIHJlbW92ZWQgZnJvbSBhbmQgd2hlcmUgaXQgd2FzIGluc2VydGVkLiBXZSBoYXZlIHRvIGFkanVzdCBmb3IgdGhpc1xuICAgICAgICAgIC8vIGFuZCBmaW5kIHRoZSBvcmlnaW5hbCBwYXRoLiBXZSBjYW4gYWNjb21wbGlzaCB0aGlzIChvbmx5IGluIG5vbi1zaWJsaW5nKVxuICAgICAgICAgIC8vIG1vdmVzIGJ5IGxvb2tpbmcgYXQgdGhlIGltcGFjdCBvZiB0aGUgbW92ZSBvcGVyYXRpb24gb24gdGhlIG5vZGVcbiAgICAgICAgICAvLyBhZnRlciB0aGUgb3JpZ2luYWwgbW92ZSBwYXRoLlxuXG5cbiAgICAgICAgICB2YXIgaW52ZXJzZVBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCk7XG4gICAgICAgICAgdmFyIGludmVyc2VOZXdQYXRoID0gUGF0aC50cmFuc2Zvcm0oUGF0aC5uZXh0KHBhdGgpLCBvcCk7XG4gICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgIHBhdGg6IGludmVyc2VQYXRoLFxuICAgICAgICAgICAgbmV3UGF0aDogaW52ZXJzZU5ld1BhdGhcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgIHtcbiAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJ1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnaW5zZXJ0X3RleHQnXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgY2FzZSAnc2V0X25vZGUnOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXMsXG4gICAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgICAgfSA9IG9wO1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiBuZXdQcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogcHJvcGVydGllc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgIGNhc2UgJ3NldF9zZWxlY3Rpb24nOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IF9wcm9wZXJ0aWVzLFxuICAgICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgICBpZiAoX3Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogX25ld1Byb3BlcnRpZXMsXG4gICAgICAgICAgICAgIG5ld1Byb3BlcnRpZXM6IG51bGxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSBpZiAoX25ld1Byb3BlcnRpZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYmplY3RTcHJlYWQkNyhfb2JqZWN0U3ByZWFkJDcoe30sIG9wKSwge30sIHtcbiAgICAgICAgICAgICAgcHJvcGVydGllczogbnVsbCxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ3KF9vYmplY3RTcHJlYWQkNyh7fSwgb3ApLCB7fSwge1xuICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiBfbmV3UHJvcGVydGllcyxcbiAgICAgICAgICAgICAgbmV3UHJvcGVydGllczogX3Byb3BlcnRpZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAge1xuICAgICAgICAgIHJldHVybiBfb2JqZWN0U3ByZWFkJDcoX29iamVjdFNwcmVhZCQ3KHt9LCBvcCksIHt9LCB7XG4gICAgICAgICAgICB0eXBlOiAnbWVyZ2Vfbm9kZScsXG4gICAgICAgICAgICBwYXRoOiBQYXRoLm5leHQob3AucGF0aClcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgfVxuXG59O1xuXG52YXIgUGF0aCA9IHtcbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBhbmNlc3RvciBwYXRocyBmb3IgYSBnaXZlbiBwYXRoLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QgYW5jZXN0b3IuIEhvd2V2ZXIsIGlmIHRoZVxyXG4gICAqIGByZXZlcnNlOiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgYW5jZXN0b3JzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBwYXRocyA9IFBhdGgubGV2ZWxzKHBhdGgsIG9wdGlvbnMpO1xuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBhdGhzID0gcGF0aHMuc2xpY2UoMCwgLTEpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRocztcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGNvbW1vbiBhbmNlc3RvciBwYXRoIG9mIHR3byBwYXRocy5cclxuICAgKi9cbiAgY29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgY29tbW9uID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhdGgubGVuZ3RoICYmIGkgPCBhbm90aGVyLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgICAgdmFyIGJ2ID0gYW5vdGhlcltpXTtcblxuICAgICAgaWYgKGF2ICE9PSBidikge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY29tbW9uLnB1c2goYXYpO1xuICAgIH1cblxuICAgIHJldHVybiBjb21tb247XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHBhdGggdG8gYW5vdGhlciwgcmV0dXJuaW5nIGFuIGludGVnZXIgaW5kaWNhdGluZyB3aGV0aGVyIHRoZSBwYXRoXHJcbiAgICogd2FzIGJlZm9yZSwgYXQsIG9yIGFmdGVyIHRoZSBvdGhlci5cclxuICAgKlxyXG4gICAqIE5vdGU6IFR3byBwYXRocyBvZiB1bmVxdWFsIGxlbmd0aCBjYW4gc3RpbGwgcmVjZWl2ZSBhIGAwYCByZXN1bHQgaWYgb25lIGlzXHJcbiAgICogZGlyZWN0bHkgYWJvdmUgb3IgYmVsb3cgdGhlIG90aGVyLiBJZiB5b3Ugd2FudCBleGFjdCBtYXRjaGluZywgdXNlXHJcbiAgICogW1tQYXRoLmVxdWFsc11dIGluc3RlYWQuXHJcbiAgICovXG4gIGNvbXBhcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBtaW4gPSBNYXRoLm1pbihwYXRoLmxlbmd0aCwgYW5vdGhlci5sZW5ndGgpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtaW47IGkrKykge1xuICAgICAgaWYgKHBhdGhbaV0gPCBhbm90aGVyW2ldKSByZXR1cm4gLTE7XG4gICAgICBpZiAocGF0aFtpXSA+IGFub3RoZXJbaV0pIHJldHVybiAxO1xuICAgIH1cblxuICAgIHJldHVybiAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBlbmRzIGFmdGVyIG9uZSBvZiB0aGUgaW5kZXhlcyBpbiBhbm90aGVyLlxyXG4gICAqL1xuICBlbmRzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPiBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBhdCBvbmUgb2YgdGhlIGluZGV4ZXMgaW4gYW5vdGhlci5cclxuICAgKi9cbiAgZW5kc0F0KHBhdGgsIGFub3RoZXIpIHtcbiAgICB2YXIgaSA9IHBhdGgubGVuZ3RoO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICByZXR1cm4gUGF0aC5lcXVhbHMoYXMsIGJzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggZW5kcyBiZWZvcmUgb25lIG9mIHRoZSBpbmRleGVzIGluIGFub3RoZXIuXHJcbiAgICovXG4gIGVuZHNCZWZvcmUocGF0aCwgYW5vdGhlcikge1xuICAgIHZhciBpID0gcGF0aC5sZW5ndGggLSAxO1xuICAgIHZhciBhcyA9IHBhdGguc2xpY2UoMCwgaSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCBpKTtcbiAgICB2YXIgYXYgPSBwYXRoW2ldO1xuICAgIHZhciBidiA9IGFub3RoZXJbaV07XG4gICAgcmV0dXJuIFBhdGguZXF1YWxzKGFzLCBicykgJiYgYXYgPCBidjtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHMocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA9PT0gYW5vdGhlci5sZW5ndGggJiYgcGF0aC5ldmVyeSgobiwgaSkgPT4gbiA9PT0gYW5vdGhlcltpXSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIHBhdGggb2YgcHJldmlvdXMgc2libGluZyBub2RlIGV4aXN0c1xyXG4gICAqL1xuICBoYXNQcmV2aW91cyhwYXRoKSB7XG4gICAgcmV0dXJuIHBhdGhbcGF0aC5sZW5ndGggLSAxXSA+IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFmdGVyIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQWZ0ZXIocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQW5jZXN0b3IocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCA8IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYmVmb3JlIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQmVmb3JlKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAtMTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBhdGggaXMgYSBjaGlsZCBvZiBhbm90aGVyLlxyXG4gICAqL1xuICBpc0NoaWxkKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPT09IGFub3RoZXIubGVuZ3RoICsgMSAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIGVxdWFsIHRvIG9yIGFuIGFuY2VzdG9yIG9mIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQ29tbW9uKHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPD0gYW5vdGhlci5sZW5ndGggJiYgUGF0aC5jb21wYXJlKHBhdGgsIGFub3RoZXIpID09PSAwO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIGRlc2NlbmRhbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNEZXNjZW5kYW50KHBhdGgsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gcGF0aC5sZW5ndGggPiBhbm90aGVyLmxlbmd0aCAmJiBQYXRoLmNvbXBhcmUocGF0aCwgYW5vdGhlcikgPT09IDA7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwYXRoIGlzIHRoZSBwYXJlbnQgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNQYXJlbnQocGF0aCwgYW5vdGhlcikge1xuICAgIHJldHVybiBwYXRoLmxlbmd0aCArIDEgPT09IGFub3RoZXIubGVuZ3RoICYmIFBhdGguY29tcGFyZShwYXRoLCBhbm90aGVyKSA9PT0gMDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpcyBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBQYXRoYCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUGF0aCh2YWx1ZSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHZhbHVlKSAmJiAodmFsdWUubGVuZ3RoID09PSAwIHx8IHR5cGVvZiB2YWx1ZVswXSA9PT0gJ251bWJlcicpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcGF0aCBpcyBhIHNpYmxpbmcgb2YgYW5vdGhlci5cclxuICAgKi9cbiAgaXNTaWJsaW5nKHBhdGgsIGFub3RoZXIpIHtcbiAgICBpZiAocGF0aC5sZW5ndGggIT09IGFub3RoZXIubGVuZ3RoKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgdmFyIGFzID0gcGF0aC5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGJzID0gYW5vdGhlci5zbGljZSgwLCAtMSk7XG4gICAgdmFyIGFsID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuICAgIHZhciBibCA9IGFub3RoZXJbYW5vdGhlci5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gYWwgIT09IGJsICYmIFBhdGguZXF1YWxzKGFzLCBicyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2V0IGEgbGlzdCBvZiBwYXRocyBhdCBldmVyeSBsZXZlbCBkb3duIHRvIGEgcGF0aC4gTm90ZTogdGhpcyBpcyB0aGUgc2FtZVxyXG4gICAqIGFzIGBQYXRoLmFuY2VzdG9yc2AsIGJ1dCBpbmNsdWRpbmcgdGhlIHBhdGggaXRzZWxmLlxyXG4gICAqXHJcbiAgICogVGhlIHBhdGhzIGFyZSBzb3J0ZWQgZnJvbSBzaGFsbG93ZXN0IHRvIGRlZXBlc3QuIEhvd2V2ZXIsIGlmIHRoZSBgcmV2ZXJzZTpcclxuICAgKiB0cnVlYCBvcHRpb24gaXMgcGFzc2VkLCB0aGV5IGFyZSByZXZlcnNlZC5cclxuICAgKi9cbiAgbGV2ZWxzKHBhdGgpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdmFyIHtcbiAgICAgIHJldmVyc2UgPSBmYWxzZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIHZhciBsaXN0ID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBwYXRoLmxlbmd0aDsgaSsrKSB7XG4gICAgICBsaXN0LnB1c2gocGF0aC5zbGljZSgwLCBpKSk7XG4gICAgfVxuXG4gICAgaWYgKHJldmVyc2UpIHtcbiAgICAgIGxpc3QucmV2ZXJzZSgpO1xuICAgIH1cblxuICAgIHJldHVybiBsaXN0O1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdpdmVuIGEgcGF0aCwgZ2V0IHRoZSBwYXRoIHRvIHRoZSBuZXh0IHNpYmxpbmcgbm9kZS5cclxuICAgKi9cbiAgbmV4dChwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBuZXh0IHBhdGggb2YgYSByb290IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0sIGJlY2F1c2UgaXQgaGFzIG5vIG5leHQgaW5kZXguXCIpKTtcbiAgICB9XG5cbiAgICB2YXIgbGFzdCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gcGF0aC5zbGljZSgwLCAtMSkuY29uY2F0KGxhc3QgKyAxKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBvcGVyYXRpb24gY2FuIGFmZmVjdCBwYXRocyBvciBub3QuIFVzZWQgYXMgYW5cclxuICAgKiBvcHRpbWl6YXRpb24gd2hlbiB1cGRhdGluZyBkaXJ0eSBwYXRocyBkdXJpbmcgbm9ybWFsaXphdGlvblxyXG4gICAqXHJcbiAgICogTk9URTogVGhpcyAqbXVzdCogYmUga2VwdCBpbiBzeW5jIHdpdGggdGhlIGltcGxlbWVudGF0aW9uIG9mICd0cmFuc2Zvcm0nXHJcbiAgICogYmVsb3dcclxuICAgKi9cbiAgb3BlcmF0aW9uQ2FuVHJhbnNmb3JtUGF0aChvcGVyYXRpb24pIHtcbiAgICBzd2l0Y2ggKG9wZXJhdGlvbi50eXBlKSB7XG4gICAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICBjYXNlICdtZXJnZV9ub2RlJzpcbiAgICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogR2l2ZW4gYSBwYXRoLCByZXR1cm4gYSBuZXcgcGF0aCByZWZlcnJpbmcgdG8gdGhlIHBhcmVudCBub2RlIGFib3ZlIGl0LlxyXG4gICAqL1xuICBwYXJlbnQocGF0aCkge1xuICAgIGlmIChwYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcGFyZW50IHBhdGggb2YgdGhlIHJvb3QgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXS5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHaXZlbiBhIHBhdGgsIGdldCB0aGUgcGF0aCB0byB0aGUgcHJldmlvdXMgc2libGluZyBub2RlLlxyXG4gICAqL1xuICBwcmV2aW91cyhwYXRoKSB7XG4gICAgaWYgKHBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgZ2V0IHRoZSBwcmV2aW91cyBwYXRoIG9mIGEgcm9vdCBwYXRoIFtcIi5jb25jYXQocGF0aCwgXCJdLCBiZWNhdXNlIGl0IGhhcyBubyBwcmV2aW91cyBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHZhciBsYXN0ID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuXG4gICAgaWYgKGxhc3QgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGdldCB0aGUgcHJldmlvdXMgcGF0aCBvZiBhIGZpcnN0IGNoaWxkIHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSBpdCB3b3VsZCByZXN1bHQgaW4gYSBuZWdhdGl2ZSBpbmRleC5cIikpO1xuICAgIH1cblxuICAgIHJldHVybiBwYXRoLnNsaWNlKDAsIC0xKS5jb25jYXQobGFzdCAtIDEpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCBhIHBhdGggcmVsYXRpdmUgdG8gYW4gYW5jZXN0b3IuXHJcbiAgICovXG4gIHJlbGF0aXZlKHBhdGgsIGFuY2VzdG9yKSB7XG4gICAgaWYgKCFQYXRoLmlzQW5jZXN0b3IoYW5jZXN0b3IsIHBhdGgpICYmICFQYXRoLmVxdWFscyhwYXRoLCBhbmNlc3RvcikpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBnZXQgdGhlIHJlbGF0aXZlIHBhdGggb2YgW1wiLmNvbmNhdChwYXRoLCBcIl0gaW5zaWRlIGFuY2VzdG9yIFtcIikuY29uY2F0KGFuY2VzdG9yLCBcIl0sIGJlY2F1c2UgaXQgaXMgbm90IGFib3ZlIG9yIGVxdWFsIHRvIHRoZSBwYXRoLlwiKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBhdGguc2xpY2UoYW5jZXN0b3IubGVuZ3RoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gYSBwYXRoIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHBhdGgsIG9wZXJhdGlvbikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gcHJvZHVjZShwYXRoLCBwID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGFmZmluaXR5ID0gJ2ZvcndhcmQnXG4gICAgICB9ID0gb3B0aW9uczsgLy8gUEVSRjogRXhpdCBlYXJseSBpZiB0aGUgb3BlcmF0aW9uIGlzIGd1YXJhbnRlZWQgbm90IHRvIGhhdmUgYW4gZWZmZWN0LlxuXG4gICAgICBpZiAoIXBhdGggfHwgKHBhdGggPT09IG51bGwgfHwgcGF0aCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcGF0aC5sZW5ndGgpID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKHAgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIHN3aXRjaCAob3BlcmF0aW9uLnR5cGUpIHtcbiAgICAgICAgY2FzZSAnaW5zZXJ0X25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IG9wXG4gICAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AsIHApIHx8IFBhdGguZW5kc0JlZm9yZShvcCwgcCkgfHwgUGF0aC5pc0FuY2VzdG9yKG9wLCBwKSkge1xuICAgICAgICAgICAgICBwW29wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdyZW1vdmVfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgcGF0aDogX29wXG4gICAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wLCBwKSB8fCBQYXRoLmlzQW5jZXN0b3IoX29wLCBwKSkge1xuICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcCwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3AubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9vcDIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgICAgICB9ID0gb3BlcmF0aW9uO1xuXG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMoX29wMiwgcCkgfHwgUGF0aC5lbmRzQmVmb3JlKF9vcDIsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wMi5sZW5ndGggLSAxXSAtPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMiwgcCkpIHtcbiAgICAgICAgICAgICAgcFtfb3AyLmxlbmd0aCAtIDFdIC09IDE7XG4gICAgICAgICAgICAgIHBbX29wMi5sZW5ndGhdICs9IHBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnc3BsaXRfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgdmFyIHtcbiAgICAgICAgICAgICAgcGF0aDogX29wMyxcbiAgICAgICAgICAgICAgcG9zaXRpb246IF9wb3NpdGlvblxuICAgICAgICAgICAgfSA9IG9wZXJhdGlvbjtcblxuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKF9vcDMsIHApKSB7XG4gICAgICAgICAgICAgIGlmIChhZmZpbml0eSA9PT0gJ2ZvcndhcmQnKSB7XG4gICAgICAgICAgICAgICAgcFtwLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAoYWZmaW5pdHkgPT09ICdiYWNrd2FyZCcpIDsgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSBpZiAoUGF0aC5lbmRzQmVmb3JlKF9vcDMsIHApKSB7XG4gICAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmlzQW5jZXN0b3IoX29wMywgcCkgJiYgcGF0aFtfb3AzLmxlbmd0aF0gPj0gX3Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgIHBbX29wMy5sZW5ndGggLSAxXSArPSAxO1xuICAgICAgICAgICAgICBwW19vcDMubGVuZ3RoXSAtPSBfcG9zaXRpb247XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIHZhciB7XG4gICAgICAgICAgICAgIHBhdGg6IF9vcDQsXG4gICAgICAgICAgICAgIG5ld1BhdGg6IG9ucFxuICAgICAgICAgICAgfSA9IG9wZXJhdGlvbjsgLy8gSWYgdGhlIG9sZCBhbmQgbmV3IHBhdGggYXJlIHRoZSBzYW1lLCBpdCdzIGEgbm8tb3AuXG5cbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhfb3A0LCBvbnApKSB7XG4gICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKFBhdGguaXNBbmNlc3Rvcihfb3A0LCBwKSB8fCBQYXRoLmVxdWFscyhfb3A0LCBwKSkge1xuICAgICAgICAgICAgICB2YXIgY29weSA9IG9ucC5zbGljZSgpO1xuXG4gICAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgb25wKSAmJiBfb3A0Lmxlbmd0aCA8IG9ucC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb3B5W19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHJldHVybiBjb3B5LmNvbmNhdChwLnNsaWNlKF9vcDQubGVuZ3RoKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguaXNTaWJsaW5nKF9vcDQsIG9ucCkgJiYgKFBhdGguaXNBbmNlc3RvcihvbnAsIHApIHx8IFBhdGguZXF1YWxzKG9ucCwgcCkpKSB7XG4gICAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gKz0gMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChQYXRoLmVuZHNCZWZvcmUob25wLCBwKSB8fCBQYXRoLmVxdWFscyhvbnAsIHApIHx8IFBhdGguaXNBbmNlc3RvcihvbnAsIHApKSB7XG4gICAgICAgICAgICAgIGlmIChQYXRoLmVuZHNCZWZvcmUoX29wNCwgcCkpIHtcbiAgICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKFBhdGguZW5kc0JlZm9yZShfb3A0LCBwKSkge1xuICAgICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob25wLCBwKSkge1xuICAgICAgICAgICAgICAgIHBbb25wLmxlbmd0aCAtIDFdICs9IDE7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBwW19vcDQubGVuZ3RoIC0gMV0gLT0gMTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn07XG5cbnZhciBQYXRoUmVmID0ge1xuICAvKipcclxuICAgKiBUcmFuc2Zvcm0gdGhlIHBhdGggcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBQYXRoLnRyYW5zZm9ybShjdXJyZW50LCBvcCwge1xuICAgICAgYWZmaW5pdHlcbiAgICB9KTtcbiAgICByZWYuY3VycmVudCA9IHBhdGg7XG5cbiAgICBpZiAocGF0aCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cblxufTtcblxuZnVuY3Rpb24gb3duS2V5cyQ2KG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCQ2KHRhcmdldCkgeyBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykgeyB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldICE9IG51bGwgPyBhcmd1bWVudHNbaV0gOiB7fTsgaWYgKGkgJSAyKSB7IG93bktleXMkNihPYmplY3Qoc291cmNlKSwgdHJ1ZSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pOyB9KTsgfSBlbHNlIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycykgeyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpOyB9IGVsc2UgeyBvd25LZXlzJDYoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG5cbnZhciBQb2ludCA9IHtcbiAgLyoqXHJcbiAgICogQ29tcGFyZSBhIHBvaW50IHRvIGFub3RoZXIsIHJldHVybmluZyBhbiBpbnRlZ2VyIGluZGljYXRpbmcgd2hldGhlciB0aGVcclxuICAgKiBwb2ludCB3YXMgYmVmb3JlLCBhdCwgb3IgYWZ0ZXIgdGhlIG90aGVyLlxyXG4gICAqL1xuICBjb21wYXJlKHBvaW50LCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3VsdCA9IFBhdGguY29tcGFyZShwb2ludC5wYXRoLCBhbm90aGVyLnBhdGgpO1xuXG4gICAgaWYgKHJlc3VsdCA9PT0gMCkge1xuICAgICAgaWYgKHBvaW50Lm9mZnNldCA8IGFub3RoZXIub2Zmc2V0KSByZXR1cm4gLTE7XG4gICAgICBpZiAocG9pbnQub2Zmc2V0ID4gYW5vdGhlci5vZmZzZXQpIHJldHVybiAxO1xuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHBvaW50IGlzIGFmdGVyIGFub3RoZXIuXHJcbiAgICovXG4gIGlzQWZ0ZXIocG9pbnQsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuY29tcGFyZShwb2ludCwgYW5vdGhlcikgPT09IDE7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSBwb2ludCBpcyBiZWZvcmUgYW5vdGhlci5cclxuICAgKi9cbiAgaXNCZWZvcmUocG9pbnQsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuY29tcGFyZShwb2ludCwgYW5vdGhlcikgPT09IC0xO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcG9pbnQgaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHMocG9pbnQsIGFub3RoZXIpIHtcbiAgICAvLyBQRVJGOiBlbnN1cmUgdGhlIG9mZnNldHMgYXJlIGVxdWFsIGZpcnN0IHNpbmNlIHRoZXkgYXJlIGNoZWFwZXIgdG8gY2hlY2suXG4gICAgcmV0dXJuIHBvaW50Lm9mZnNldCA9PT0gYW5vdGhlci5vZmZzZXQgJiYgUGF0aC5lcXVhbHMocG9pbnQucGF0aCwgYW5vdGhlci5wYXRoKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBQb2ludGAgaW50ZXJmYWNlLlxyXG4gICAqL1xuICBpc1BvaW50KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUGxhaW5PYmplY3QodmFsdWUpICYmIHR5cGVvZiB2YWx1ZS5vZmZzZXQgPT09ICdudW1iZXInICYmIFBhdGguaXNQYXRoKHZhbHVlLnBhdGgpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSBhIHBvaW50IGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHBvaW50LCBvcCkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICByZXR1cm4gcHJvZHVjZShwb2ludCwgcCA9PiB7XG4gICAgICBpZiAocCA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cblxuICAgICAgdmFyIHtcbiAgICAgICAgYWZmaW5pdHkgPSAnZm9yd2FyZCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0XG4gICAgICB9ID0gcDtcblxuICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgIGNhc2UgJ2luc2VydF9ub2RlJzpcbiAgICAgICAgY2FzZSAnbW92ZV9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiAob3Aub2Zmc2V0IDwgb2Zmc2V0IHx8IG9wLm9mZnNldCA9PT0gb2Zmc2V0ICYmIGFmZmluaXR5ID09PSAnZm9yd2FyZCcpKSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0ICs9IG9wLnRleHQubGVuZ3RoO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAnbWVyZ2Vfbm9kZSc6XG4gICAgICAgICAge1xuICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG9wLnBhdGgsIHBhdGgpKSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0ICs9IG9wLnBvc2l0aW9uO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBwLnBhdGggPSBQYXRoLnRyYW5zZm9ybShwYXRoLCBvcCwgb3B0aW9ucyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX3RleHQnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSAmJiBvcC5vZmZzZXQgPD0gb2Zmc2V0KSB7XG4gICAgICAgICAgICAgIHAub2Zmc2V0IC09IE1hdGgubWluKG9mZnNldCAtIG9wLm9mZnNldCwgb3AudGV4dC5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgY2FzZSAncmVtb3ZlX25vZGUnOlxuICAgICAgICAgIHtcbiAgICAgICAgICAgIGlmIChQYXRoLmVxdWFscyhvcC5wYXRoLCBwYXRoKSB8fCBQYXRoLmlzQW5jZXN0b3Iob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cblxuICAgICAgICBjYXNlICdzcGxpdF9ub2RlJzpcbiAgICAgICAgICB7XG4gICAgICAgICAgICBpZiAoUGF0aC5lcXVhbHMob3AucGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAgICAgaWYgKG9wLnBvc2l0aW9uID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wLnBvc2l0aW9uIDwgb2Zmc2V0IHx8IG9wLnBvc2l0aW9uID09PSBvZmZzZXQgJiYgYWZmaW5pdHkgPT09ICdmb3J3YXJkJykge1xuICAgICAgICAgICAgICAgIHAub2Zmc2V0IC09IG9wLnBvc2l0aW9uO1xuICAgICAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBfb2JqZWN0U3ByZWFkJDYoX29iamVjdFNwcmVhZCQ2KHt9LCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgICAgICAgIGFmZmluaXR5OiAnZm9yd2FyZCdcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHAucGF0aCA9IFBhdGgudHJhbnNmb3JtKHBhdGgsIG9wLCBvcHRpb25zKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbn07XG5cbnZhciBQb2ludFJlZiA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBwb2ludCByZWYncyBjdXJyZW50IHZhbHVlIGJ5IGFuIG9wZXJhdGlvbi5cclxuICAgKi9cbiAgdHJhbnNmb3JtKHJlZiwgb3ApIHtcbiAgICB2YXIge1xuICAgICAgY3VycmVudCxcbiAgICAgIGFmZmluaXR5XG4gICAgfSA9IHJlZjtcblxuICAgIGlmIChjdXJyZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgcG9pbnQgPSBQb2ludC50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwb2ludDtcblxuICAgIGlmIChwb2ludCA9PSBudWxsKSB7XG4gICAgICByZWYudW5yZWYoKTtcbiAgICB9XG4gIH1cblxufTtcblxudmFyIF9leGNsdWRlZCQyID0gW1wiYW5jaG9yXCIsIFwiZm9jdXNcIl07XG5cbmZ1bmN0aW9uIG93bktleXMkNShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkNSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDUoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQ1KE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgUmFuZ2UgPSB7XG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgYW5kIGVuZCBwb2ludHMgb2YgYSByYW5nZSwgaW4gdGhlIG9yZGVyIGluIHdoaWNoIHRoZXkgYXBwZWFyXHJcbiAgICogaW4gdGhlIGRvY3VtZW50LlxyXG4gICAqL1xuICBlZGdlcyhyYW5nZSkge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgcmV2ZXJzZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHJhbmdlO1xuICAgIHJldHVybiBSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKSA9PT0gcmV2ZXJzZSA/IFthbmNob3IsIGZvY3VzXSA6IFtmb2N1cywgYW5jaG9yXTtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGVuZCBwb2ludCBvZiBhIHJhbmdlLlxyXG4gICAqL1xuICBlbmQocmFuZ2UpIHtcbiAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICByZXR1cm4gZW5kO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgZXhhY3RseSBlcXVhbCB0byBhbm90aGVyLlxyXG4gICAqL1xuICBlcXVhbHMocmFuZ2UsIGFub3RoZXIpIHtcbiAgICByZXR1cm4gUG9pbnQuZXF1YWxzKHJhbmdlLmFuY2hvciwgYW5vdGhlci5hbmNob3IpICYmIFBvaW50LmVxdWFscyhyYW5nZS5mb2N1cywgYW5vdGhlci5mb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpbmNsdWRlcyBhIHBhdGgsIGEgcG9pbnQgb3IgcGFydCBvZiBhbm90aGVyIHJhbmdlLlxyXG4gICAqL1xuICBpbmNsdWRlcyhyYW5nZSwgdGFyZ2V0KSB7XG4gICAgaWYgKFJhbmdlLmlzUmFuZ2UodGFyZ2V0KSkge1xuICAgICAgaWYgKFJhbmdlLmluY2x1ZGVzKHJhbmdlLCB0YXJnZXQuYW5jaG9yKSB8fCBSYW5nZS5pbmNsdWRlcyhyYW5nZSwgdGFyZ2V0LmZvY3VzKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgdmFyIFtycywgcmVdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgICAgdmFyIFt0cywgdGVdID0gUmFuZ2UuZWRnZXModGFyZ2V0KTtcbiAgICAgIHJldHVybiBQb2ludC5pc0JlZm9yZShycywgdHMpICYmIFBvaW50LmlzQWZ0ZXIocmUsIHRlKTtcbiAgICB9XG5cbiAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMocmFuZ2UpO1xuICAgIHZhciBpc0FmdGVyU3RhcnQgPSBmYWxzZTtcbiAgICB2YXIgaXNCZWZvcmVFbmQgPSBmYWxzZTtcblxuICAgIGlmIChQb2ludC5pc1BvaW50KHRhcmdldCkpIHtcbiAgICAgIGlzQWZ0ZXJTdGFydCA9IFBvaW50LmNvbXBhcmUodGFyZ2V0LCBzdGFydCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUG9pbnQuY29tcGFyZSh0YXJnZXQsIGVuZCkgPD0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgaXNBZnRlclN0YXJ0ID0gUGF0aC5jb21wYXJlKHRhcmdldCwgc3RhcnQucGF0aCkgPj0gMDtcbiAgICAgIGlzQmVmb3JlRW5kID0gUGF0aC5jb21wYXJlKHRhcmdldCwgZW5kLnBhdGgpIDw9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIGlzQWZ0ZXJTdGFydCAmJiBpc0JlZm9yZUVuZDtcbiAgfSxcblxuICAvKipcclxuICAgKiBHZXQgdGhlIGludGVyc2VjdGlvbiBvZiBhIHJhbmdlIHdpdGggYW5vdGhlci5cclxuICAgKi9cbiAgaW50ZXJzZWN0aW9uKHJhbmdlLCBhbm90aGVyKSB7XG4gICAgdmFyIHJlc3QgPSBfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMocmFuZ2UsIF9leGNsdWRlZCQyKTtcblxuICAgIHZhciBbczEsIGUxXSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICB2YXIgW3MyLCBlMl0gPSBSYW5nZS5lZGdlcyhhbm90aGVyKTtcbiAgICB2YXIgc3RhcnQgPSBQb2ludC5pc0JlZm9yZShzMSwgczIpID8gczIgOiBzMTtcbiAgICB2YXIgZW5kID0gUG9pbnQuaXNCZWZvcmUoZTEsIGUyKSA/IGUxIDogZTI7XG5cbiAgICBpZiAoUG9pbnQuaXNCZWZvcmUoZW5kLCBzdGFydCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gX29iamVjdFNwcmVhZCQ1KHtcbiAgICAgICAgYW5jaG9yOiBzdGFydCxcbiAgICAgICAgZm9jdXM6IGVuZFxuICAgICAgfSwgcmVzdCk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgYmFja3dhcmQsIG1lYW5pbmcgdGhhdCBpdHMgYW5jaG9yIHBvaW50IGFwcGVhcnMgaW4gdGhlXHJcbiAgICogZG9jdW1lbnQgX2FmdGVyXyBpdHMgZm9jdXMgcG9pbnQuXHJcbiAgICovXG4gIGlzQmFja3dhcmQocmFuZ2UpIHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIFBvaW50LmlzQWZ0ZXIoYW5jaG9yLCBmb2N1cyk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSByYW5nZSBpcyBjb2xsYXBzZWQsIG1lYW5pbmcgdGhhdCBib3RoIGl0cyBhbmNob3IgYW5kIGZvY3VzXHJcbiAgICogcG9pbnRzIHJlZmVyIHRvIHRoZSBleGFjdCBzYW1lIHBvc2l0aW9uIGluIHRoZSBkb2N1bWVudC5cclxuICAgKi9cbiAgaXNDb2xsYXBzZWQocmFuZ2UpIHtcbiAgICB2YXIge1xuICAgICAgYW5jaG9yLFxuICAgICAgZm9jdXNcbiAgICB9ID0gcmFuZ2U7XG4gICAgcmV0dXJuIFBvaW50LmVxdWFscyhhbmNob3IsIGZvY3VzKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHJhbmdlIGlzIGV4cGFuZGVkLlxyXG4gICAqXHJcbiAgICogVGhpcyBpcyB0aGUgb3Bwb3NpdGUgb2YgW1tSYW5nZS5pc0NvbGxhcHNlZF1dIGFuZCBpcyBwcm92aWRlZCBmb3IgbGVnaWJpbGl0eS5cclxuICAgKi9cbiAgaXNFeHBhbmRlZChyYW5nZSkge1xuICAgIHJldHVybiAhUmFuZ2UuaXNDb2xsYXBzZWQocmFuZ2UpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIGEgcmFuZ2UgaXMgZm9yd2FyZC5cclxuICAgKlxyXG4gICAqIFRoaXMgaXMgdGhlIG9wcG9zaXRlIG9mIFtbUmFuZ2UuaXNCYWNrd2FyZF1dIGFuZCBpcyBwcm92aWRlZCBmb3IgbGVnaWJpbGl0eS5cclxuICAgKi9cbiAgaXNGb3J3YXJkKHJhbmdlKSB7XG4gICAgcmV0dXJuICFSYW5nZS5pc0JhY2t3YXJkKHJhbmdlKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIFtbUmFuZ2VdXSBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzUmFuZ2UodmFsdWUpIHtcbiAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgJiYgUG9pbnQuaXNQb2ludCh2YWx1ZS5hbmNob3IpICYmIFBvaW50LmlzUG9pbnQodmFsdWUuZm9jdXMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIHBvaW50IGVudHJpZXMgaW4gYSByYW5nZS5cclxuICAgKi9cbiAgKnBvaW50cyhyYW5nZSkge1xuICAgIHlpZWxkIFtyYW5nZS5hbmNob3IsICdhbmNob3InXTtcbiAgICB5aWVsZCBbcmFuZ2UuZm9jdXMsICdmb2N1cyddO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgc3RhcnQgcG9pbnQgb2YgYSByYW5nZS5cclxuICAgKi9cbiAgc3RhcnQocmFuZ2UpIHtcbiAgICB2YXIgW3N0YXJ0XSA9IFJhbmdlLmVkZ2VzKHJhbmdlKTtcbiAgICByZXR1cm4gc3RhcnQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIGEgcmFuZ2UgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0ocmFuZ2UsIG9wKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHJldHVybiBwcm9kdWNlKHJhbmdlLCByID0+IHtcbiAgICAgIGlmIChyID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIge1xuICAgICAgICBhZmZpbml0eSA9ICdpbndhcmQnXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciBhZmZpbml0eUFuY2hvcjtcbiAgICAgIHZhciBhZmZpbml0eUZvY3VzO1xuXG4gICAgICBpZiAoYWZmaW5pdHkgPT09ICdpbndhcmQnKSB7XG4gICAgICAgIC8vIElmIHRoZSByYW5nZSBpcyBjb2xsYXBzZWQsIG1ha2Ugc3VyZSB0byB1c2UgdGhlIHNhbWUgYWZmaW5pdHkgdG9cbiAgICAgICAgLy8gYXZvaWQgdGhlIHR3byBwb2ludHMgcGFzc2luZyBlYWNoIG90aGVyIGFuZCBleHBhbmRpbmcgaW4gdGhlIG9wcG9zaXRlXG4gICAgICAgIC8vIGRpcmVjdGlvblxuICAgICAgICB2YXIgaXNDb2xsYXBzZWQgPSBSYW5nZS5pc0NvbGxhcHNlZChyKTtcblxuICAgICAgICBpZiAoUmFuZ2UuaXNGb3J3YXJkKHIpKSB7XG4gICAgICAgICAgYWZmaW5pdHlBbmNob3IgPSAnZm9yd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGlzQ29sbGFwc2VkID8gYWZmaW5pdHlBbmNob3IgOiAnYmFja3dhcmQnO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFmZmluaXR5QW5jaG9yID0gJ2JhY2t3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gaXNDb2xsYXBzZWQgPyBhZmZpbml0eUFuY2hvciA6ICdmb3J3YXJkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChhZmZpbml0eSA9PT0gJ291dHdhcmQnKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0ZvcndhcmQocikpIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdiYWNrd2FyZCc7XG4gICAgICAgICAgYWZmaW5pdHlGb2N1cyA9ICdmb3J3YXJkJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZmZpbml0eUFuY2hvciA9ICdmb3J3YXJkJztcbiAgICAgICAgICBhZmZpbml0eUZvY3VzID0gJ2JhY2t3YXJkJztcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWZmaW5pdHlBbmNob3IgPSBhZmZpbml0eTtcbiAgICAgICAgYWZmaW5pdHlGb2N1cyA9IGFmZmluaXR5O1xuICAgICAgfVxuXG4gICAgICB2YXIgYW5jaG9yID0gUG9pbnQudHJhbnNmb3JtKHIuYW5jaG9yLCBvcCwge1xuICAgICAgICBhZmZpbml0eTogYWZmaW5pdHlBbmNob3JcbiAgICAgIH0pO1xuICAgICAgdmFyIGZvY3VzID0gUG9pbnQudHJhbnNmb3JtKHIuZm9jdXMsIG9wLCB7XG4gICAgICAgIGFmZmluaXR5OiBhZmZpbml0eUZvY3VzXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFhbmNob3IgfHwgIWZvY3VzKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICByLmFuY2hvciA9IGFuY2hvcjtcbiAgICAgIHIuZm9jdXMgPSBmb2N1cztcbiAgICB9KTtcbiAgfVxuXG59O1xuXG52YXIgUmFuZ2VSZWYgPSB7XG4gIC8qKlxyXG4gICAqIFRyYW5zZm9ybSB0aGUgcmFuZ2UgcmVmJ3MgY3VycmVudCB2YWx1ZSBieSBhbiBvcGVyYXRpb24uXHJcbiAgICovXG4gIHRyYW5zZm9ybShyZWYsIG9wKSB7XG4gICAgdmFyIHtcbiAgICAgIGN1cnJlbnQsXG4gICAgICBhZmZpbml0eVxuICAgIH0gPSByZWY7XG5cbiAgICBpZiAoY3VycmVudCA9PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHBhdGggPSBSYW5nZS50cmFuc2Zvcm0oY3VycmVudCwgb3AsIHtcbiAgICAgIGFmZmluaXR5XG4gICAgfSk7XG4gICAgcmVmLmN1cnJlbnQgPSBwYXRoO1xuXG4gICAgaWYgKHBhdGggPT0gbnVsbCkge1xuICAgICAgcmVmLnVucmVmKCk7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBfc2NydWJiZXIgPSB1bmRlZmluZWQ7XG4vKipcclxuICogVGhpcyBpbnRlcmZhY2UgaW1wbGVtZW50cyBhIHN0cmluZ2lmeSgpIGZ1bmN0aW9uLCB3aGljaCBpcyB1c2VkIGJ5IFNsYXRlXHJcbiAqIGludGVybmFsbHkgd2hlbiBnZW5lcmF0aW5nIGV4Y2VwdGlvbnMgY29udGFpbmluZyBlbmQgdXNlciBkYXRhLiBEZXZlbG9wZXJzXHJcbiAqIHVzaW5nIFNsYXRlIG1heSBjYWxsIFNjcnViYmVyLnNldFNjcnViYmVyKCkgdG8gYWx0ZXIgdGhlIGJlaGF2aW9yIG9mIHRoaXNcclxuICogc3RyaW5naWZ5KCkgZnVuY3Rpb24uXHJcbiAqXHJcbiAqIEZvciBleGFtcGxlLCB0byBwcmV2ZW50IHRoZSBjbGVhcnRleHQgbG9nZ2luZyBvZiAndGV4dCcgZmllbGRzIHdpdGhpbiBOb2RlczpcclxuICpcclxuICogICAgaW1wb3J0IHsgU2NydWJiZXIgfSBmcm9tICdzbGF0ZSc7XHJcbiAqICAgIFNjcnViYmVyLnNldFNjcnViYmVyKChrZXksIHZhbCkgPT4ge1xyXG4gKiAgICAgIGlmIChrZXkgPT09ICd0ZXh0JykgcmV0dXJuICcuLi5zY3J1YmJlZC4uLidcclxuICogICAgICByZXR1cm4gdmFsXHJcbiAqICAgIH0pO1xyXG4gKlxyXG4gKi9cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxudmFyIFNjcnViYmVyID0ge1xuICBzZXRTY3J1YmJlcihzY3J1YmJlcikge1xuICAgIF9zY3J1YmJlciA9IHNjcnViYmVyO1xuICB9LFxuXG4gIHN0cmluZ2lmeSh2YWx1ZSkge1xuICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgX3NjcnViYmVyKTtcbiAgfVxuXG59O1xuXG4vKlxyXG4gIEN1c3RvbSBkZWVwIGVxdWFsIGNvbXBhcmlzb24gZm9yIFNsYXRlIG5vZGVzLlxyXG5cbiAgV2UgZG9uJ3QgbmVlZCBnZW5lcmFsIHB1cnBvc2UgZGVlcCBlcXVhbGl0eTtcclxuICBTbGF0ZSBvbmx5IHN1cHBvcnRzIHBsYWluIHZhbHVlcywgQXJyYXlzLCBhbmQgbmVzdGVkIG9iamVjdHMuXHJcbiAgQ29tcGxleCB2YWx1ZXMgbmVzdGVkIGluc2lkZSBBcnJheXMgYXJlIG5vdCBzdXBwb3J0ZWQuXHJcblxuICBTbGF0ZSBvYmplY3RzIGFyZSBkZXNpZ25lZCB0byBiZSBzZXJpYWxpc2VkLCBzb1xyXG4gIG1pc3Npbmcga2V5cyBhcmUgZGVsaWJlcmF0ZWx5IG5vcm1hbGlzZWQgdG8gdW5kZWZpbmVkLlxyXG4gKi9cblxudmFyIGlzRGVlcEVxdWFsID0gKG5vZGUsIGFub3RoZXIpID0+IHtcbiAgZm9yICh2YXIga2V5IGluIG5vZGUpIHtcbiAgICB2YXIgYSA9IG5vZGVba2V5XTtcbiAgICB2YXIgYiA9IGFub3RoZXJba2V5XTtcblxuICAgIGlmIChpc1BsYWluT2JqZWN0KGEpICYmIGlzUGxhaW5PYmplY3QoYikpIHtcbiAgICAgIGlmICghaXNEZWVwRXF1YWwoYSwgYikpIHJldHVybiBmYWxzZTtcbiAgICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuICAgICAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFbaV0gIT09IGJbaV0pIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGEgIT09IGIpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgLypcclxuICAgIERlZXAgb2JqZWN0IGVxdWFsaXR5IGlzIG9ubHkgbmVjZXNzYXJ5IGluIG9uZSBkaXJlY3Rpb247IGluIHRoZSByZXZlcnNlIGRpcmVjdGlvblxyXG4gICAgd2UgYXJlIG9ubHkgbG9va2luZyBmb3Iga2V5cyB0aGF0IGFyZSBtaXNzaW5nLlxyXG4gICAgQXMgYWJvdmUsIHVuZGVmaW5lZCBrZXlzIGFyZSBub3JtYWxpc2VkIHRvIG1pc3NpbmcuXHJcbiAgKi9cblxuXG4gIGZvciAodmFyIF9rZXkgaW4gYW5vdGhlcikge1xuICAgIGlmIChub2RlW19rZXldID09PSB1bmRlZmluZWQgJiYgYW5vdGhlcltfa2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgX2V4Y2x1ZGVkJDEgPSBbXCJ0ZXh0XCJdLFxuICAgIF9leGNsdWRlZDIkMSA9IFtcImFuY2hvclwiLCBcImZvY3VzXCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDQob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDQodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQ0KE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkNChPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIFRleHQgPSB7XG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHR3byB0ZXh0IG5vZGVzIGFyZSBlcXVhbC5cclxuICAgKlxyXG4gICAqIFdoZW4gbG9vc2UgaXMgc2V0LCB0aGUgdGV4dCBpcyBub3QgY29tcGFyZWQuIFRoaXMgaXNcclxuICAgKiB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgc2libGluZyB0ZXh0IG5vZGVzIGNhbiBiZSBtZXJnZWQuXHJcbiAgICovXG4gIGVxdWFscyh0ZXh0LCBhbm90aGVyKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBsb29zZSA9IGZhbHNlXG4gICAgfSA9IG9wdGlvbnM7XG5cbiAgICBmdW5jdGlvbiBvbWl0VGV4dChvYmopIHtcbiAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG9iaiwgX2V4Y2x1ZGVkJDEpO1xuXG4gICAgICByZXR1cm4gcmVzdDtcbiAgICB9XG5cbiAgICByZXR1cm4gaXNEZWVwRXF1YWwobG9vc2UgPyBvbWl0VGV4dCh0ZXh0KSA6IHRleHQsIGxvb3NlID8gb21pdFRleHQoYW5vdGhlcikgOiBhbm90aGVyKTtcbiAgfSxcblxuICAvKipcclxuICAgKiBDaGVjayBpZiBhIHZhbHVlIGltcGxlbWVudHMgdGhlIGBUZXh0YCBpbnRlcmZhY2UuXHJcbiAgICovXG4gIGlzVGV4dCh2YWx1ZSkge1xuICAgIHJldHVybiBpc1BsYWluT2JqZWN0KHZhbHVlKSAmJiB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ3N0cmluZyc7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYSB2YWx1ZSBpcyBhIGxpc3Qgb2YgYFRleHRgIG9iamVjdHMuXHJcbiAgICovXG4gIGlzVGV4dExpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkodmFsID0+IFRleHQuaXNUZXh0KHZhbCkpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHNvbWUgcHJvcHMgYXJlIGEgcGFydGlhbCBvZiBUZXh0LlxyXG4gICAqL1xuICBpc1RleHRQcm9wcyhwcm9wcykge1xuICAgIHJldHVybiBwcm9wcy50ZXh0ICE9PSB1bmRlZmluZWQ7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgYW4gdGV4dCBtYXRjaGVzIHNldCBvZiBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogTm90ZTogdGhpcyBpcyBmb3IgbWF0Y2hpbmcgY3VzdG9tIHByb3BlcnRpZXMsIGFuZCBpdCBkb2VzIG5vdCBlbnN1cmUgdGhhdFxyXG4gICAqIHRoZSBgdGV4dGAgcHJvcGVydHkgYXJlIHR3byBub2RlcyBlcXVhbC5cclxuICAgKi9cbiAgbWF0Y2hlcyh0ZXh0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wcykge1xuICAgICAgaWYgKGtleSA9PT0gJ3RleHQnKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRleHQuaGFzT3duUHJvcGVydHkoa2V5KSB8fCB0ZXh0W2tleV0gIT09IHByb3BzW2tleV0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIEdldCB0aGUgbGVhdmVzIGZvciBhIHRleHQgbm9kZSBnaXZlbiBkZWNvcmF0aW9ucy5cclxuICAgKi9cbiAgZGVjb3JhdGlvbnMobm9kZSwgZGVjb3JhdGlvbnMpIHtcbiAgICB2YXIgbGVhdmVzID0gW19vYmplY3RTcHJlYWQkNCh7fSwgbm9kZSldO1xuXG4gICAgZm9yICh2YXIgZGVjIG9mIGRlY29yYXRpb25zKSB7XG4gICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhkZWMsIF9leGNsdWRlZDIkMSk7XG5cbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhkZWMpO1xuICAgICAgdmFyIG5leHQgPSBbXTtcbiAgICAgIHZhciBsZWFmRW5kID0gMDtcbiAgICAgIHZhciBkZWNvcmF0aW9uU3RhcnQgPSBzdGFydC5vZmZzZXQ7XG4gICAgICB2YXIgZGVjb3JhdGlvbkVuZCA9IGVuZC5vZmZzZXQ7XG5cbiAgICAgIGZvciAodmFyIGxlYWYgb2YgbGVhdmVzKSB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbGVuZ3RoXG4gICAgICAgIH0gPSBsZWFmLnRleHQ7XG4gICAgICAgIHZhciBsZWFmU3RhcnQgPSBsZWFmRW5kO1xuICAgICAgICBsZWFmRW5kICs9IGxlbmd0aDsgLy8gSWYgdGhlIHJhbmdlIGVuY29tcGFzc2VzIHRoZSBlbnRpcmUgbGVhZiwgYWRkIHRoZSByYW5nZS5cblxuICAgICAgICBpZiAoZGVjb3JhdGlvblN0YXJ0IDw9IGxlYWZTdGFydCAmJiBsZWFmRW5kIDw9IGRlY29yYXRpb25FbmQpIHtcbiAgICAgICAgICBPYmplY3QuYXNzaWduKGxlYWYsIHJlc3QpO1xuICAgICAgICAgIG5leHQucHVzaChsZWFmKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfSAvLyBJZiB0aGUgcmFuZ2UgZXhwYW5kZWQgYW5kIG1hdGNoIHRoZSBsZWFmLCBvciBzdGFydHMgYWZ0ZXIsIG9yIGVuZHMgYmVmb3JlIGl0LCBjb250aW51ZS5cblxuXG4gICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgIT09IGRlY29yYXRpb25FbmQgJiYgKGRlY29yYXRpb25TdGFydCA9PT0gbGVhZkVuZCB8fCBkZWNvcmF0aW9uRW5kID09PSBsZWFmU3RhcnQpIHx8IGRlY29yYXRpb25TdGFydCA+IGxlYWZFbmQgfHwgZGVjb3JhdGlvbkVuZCA8IGxlYWZTdGFydCB8fCBkZWNvcmF0aW9uRW5kID09PSBsZWFmU3RhcnQgJiYgbGVhZlN0YXJ0ICE9PSAwKSB7XG4gICAgICAgICAgbmV4dC5wdXNoKGxlYWYpO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IC8vIE90aGVyd2lzZSB3ZSBuZWVkIHRvIHNwbGl0IHRoZSBsZWFmLCBhdCB0aGUgc3RhcnQsIGVuZCwgb3IgYm90aCxcbiAgICAgICAgLy8gYW5kIGFkZCB0aGUgcmFuZ2UgdG8gdGhlIG1pZGRsZSBpbnRlcnNlY3Rpbmcgc2VjdGlvbi4gRG8gdGhlIGVuZFxuICAgICAgICAvLyBzcGxpdCBmaXJzdCBzaW5jZSB3ZSBkb24ndCBuZWVkIHRvIHVwZGF0ZSB0aGUgb2Zmc2V0IHRoYXQgd2F5LlxuXG5cbiAgICAgICAgdmFyIG1pZGRsZSA9IGxlYWY7XG4gICAgICAgIHZhciBiZWZvcmUgPSB2b2lkIDA7XG4gICAgICAgIHZhciBhZnRlciA9IHZvaWQgMDtcblxuICAgICAgICBpZiAoZGVjb3JhdGlvbkVuZCA8IGxlYWZFbmQpIHtcbiAgICAgICAgICB2YXIgb2ZmID0gZGVjb3JhdGlvbkVuZCAtIGxlYWZTdGFydDtcbiAgICAgICAgICBhZnRlciA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZShvZmYpXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgbWlkZGxlID0gX29iamVjdFNwcmVhZCQ0KF9vYmplY3RTcHJlYWQkNCh7fSwgbWlkZGxlKSwge30sIHtcbiAgICAgICAgICAgIHRleHQ6IG1pZGRsZS50ZXh0LnNsaWNlKDAsIG9mZilcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChkZWNvcmF0aW9uU3RhcnQgPiBsZWFmU3RhcnQpIHtcbiAgICAgICAgICB2YXIgX29mZiA9IGRlY29yYXRpb25TdGFydCAtIGxlYWZTdGFydDtcblxuICAgICAgICAgIGJlZm9yZSA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZSgwLCBfb2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIG1pZGRsZSA9IF9vYmplY3RTcHJlYWQkNChfb2JqZWN0U3ByZWFkJDQoe30sIG1pZGRsZSksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBtaWRkbGUudGV4dC5zbGljZShfb2ZmKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmFzc2lnbihtaWRkbGUsIHJlc3QpO1xuXG4gICAgICAgIGlmIChiZWZvcmUpIHtcbiAgICAgICAgICBuZXh0LnB1c2goYmVmb3JlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5leHQucHVzaChtaWRkbGUpO1xuXG4gICAgICAgIGlmIChhZnRlcikge1xuICAgICAgICAgIG5leHQucHVzaChhZnRlcik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgbGVhdmVzID0gbmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gbGVhdmVzO1xuICB9XG5cbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMyhvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMyh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDMoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgYXBwbHlUb0RyYWZ0ID0gKGVkaXRvciwgc2VsZWN0aW9uLCBvcCkgPT4ge1xuICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICBjYXNlICdpbnNlcnRfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aCxcbiAgICAgICAgICBub2RlXG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgdmFyIHBhcmVudCA9IE5vZGUucGFyZW50KGVkaXRvciwgcGF0aCk7XG4gICAgICAgIHZhciBpbmRleCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcblxuICAgICAgICBpZiAoaW5kZXggPiBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGFuIFxcXCJpbnNlcnRfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChwYXRoLCBcIl0gYmVjYXVzZSB0aGUgZGVzdGluYXRpb24gaXMgcGFzdCB0aGUgZW5kIG9mIHRoZSBub2RlLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICBwYXJlbnQuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAwLCBub2RlKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW3BvaW50LCBrZXldIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25ba2V5XSA9IFBvaW50LnRyYW5zZm9ybShwb2ludCwgb3ApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnaW5zZXJ0X3RleHQnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICB0ZXh0XG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID09PSAwKSBicmVhaztcblxuICAgICAgICB2YXIgX25vZGUgPSBOb2RlLmxlYWYoZWRpdG9yLCBfcGF0aCk7XG5cbiAgICAgICAgdmFyIGJlZm9yZSA9IF9ub2RlLnRleHQuc2xpY2UoMCwgb2Zmc2V0KTtcblxuICAgICAgICB2YXIgYWZ0ZXIgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgX25vZGUudGV4dCA9IGJlZm9yZSArIHRleHQgKyBhZnRlcjtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludCwgX2tleV0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHNlbGVjdGlvbltfa2V5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ21lcmdlX25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoMlxuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgdmFyIF9ub2RlMiA9IE5vZGUuZ2V0KGVkaXRvciwgX3BhdGgyKTtcblxuICAgICAgICB2YXIgcHJldlBhdGggPSBQYXRoLnByZXZpb3VzKF9wYXRoMik7XG4gICAgICAgIHZhciBwcmV2ID0gTm9kZS5nZXQoZWRpdG9yLCBwcmV2UGF0aCk7XG5cbiAgICAgICAgdmFyIF9wYXJlbnQgPSBOb2RlLnBhcmVudChlZGl0b3IsIF9wYXRoMik7XG5cbiAgICAgICAgdmFyIF9pbmRleCA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgaWYgKFRleHQuaXNUZXh0KF9ub2RlMikgJiYgVGV4dC5pc1RleHQocHJldikpIHtcbiAgICAgICAgICBwcmV2LnRleHQgKz0gX25vZGUyLnRleHQ7XG4gICAgICAgIH0gZWxzZSBpZiAoIVRleHQuaXNUZXh0KF9ub2RlMikgJiYgIVRleHQuaXNUZXh0KHByZXYpKSB7XG4gICAgICAgICAgcHJldi5jaGlsZHJlbi5wdXNoKC4uLl9ub2RlMi5jaGlsZHJlbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFwcGx5IGEgXFxcIm1lcmdlX25vZGVcXFwiIG9wZXJhdGlvbiBhdCBwYXRoIFtcIi5jb25jYXQoX3BhdGgyLCBcIl0gdG8gbm9kZXMgb2YgZGlmZmVyZW50IGludGVyZmFjZXM6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KF9ub2RlMiksIFwiIFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KHByZXYpKSk7XG4gICAgICAgIH1cblxuICAgICAgICBfcGFyZW50LmNoaWxkcmVuLnNwbGljZShfaW5kZXgsIDEpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50MiwgX2tleTJdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleTJdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDIsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ21vdmVfbm9kZSc6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgcGF0aDogX3BhdGgzLFxuICAgICAgICAgIG5ld1BhdGhcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChQYXRoLmlzQW5jZXN0b3IoX3BhdGgzLCBuZXdQYXRoKSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBtb3ZlIGEgcGF0aCBbXCIuY29uY2F0KF9wYXRoMywgXCJdIHRvIG5ldyBwYXRoIFtcIikuY29uY2F0KG5ld1BhdGgsIFwiXSBiZWNhdXNlIHRoZSBkZXN0aW5hdGlvbiBpcyBpbnNpZGUgaXRzZWxmLlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25vZGUzID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDMpO1xuXG4gICAgICAgIHZhciBfcGFyZW50MiA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGgzKTtcblxuICAgICAgICB2YXIgX2luZGV4MiA9IF9wYXRoM1tfcGF0aDMubGVuZ3RoIC0gMV07IC8vIFRoaXMgaXMgdHJpY2t5LCBidXQgc2luY2UgdGhlIGBwYXRoYCBhbmQgYG5ld1BhdGhgIGJvdGggcmVmZXIgdG9cbiAgICAgICAgLy8gdGhlIHNhbWUgc25hcHNob3QgaW4gdGltZSwgdGhlcmUncyBhIG1pc21hdGNoLiBBZnRlciBlaXRoZXJcbiAgICAgICAgLy8gcmVtb3ZpbmcgdGhlIG9yaWdpbmFsIHBvc2l0aW9uLCB0aGUgc2Vjb25kIHN0ZXAncyBwYXRoIGNhbiBiZSBvdXRcbiAgICAgICAgLy8gb2YgZGF0ZS4gU28gaW5zdGVhZCBvZiB1c2luZyB0aGUgYG9wLm5ld1BhdGhgIGRpcmVjdGx5LCB3ZVxuICAgICAgICAvLyB0cmFuc2Zvcm0gYG9wLnBhdGhgIHRvIGFzY2VydGFpbiB3aGF0IHRoZSBgbmV3UGF0aGAgd291bGQgYmUgYWZ0ZXJcbiAgICAgICAgLy8gdGhlIG9wZXJhdGlvbiB3YXMgYXBwbGllZC5cblxuICAgICAgICBfcGFyZW50Mi5jaGlsZHJlbi5zcGxpY2UoX2luZGV4MiwgMSk7XG5cbiAgICAgICAgdmFyIHRydWVQYXRoID0gUGF0aC50cmFuc2Zvcm0oX3BhdGgzLCBvcCk7XG4gICAgICAgIHZhciBuZXdQYXJlbnQgPSBOb2RlLmdldChlZGl0b3IsIFBhdGgucGFyZW50KHRydWVQYXRoKSk7XG4gICAgICAgIHZhciBuZXdJbmRleCA9IHRydWVQYXRoW3RydWVQYXRoLmxlbmd0aCAtIDFdO1xuICAgICAgICBuZXdQYXJlbnQuY2hpbGRyZW4uc3BsaWNlKG5ld0luZGV4LCAwLCBfbm9kZTMpO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50MywgX2tleTNdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleTNdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDMsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlbW92ZV9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDRcbiAgICAgICAgfSA9IG9wO1xuICAgICAgICB2YXIgX2luZGV4MyA9IF9wYXRoNFtfcGF0aDQubGVuZ3RoIC0gMV07XG5cbiAgICAgICAgdmFyIF9wYXJlbnQzID0gTm9kZS5wYXJlbnQoZWRpdG9yLCBfcGF0aDQpO1xuXG4gICAgICAgIF9wYXJlbnQzLmNoaWxkcmVuLnNwbGljZShfaW5kZXgzLCAxKTsgLy8gVHJhbnNmb3JtIGFsbCBvZiB0aGUgcG9pbnRzIGluIHRoZSB2YWx1ZSwgYnV0IGlmIHRoZSBwb2ludCB3YXMgaW4gdGhlXG4gICAgICAgIC8vIG5vZGUgdGhhdCB3YXMgcmVtb3ZlZCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgcmFuZ2Ugb3IgcmVtb3ZlIGl0LlxuXG5cbiAgICAgICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgICAgIGZvciAodmFyIFtfcG9pbnQ0LCBfa2V5NF0gb2YgUmFuZ2UucG9pbnRzKHNlbGVjdGlvbikpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBQb2ludC50cmFuc2Zvcm0oX3BvaW50NCwgb3ApO1xuXG4gICAgICAgICAgICBpZiAoc2VsZWN0aW9uICE9IG51bGwgJiYgcmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk0XSA9IHJlc3VsdDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHZhciBfcHJldiA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICB2YXIgbmV4dCA9IHZvaWQgMDtcblxuICAgICAgICAgICAgICBmb3IgKHZhciBbbiwgcF0gb2YgTm9kZS50ZXh0cyhlZGl0b3IpKSB7XG4gICAgICAgICAgICAgICAgaWYgKFBhdGguY29tcGFyZShwLCBfcGF0aDQpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgX3ByZXYgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIG5leHQgPSBbbiwgcF07XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICB2YXIgcHJlZmVyTmV4dCA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIGlmIChfcHJldiAmJiBuZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKFBhdGguZXF1YWxzKG5leHRbMV0sIF9wYXRoNCkpIHtcbiAgICAgICAgICAgICAgICAgIHByZWZlck5leHQgPSAhUGF0aC5oYXNQcmV2aW91cyhuZXh0WzFdKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgcHJlZmVyTmV4dCA9IFBhdGguY29tbW9uKF9wcmV2WzFdLCBfcGF0aDQpLmxlbmd0aCA8IFBhdGguY29tbW9uKG5leHRbMV0sIF9wYXRoNCkubGVuZ3RoO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGlmIChfcHJldiAmJiAhcHJlZmVyTmV4dCkge1xuICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IF9wcmV2WzFdO1xuICAgICAgICAgICAgICAgIF9wb2ludDQub2Zmc2V0ID0gX3ByZXZbMF0udGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSBpZiAobmV4dCkge1xuICAgICAgICAgICAgICAgIF9wb2ludDQucGF0aCA9IG5leHRbMV07XG4gICAgICAgICAgICAgICAgX3BvaW50NC5vZmZzZXQgPSAwO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNlbGVjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3JlbW92ZV90ZXh0JzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDUsXG4gICAgICAgICAgb2Zmc2V0OiBfb2Zmc2V0LFxuICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgIH0gPSBvcDtcbiAgICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA9PT0gMCkgYnJlYWs7XG5cbiAgICAgICAgdmFyIF9ub2RlNCA9IE5vZGUubGVhZihlZGl0b3IsIF9wYXRoNSk7XG5cbiAgICAgICAgdmFyIF9iZWZvcmUgPSBfbm9kZTQudGV4dC5zbGljZSgwLCBfb2Zmc2V0KTtcblxuICAgICAgICB2YXIgX2FmdGVyID0gX25vZGU0LnRleHQuc2xpY2UoX29mZnNldCArIF90ZXh0Lmxlbmd0aCk7XG5cbiAgICAgICAgX25vZGU0LnRleHQgPSBfYmVmb3JlICsgX2FmdGVyO1xuXG4gICAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgICBmb3IgKHZhciBbX3BvaW50NSwgX2tleTVdIG9mIFJhbmdlLnBvaW50cyhzZWxlY3Rpb24pKSB7XG4gICAgICAgICAgICBzZWxlY3Rpb25bX2tleTVdID0gUG9pbnQudHJhbnNmb3JtKF9wb2ludDUsIG9wKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NldF9ub2RlJzpcbiAgICAgIHtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aDYsXG4gICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICBuZXdQcm9wZXJ0aWVzXG4gICAgICAgIH0gPSBvcDtcblxuICAgICAgICBpZiAoX3BhdGg2Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzZXQgcHJvcGVydGllcyBvbiB0aGUgcm9vdCBub2RlIVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBfbm9kZTUgPSBOb2RlLmdldChlZGl0b3IsIF9wYXRoNik7XG5cbiAgICAgICAgZm9yICh2YXIgX2tleTYgaW4gbmV3UHJvcGVydGllcykge1xuICAgICAgICAgIGlmIChfa2V5NiA9PT0gJ2NoaWxkcmVuJyB8fCBfa2V5NiA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3Qgc2V0IHRoZSBcXFwiXCIuY29uY2F0KF9rZXk2LCBcIlxcXCIgcHJvcGVydHkgb2Ygbm9kZXMhXCIpKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgdmFsdWUgPSBuZXdQcm9wZXJ0aWVzW19rZXk2XTtcblxuICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBkZWxldGUgX25vZGU1W19rZXk2XTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX25vZGU1W19rZXk2XSA9IHZhbHVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSAvLyBwcm9wZXJ0aWVzIHRoYXQgd2VyZSBwcmV2aW91c2x5IGRlZmluZWQsIGJ1dCBhcmUgbm93IG1pc3NpbmcsIG11c3QgYmUgZGVsZXRlZFxuXG5cbiAgICAgICAgZm9yICh2YXIgX2tleTcgaW4gcHJvcGVydGllcykge1xuICAgICAgICAgIGlmICghbmV3UHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShfa2V5NykpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBfbm9kZTVbX2tleTddO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgY2FzZSAnc2V0X3NlbGVjdGlvbic6XG4gICAgICB7XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbmV3UHJvcGVydGllczogX25ld1Byb3BlcnRpZXNcbiAgICAgICAgfSA9IG9wO1xuXG4gICAgICAgIGlmIChfbmV3UHJvcGVydGllcyA9PSBudWxsKSB7XG4gICAgICAgICAgc2VsZWN0aW9uID0gX25ld1Byb3BlcnRpZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKHNlbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAoIVJhbmdlLmlzUmFuZ2UoX25ld1Byb3BlcnRpZXMpKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBhcHBseSBhbiBpbmNvbXBsZXRlIFxcXCJzZXRfc2VsZWN0aW9uXFxcIiBvcGVyYXRpb24gcHJvcGVydGllcyBcIi5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KF9uZXdQcm9wZXJ0aWVzKSwgXCIgd2hlbiB0aGVyZSBpcyBubyBjdXJyZW50IHNlbGVjdGlvbi5cIikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBzZWxlY3Rpb24gPSBfb2JqZWN0U3ByZWFkJDMoe30sIF9uZXdQcm9wZXJ0aWVzKTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBmb3IgKHZhciBfa2V5OCBpbiBfbmV3UHJvcGVydGllcykge1xuICAgICAgICAgICAgdmFyIF92YWx1ZSA9IF9uZXdQcm9wZXJ0aWVzW19rZXk4XTtcblxuICAgICAgICAgICAgaWYgKF92YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgIGlmIChfa2V5OCA9PT0gJ2FuY2hvcicgfHwgX2tleTggPT09ICdmb2N1cycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgcmVtb3ZlIHRoZSBcXFwiXCIuY29uY2F0KF9rZXk4LCBcIlxcXCIgc2VsZWN0aW9uIHByb3BlcnR5XCIpKTtcbiAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgIGRlbGV0ZSBzZWxlY3Rpb25bX2tleThdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk4XSA9IF92YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgIGNhc2UgJ3NwbGl0X25vZGUnOlxuICAgICAge1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoNyxcbiAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICBwcm9wZXJ0aWVzOiBfcHJvcGVydGllc1xuICAgICAgICB9ID0gb3A7XG5cbiAgICAgICAgaWYgKF9wYXRoNy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgYXBwbHkgYSBcXFwic3BsaXRfbm9kZVxcXCIgb3BlcmF0aW9uIGF0IHBhdGggW1wiLmNvbmNhdChfcGF0aDcsIFwiXSBiZWNhdXNlIHRoZSByb290IG5vZGUgY2Fubm90IGJlIHNwbGl0LlwiKSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgX25vZGU2ID0gTm9kZS5nZXQoZWRpdG9yLCBfcGF0aDcpO1xuXG4gICAgICAgIHZhciBfcGFyZW50NCA9IE5vZGUucGFyZW50KGVkaXRvciwgX3BhdGg3KTtcblxuICAgICAgICB2YXIgX2luZGV4NCA9IF9wYXRoN1tfcGF0aDcubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciBuZXdOb2RlO1xuXG4gICAgICAgIGlmIChUZXh0LmlzVGV4dChfbm9kZTYpKSB7XG4gICAgICAgICAgdmFyIF9iZWZvcmUyID0gX25vZGU2LnRleHQuc2xpY2UoMCwgcG9zaXRpb24pO1xuXG4gICAgICAgICAgdmFyIF9hZnRlcjIgPSBfbm9kZTYudGV4dC5zbGljZShwb3NpdGlvbik7XG5cbiAgICAgICAgICBfbm9kZTYudGV4dCA9IF9iZWZvcmUyO1xuICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJDMoX29iamVjdFNwcmVhZCQzKHt9LCBfcHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgICAgICB0ZXh0OiBfYWZ0ZXIyXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIF9iZWZvcmUzID0gX25vZGU2LmNoaWxkcmVuLnNsaWNlKDAsIHBvc2l0aW9uKTtcblxuICAgICAgICAgIHZhciBfYWZ0ZXIzID0gX25vZGU2LmNoaWxkcmVuLnNsaWNlKHBvc2l0aW9uKTtcblxuICAgICAgICAgIF9ub2RlNi5jaGlsZHJlbiA9IF9iZWZvcmUzO1xuICAgICAgICAgIG5ld05vZGUgPSBfb2JqZWN0U3ByZWFkJDMoX29iamVjdFNwcmVhZCQzKHt9LCBfcHJvcGVydGllcyksIHt9LCB7XG4gICAgICAgICAgICBjaGlsZHJlbjogX2FmdGVyM1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgX3BhcmVudDQuY2hpbGRyZW4uc3BsaWNlKF9pbmRleDQgKyAxLCAwLCBuZXdOb2RlKTtcblxuICAgICAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICAgICAgZm9yICh2YXIgW19wb2ludDYsIF9rZXk5XSBvZiBSYW5nZS5wb2ludHMoc2VsZWN0aW9uKSkge1xuICAgICAgICAgICAgc2VsZWN0aW9uW19rZXk5XSA9IFBvaW50LnRyYW5zZm9ybShfcG9pbnQ2LCBvcCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gIH1cblxuICByZXR1cm4gc2VsZWN0aW9uO1xufTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXJlZGVjbGFyZVxuXG5cbnZhciBHZW5lcmFsVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogVHJhbnNmb3JtIHRoZSBlZGl0b3IgYnkgYW4gb3BlcmF0aW9uLlxyXG4gICAqL1xuICB0cmFuc2Zvcm0oZWRpdG9yLCBvcCkge1xuICAgIGVkaXRvci5jaGlsZHJlbiA9IGNyZWF0ZURyYWZ0KGVkaXRvci5jaGlsZHJlbik7XG4gICAgdmFyIHNlbGVjdGlvbiA9IGVkaXRvci5zZWxlY3Rpb24gJiYgY3JlYXRlRHJhZnQoZWRpdG9yLnNlbGVjdGlvbik7XG5cbiAgICB0cnkge1xuICAgICAgc2VsZWN0aW9uID0gYXBwbHlUb0RyYWZ0KGVkaXRvciwgc2VsZWN0aW9uLCBvcCk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGVkaXRvci5jaGlsZHJlbiA9IGZpbmlzaERyYWZ0KGVkaXRvci5jaGlsZHJlbik7XG5cbiAgICAgIGlmIChzZWxlY3Rpb24pIHtcbiAgICAgICAgZWRpdG9yLnNlbGVjdGlvbiA9IGlzRHJhZnQoc2VsZWN0aW9uKSA/IGZpbmlzaERyYWZ0KHNlbGVjdGlvbikgOiBzZWxlY3Rpb247XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3Iuc2VsZWN0aW9uID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxufTtcblxudmFyIF9leGNsdWRlZCA9IFtcInRleHRcIl0sXG4gICAgX2V4Y2x1ZGVkMiA9IFtcImNoaWxkcmVuXCJdO1xuXG5mdW5jdGlvbiBvd25LZXlzJDIob2JqZWN0LCBlbnVtZXJhYmxlT25seSkgeyB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7IGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7IHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpOyBpZiAoZW51bWVyYWJsZU9ubHkpIHsgc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHsgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7IH0pOyB9IGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTsgfSByZXR1cm4ga2V5czsgfVxuXG5mdW5jdGlvbiBfb2JqZWN0U3ByZWFkJDIodGFyZ2V0KSB7IGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7IHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaV0gIT0gbnVsbCA/IGFyZ3VtZW50c1tpXSA6IHt9OyBpZiAoaSAlIDIpIHsgb3duS2V5cyQyKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMkMihPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpOyB9KTsgfSB9IHJldHVybiB0YXJnZXQ7IH1cblxudmFyIE5vZGVUcmFuc2Zvcm1zID0ge1xuICAvKipcclxuICAgKiBJbnNlcnQgbm9kZXMgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB0aGUgRWRpdG9yLlxyXG4gICAqL1xuICBpbnNlcnROb2RlcyhlZGl0b3IsIG5vZGVzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2UsXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0J1xuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIHNlbGVjdFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmIChOb2RlLmlzTm9kZShub2RlcykpIHtcbiAgICAgICAgbm9kZXMgPSBbbm9kZXNdO1xuICAgICAgfVxuXG4gICAgICBpZiAobm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgdmFyIFtub2RlXSA9IG5vZGVzOyAvLyBCeSBkZWZhdWx0LCB1c2UgdGhlIHNlbGVjdGlvbiBhcyB0aGUgdGFyZ2V0IGxvY2F0aW9uLiBCdXQgaWYgdGhlcmUgaXNcbiAgICAgIC8vIG5vIHNlbGVjdGlvbiwgaW5zZXJ0IGF0IHRoZSBlbmQgb2YgdGhlIGRvY3VtZW50IHNpbmNlIHRoYXQgaXMgc3VjaCBhXG4gICAgICAvLyBjb21tb24gdXNlIGNhc2Ugd2hlbiBpbnNlcnRpbmcgZnJvbSBhIG5vbi1zZWxlY3RlZCBzdGF0ZS5cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICBpZiAoZWRpdG9yLnNlbGVjdGlvbikge1xuICAgICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbjtcbiAgICAgICAgfSBlbHNlIGlmIChlZGl0b3IuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhdCA9IFswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdCA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIGlmIChzZWxlY3QgPT0gbnVsbCkge1xuICAgICAgICBzZWxlY3QgPSBmYWxzZTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmICghaGFuZ2luZykge1xuICAgICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICAgIHZhciBwb2ludFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGVuZCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5kZWxldGUoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGF0ID0gcG9pbnRSZWYudW5yZWYoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkpIHtcbiAgICAgICAgICAgIG1hdGNoID0gbiA9PiBUZXh0LmlzVGV4dChuKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKGVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgICAgbWF0Y2ggPSBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXRjaCA9IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgW2VudHJ5XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYXQucGF0aCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlbnRyeSkge1xuICAgICAgICAgIHZhciBbLCBfbWF0Y2hQYXRoXSA9IGVudHJ5O1xuICAgICAgICAgIHZhciBwYXRoUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICB2YXIgaXNBdEVuZCA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfbWF0Y2hQYXRoKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdCxcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgdmFyIHBhdGggPSBwYXRoUmVmLnVucmVmKCk7XG4gICAgICAgICAgYXQgPSBpc0F0RW5kID8gUGF0aC5uZXh0KHBhdGgpIDogcGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHBhcmVudFBhdGggPSBQYXRoLnBhcmVudChhdCk7XG4gICAgICB2YXIgaW5kZXggPSBhdFthdC5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKCF2b2lkcyAmJiBFZGl0b3Iudm9pZChlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhcmVudFBhdGhcbiAgICAgIH0pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX25vZGUgb2Ygbm9kZXMpIHtcbiAgICAgICAgdmFyIF9wYXRoID0gcGFyZW50UGF0aC5jb25jYXQoaW5kZXgpO1xuXG4gICAgICAgIGluZGV4Kys7XG4gICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgdHlwZTogJ2luc2VydF9ub2RlJyxcbiAgICAgICAgICBwYXRoOiBfcGF0aCxcbiAgICAgICAgICBub2RlOiBfbm9kZVxuICAgICAgICB9KTtcbiAgICAgICAgYXQgPSBQYXRoLm5leHQoYXQpO1xuICAgICAgfVxuXG4gICAgICBhdCA9IFBhdGgucHJldmlvdXMoYXQpO1xuXG4gICAgICBpZiAoc2VsZWN0KSB7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5lbmQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBwb2ludCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBMaWZ0IG5vZGVzIGF0IGEgc3BlY2lmaWMgbG9jYXRpb24gdXB3YXJkcyBpbiB0aGUgZG9jdW1lbnQgdHJlZSwgc3BsaXR0aW5nXHJcbiAgICogdGhlaXIgcGFyZW50IGluIHR3byBpZiBuZWNlc3NhcnkuXHJcbiAgICovXG4gIGxpZnROb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBQYXRoLmlzUGF0aChhdCkgPyBtYXRjaFBhdGgoZWRpdG9yLCBhdCkgOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgbWF0Y2hlcyA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgcGF0aFJlZnMgPSBBcnJheS5mcm9tKG1hdGNoZXMsIF9yZWYgPT4ge1xuICAgICAgICB2YXIgWywgcF0gPSBfcmVmO1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbGlmdCBub2RlIGF0IGEgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSBiZWNhdXNlIGl0IGhhcyBhIGRlcHRoIG9mIGxlc3MgdGhhbiBgMmAuXCIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwYXJlbnROb2RlRW50cnkgPSBFZGl0b3Iubm9kZShlZGl0b3IsIFBhdGgucGFyZW50KHBhdGgpKTtcbiAgICAgICAgdmFyIFtwYXJlbnQsIHBhcmVudFBhdGhdID0gcGFyZW50Tm9kZUVudHJ5O1xuICAgICAgICB2YXIgaW5kZXggPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgIHZhciB7XG4gICAgICAgICAgbGVuZ3RoXG4gICAgICAgIH0gPSBwYXJlbnQuY2hpbGRyZW47XG5cbiAgICAgICAgaWYgKGxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgIHZhciB0b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgICAgIHRvOiB0b1BhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIFRyYW5zZm9ybXMucmVtb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogcGFyZW50UGF0aCxcbiAgICAgICAgICAgIHZvaWRzXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoaW5kZXggPT09IDApIHtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IHBhcmVudFBhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBsZW5ndGggLSAxKSB7XG4gICAgICAgICAgdmFyIF90b1BhdGggPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgsXG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhciBzcGxpdFBhdGggPSBQYXRoLm5leHQocGF0aCk7XG5cbiAgICAgICAgICB2YXIgX3RvUGF0aDIgPSBQYXRoLm5leHQocGFyZW50UGF0aCk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogc3BsaXRQYXRoLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0OiBwYXRoLFxuICAgICAgICAgICAgdG86IF90b1BhdGgyLFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1lcmdlIGEgbm9kZSBhdCBhIGxvY2F0aW9uIHdpdGggdGhlIHByZXZpb3VzIG5vZGUgb2YgdGhlIHNhbWUgZGVwdGgsXHJcbiAgICogcmVtb3ZpbmcgYW55IGVtcHR5IGNvbnRhaW5pbmcgbm9kZXMgYWZ0ZXIgdGhlIG1lcmdlIGlmIG5lY2Vzc2FyeS5cclxuICAgKi9cbiAgbWVyZ2VOb2RlcyhlZGl0b3IpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWF0KSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICAgIHZhciBbcGFyZW50XSA9IEVkaXRvci5wYXJlbnQoZWRpdG9yLCBhdCk7XG5cbiAgICAgICAgICBtYXRjaCA9IG4gPT4gcGFyZW50LmNoaWxkcmVuLmluY2x1ZGVzKG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghaGFuZ2luZyAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG5cbiAgICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIGF0KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFtjdXJyZW50XSA9IEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICB2b2lkcyxcbiAgICAgICAgbW9kZVxuICAgICAgfSk7XG4gICAgICB2YXIgcHJldiA9IEVkaXRvci5wcmV2aW91cyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICB2b2lkcyxcbiAgICAgICAgbW9kZVxuICAgICAgfSk7XG5cbiAgICAgIGlmICghY3VycmVudCB8fCAhcHJldikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBbbm9kZSwgcGF0aF0gPSBjdXJyZW50O1xuICAgICAgdmFyIFtwcmV2Tm9kZSwgcHJldlBhdGhdID0gcHJldjtcblxuICAgICAgaWYgKHBhdGgubGVuZ3RoID09PSAwIHx8IHByZXZQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBuZXdQYXRoID0gUGF0aC5uZXh0KHByZXZQYXRoKTtcbiAgICAgIHZhciBjb21tb25QYXRoID0gUGF0aC5jb21tb24ocGF0aCwgcHJldlBhdGgpO1xuICAgICAgdmFyIGlzUHJldmlvdXNTaWJsaW5nID0gUGF0aC5pc1NpYmxpbmcocGF0aCwgcHJldlBhdGgpO1xuICAgICAgdmFyIGxldmVscyA9IEFycmF5LmZyb20oRWRpdG9yLmxldmVscyhlZGl0b3IsIHtcbiAgICAgICAgYXQ6IHBhdGhcbiAgICAgIH0pLCBfcmVmMiA9PiB7XG4gICAgICAgIHZhciBbbl0gPSBfcmVmMjtcbiAgICAgICAgcmV0dXJuIG47XG4gICAgICB9KS5zbGljZShjb21tb25QYXRoLmxlbmd0aCkuc2xpY2UoMCwgLTEpOyAvLyBEZXRlcm1pbmUgaWYgdGhlIG1lcmdlIHdpbGwgbGVhdmUgYW4gYW5jZXN0b3Igb2YgdGhlIHBhdGggZW1wdHkgYXMgYVxuICAgICAgLy8gcmVzdWx0LCBpbiB3aGljaCBjYXNlIHdlJ2xsIHdhbnQgdG8gcmVtb3ZlIGl0IGFmdGVyIG1lcmdpbmcuXG5cbiAgICAgIHZhciBlbXB0eUFuY2VzdG9yID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBhdDogcGF0aCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICBtYXRjaDogbiA9PiBsZXZlbHMuaW5jbHVkZXMobikgJiYgaGFzU2luZ2xlQ2hpbGROZXN0KGVkaXRvciwgbilcbiAgICAgIH0pO1xuICAgICAgdmFyIGVtcHR5UmVmID0gZW1wdHlBbmNlc3RvciAmJiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGVtcHR5QW5jZXN0b3JbMV0pO1xuICAgICAgdmFyIHByb3BlcnRpZXM7XG4gICAgICB2YXIgcG9zaXRpb247IC8vIEVuc3VyZSB0aGF0IHRoZSBub2RlcyBhcmUgZXF1aXZhbGVudCwgYW5kIGZpZ3VyZSBvdXQgd2hhdCB0aGUgcG9zaXRpb25cbiAgICAgIC8vIGFuZCBleHRyYSBwcm9wZXJ0aWVzIG9mIHRoZSBtZXJnZSB3aWxsIGJlLlxuXG4gICAgICBpZiAoVGV4dC5pc1RleHQobm9kZSkgJiYgVGV4dC5pc1RleHQocHJldk5vZGUpKSB7XG4gICAgICAgIHZhciByZXN0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKG5vZGUsIF9leGNsdWRlZCk7XG5cbiAgICAgICAgcG9zaXRpb24gPSBwcmV2Tm9kZS50ZXh0Lmxlbmd0aDtcbiAgICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgICB9IGVsc2UgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpICYmIEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSkge1xuICAgICAgICB2YXIgcmVzdCA9IF9vYmplY3RXaXRob3V0UHJvcGVydGllcyhub2RlLCBfZXhjbHVkZWQyKTtcblxuICAgICAgICBwb3NpdGlvbiA9IHByZXZOb2RlLmNoaWxkcmVuLmxlbmd0aDtcbiAgICAgICAgcHJvcGVydGllcyA9IHJlc3Q7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW5ub3QgbWVyZ2UgdGhlIG5vZGUgYXQgcGF0aCBbXCIuY29uY2F0KHBhdGgsIFwiXSB3aXRoIHRoZSBwcmV2aW91cyBzaWJsaW5nIGJlY2F1c2UgaXQgaXMgbm90IHRoZSBzYW1lIGtpbmQ6IFwiKS5jb25jYXQoU2NydWJiZXIuc3RyaW5naWZ5KG5vZGUpLCBcIiBcIikuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeShwcmV2Tm9kZSkpKTtcbiAgICAgIH0gLy8gSWYgdGhlIG5vZGUgaXNuJ3QgYWxyZWFkeSB0aGUgbmV4dCBzaWJsaW5nIG9mIHRoZSBwcmV2aW91cyBub2RlLCBtb3ZlXG4gICAgICAvLyBpdCBzbyB0aGF0IGl0IGlzIGJlZm9yZSBtZXJnaW5nLlxuXG5cbiAgICAgIGlmICghaXNQcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5tb3ZlTm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHBhdGgsXG4gICAgICAgICAgdG86IG5ld1BhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IC8vIElmIHRoZXJlIHdhcyBnb2luZyB0byBiZSBhbiBlbXB0eSBhbmNlc3RvciBvZiB0aGUgbm9kZSB0aGF0IHdhcyBtZXJnZWQsXG4gICAgICAvLyB3ZSByZW1vdmUgaXQgZnJvbSB0aGUgdHJlZS5cblxuXG4gICAgICBpZiAoZW1wdHlSZWYpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW1wdHlSZWYuY3VycmVudCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gSWYgdGhlIHRhcmdldCBub2RlIHRoYXQgd2UncmUgbWVyZ2luZyB3aXRoIGlzIGVtcHR5LCByZW1vdmUgaXQgaW5zdGVhZFxuICAgICAgLy8gb2YgbWVyZ2luZyB0aGUgdHdvLiBUaGlzIGlzIGEgY29tbW9uIHJpY2ggdGV4dCBlZGl0b3IgYmVoYXZpb3IgdG9cbiAgICAgIC8vIHByZXZlbnQgbG9zaW5nIGZvcm1hdHRpbmcgd2hlbiBkZWxldGluZyBlbnRpcmUgbm9kZXMgd2hlbiB5b3UgaGF2ZSBhXG4gICAgICAvLyBoYW5naW5nIHNlbGVjdGlvbi5cbiAgICAgIC8vIGlmIHByZXZOb2RlIGlzIGZpcnN0IGNoaWxkIGluIHBhcmVudCxkb24ndCByZW1vdmUgaXQuXG5cblxuICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHByZXZOb2RlKSAmJiBFZGl0b3IuaXNFbXB0eShlZGl0b3IsIHByZXZOb2RlKSB8fCBUZXh0LmlzVGV4dChwcmV2Tm9kZSkgJiYgcHJldk5vZGUudGV4dCA9PT0gJycgJiYgcHJldlBhdGhbcHJldlBhdGgubGVuZ3RoIC0gMV0gIT09IDApIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogcHJldlBhdGgsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgIHR5cGU6ICdtZXJnZV9ub2RlJyxcbiAgICAgICAgICBwYXRoOiBuZXdQYXRoLFxuICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgIHByb3BlcnRpZXNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmIChlbXB0eVJlZikge1xuICAgICAgICBlbXB0eVJlZi51bnJlZigpO1xuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIG5vZGVzIGF0IGEgbG9jYXRpb24gdG8gYSBuZXcgbG9jYXRpb24uXHJcbiAgICovXG4gIG1vdmVOb2RlcyhlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgdG8sXG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvbixcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgIG1hdGNoID0gUGF0aC5pc1BhdGgoYXQpID8gbWF0Y2hQYXRoKGVkaXRvciwgYXQpIDogbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgfVxuXG4gICAgICB2YXIgdG9SZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHRvKTtcbiAgICAgIHZhciB0YXJnZXRzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20odGFyZ2V0cywgX3JlZjMgPT4ge1xuICAgICAgICB2YXIgWywgcF0gPSBfcmVmMztcbiAgICAgICAgcmV0dXJuIEVkaXRvci5wYXRoUmVmKGVkaXRvciwgcCk7XG4gICAgICB9KTtcblxuICAgICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgICB2YXIgcGF0aCA9IHBhdGhSZWYudW5yZWYoKTtcbiAgICAgICAgdmFyIG5ld1BhdGggPSB0b1JlZi5jdXJyZW50O1xuXG4gICAgICAgIGlmIChwYXRoLmxlbmd0aCAhPT0gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAnbW92ZV9ub2RlJyxcbiAgICAgICAgICAgIHBhdGgsXG4gICAgICAgICAgICBuZXdQYXRoXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodG9SZWYuY3VycmVudCAmJiBQYXRoLmlzU2libGluZyhuZXdQYXRoLCBwYXRoKSAmJiBQYXRoLmlzQWZ0ZXIobmV3UGF0aCwgcGF0aCkpIHtcbiAgICAgICAgICAvLyBXaGVuIHBlcmZvcm1pbmcgYSBzaWJsaW5nIG1vdmUgdG8gYSBsYXRlciBpbmRleCwgdGhlIHBhdGggYXQgdGhlIGRlc3RpbmF0aW9uIGlzIHNoaWZ0ZWRcbiAgICAgICAgICAvLyB0byBiZWZvcmUgdGhlIGluc2VydGlvbiBwb2ludCBpbnN0ZWFkIG9mIGFmdGVyLiBUbyBlbnN1cmUgb3VyIGdyb3VwIG9mIG5vZGVzIGFyZSBpbnNlcnRlZFxuICAgICAgICAgIC8vIGluIHRoZSBjb3JyZWN0IG9yZGVyIHdlIGluY3JlbWVudCB0b1JlZiB0byBhY2NvdW50IGZvciB0aGF0XG4gICAgICAgICAgdG9SZWYuY3VycmVudCA9IFBhdGgubmV4dCh0b1JlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0b1JlZi51bnJlZigpO1xuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFJlbW92ZSB0aGUgbm9kZXMgYXQgYSBzcGVjaWZpYyBsb2NhdGlvbiBpbiB0aGUgZG9jdW1lbnQuXHJcbiAgICovXG4gIHJlbW92ZU5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgaGFuZ2luZyA9IGZhbHNlLFxuICAgICAgICB2b2lkcyA9IGZhbHNlLFxuICAgICAgICBtb2RlID0gJ2xvd2VzdCdcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVwdGhzID0gRWRpdG9yLm5vZGVzKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIG1vZGUsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20oZGVwdGhzLCBfcmVmNCA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY0O1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0pO1xuXG4gICAgICBmb3IgKHZhciBwYXRoUmVmIG9mIHBhdGhSZWZzKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgdmFyIFtub2RlXSA9IEVkaXRvci5ub2RlKGVkaXRvciwgcGF0aCk7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdyZW1vdmVfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgbm9kZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogU2V0IG5ldyBwcm9wZXJ0aWVzIG9uIHRoZSBub2RlcyBhdCBhIGxvY2F0aW9uLlxyXG4gICAqL1xuICBzZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtYXRjaCxcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBjb21wYXJlLFxuICAgICAgICBtZXJnZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBoYW5naW5nID0gZmFsc2UsXG4gICAgICAgIG1vZGUgPSAnbG93ZXN0JyxcbiAgICAgICAgc3BsaXQgPSBmYWxzZSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nICYmIFJhbmdlLmlzUmFuZ2UoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnVuaGFuZ1JhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoc3BsaXQgJiYgUmFuZ2UuaXNSYW5nZShhdCkpIHtcbiAgICAgICAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKGF0KSAmJiBFZGl0b3IubGVhZihlZGl0b3IsIGF0LmFuY2hvcilbMF0udGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgLy8gSWYgdGhlIHJhbmdlIGlzIGNvbGxhcHNlZCBpbiBhIG5vbi1lbXB0eSBub2RlIGFuZCAnc3BsaXQnIGlzIHRydWUsIHRoZXJlJ3Mgbm90aGluZyB0b1xuICAgICAgICAgIC8vIHNldCB0aGF0IHdvbid0IGdldCBub3JtYWxpemVkIGF3YXlcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgdmFyIFtzdGFydCwgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIHNwbGl0TW9kZSA9IG1vZGUgPT09ICdsb3dlc3QnID8gJ2xvd2VzdCcgOiAnaGlnaGVzdCc7XG4gICAgICAgIHZhciBlbmRBdEVuZE9mTm9kZSA9IEVkaXRvci5pc0VuZChlZGl0b3IsIGVuZCwgZW5kLnBhdGgpO1xuICAgICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGVuZCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhZW5kQXRFbmRPZk5vZGVcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzdGFydEF0U3RhcnRPZk5vZGUgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIHN0YXJ0LCBzdGFydC5wYXRoKTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlOiBzcGxpdE1vZGUsXG4gICAgICAgICAgdm9pZHMsXG4gICAgICAgICAgYWx3YXlzOiAhc3RhcnRBdFN0YXJ0T2ZOb2RlXG4gICAgICAgIH0pO1xuICAgICAgICBhdCA9IHJhbmdlUmVmLnVucmVmKCk7XG5cbiAgICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCkge1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgYXQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghY29tcGFyZSkge1xuICAgICAgICBjb21wYXJlID0gKHByb3AsIG5vZGVQcm9wKSA9PiBwcm9wICE9PSBub2RlUHJvcDtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgW25vZGUsIHBhdGhdIG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIG1hdGNoLFxuICAgICAgICBtb2RlLFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpIHtcbiAgICAgICAgdmFyIHByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgdmFyIG5ld1Byb3BlcnRpZXMgPSB7fTsgLy8gWW91IGNhbid0IHNldCBwcm9wZXJ0aWVzIG9uIHRoZSBlZGl0b3Igbm9kZS5cblxuICAgICAgICBpZiAocGF0aC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBoYXNDaGFuZ2VzID0gZmFsc2U7XG5cbiAgICAgICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgICAgIGlmIChrID09PSAnY2hpbGRyZW4nIHx8IGsgPT09ICd0ZXh0Jykge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGNvbXBhcmUocHJvcHNba10sIG5vZGVba10pKSB7XG4gICAgICAgICAgICBoYXNDaGFuZ2VzID0gdHJ1ZTsgLy8gT21pdCBuZXcgcHJvcGVydGllcyBmcm9tIHRoZSBvbGQgcHJvcGVydGllcyBsaXN0XG5cbiAgICAgICAgICAgIGlmIChub2RlLmhhc093blByb3BlcnR5KGspKSBwcm9wZXJ0aWVzW2tdID0gbm9kZVtrXTsgLy8gT21pdCBwcm9wZXJ0aWVzIHRoYXQgaGF2ZSBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgbmV3IHByb3BlcnRpZXMgbGlzdFxuXG4gICAgICAgICAgICBpZiAobWVyZ2UpIHtcbiAgICAgICAgICAgICAgaWYgKHByb3BzW2tdICE9IG51bGwpIG5ld1Byb3BlcnRpZXNba10gPSBtZXJnZShub2RlW2tdLCBwcm9wc1trXSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBpZiAocHJvcHNba10gIT0gbnVsbCkgbmV3UHJvcGVydGllc1trXSA9IHByb3BzW2tdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChoYXNDaGFuZ2VzKSB7XG4gICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgIHR5cGU6ICdzZXRfbm9kZScsXG4gICAgICAgICAgICBwYXRoLFxuICAgICAgICAgICAgcHJvcGVydGllcyxcbiAgICAgICAgICAgIG5ld1Byb3BlcnRpZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNwbGl0IHRoZSBub2RlcyBhdCBhIHNwZWNpZmljIGxvY2F0aW9uLlxyXG4gICAqL1xuICBzcGxpdE5vZGVzKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgbW9kZSA9ICdsb3dlc3QnLFxuICAgICAgICB2b2lkcyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcbiAgICAgIHZhciB7XG4gICAgICAgIG1hdGNoLFxuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGhlaWdodCA9IDAsXG4gICAgICAgIGFsd2F5cyA9IGZhbHNlXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKG1hdGNoID09IG51bGwpIHtcbiAgICAgICAgbWF0Y2ggPSBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbik7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBhdCA9IGRlbGV0ZVJhbmdlKGVkaXRvciwgYXQpO1xuICAgICAgfSAvLyBJZiB0aGUgdGFyZ2V0IGlzIGEgcGF0aCwgdGhlIGRlZmF1bHQgaGVpZ2h0LXNraXBwaW5nIGFuZCBwb3NpdGlvblxuICAgICAgLy8gY291bnRlcnMgbmVlZCB0byBhY2NvdW50IGZvciB1cyBwb3RlbnRpYWxseSBzcGxpdHRpbmcgYXQgYSBub24tbGVhZi5cblxuXG4gICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIHZhciBwYXRoID0gYXQ7XG4gICAgICAgIHZhciBwb2ludCA9IEVkaXRvci5wb2ludChlZGl0b3IsIHBhdGgpO1xuICAgICAgICB2YXIgW3BhcmVudF0gPSBFZGl0b3IucGFyZW50KGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgbWF0Y2ggPSBuID0+IG4gPT09IHBhcmVudDtcblxuICAgICAgICBoZWlnaHQgPSBwb2ludC5wYXRoLmxlbmd0aCAtIHBhdGgubGVuZ3RoICsgMTtcbiAgICAgICAgYXQgPSBwb2ludDtcbiAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciBiZWZvcmVSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICBhZmZpbml0eTogJ2JhY2t3YXJkJ1xuICAgICAgfSk7XG4gICAgICB2YXIgYWZ0ZXJSZWY7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBbaGlnaGVzdF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgbW9kZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIWhpZ2hlc3QpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdm9pZE1hdGNoID0gRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgYXQsXG4gICAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgbnVkZ2UgPSAwO1xuXG4gICAgICAgIGlmICghdm9pZHMgJiYgdm9pZE1hdGNoKSB7XG4gICAgICAgICAgdmFyIFt2b2lkTm9kZSwgdm9pZFBhdGhdID0gdm9pZE1hdGNoO1xuXG4gICAgICAgICAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KHZvaWROb2RlKSAmJiBlZGl0b3IuaXNJbmxpbmUodm9pZE5vZGUpKSB7XG4gICAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCB2b2lkUGF0aCk7XG5cbiAgICAgICAgICAgIGlmICghYWZ0ZXIpIHtcbiAgICAgICAgICAgICAgdmFyIHRleHQgPSB7XG4gICAgICAgICAgICAgICAgdGV4dDogJydcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgdmFyIGFmdGVyUGF0aCA9IFBhdGgubmV4dCh2b2lkUGF0aCk7XG4gICAgICAgICAgICAgIFRyYW5zZm9ybXMuaW5zZXJ0Tm9kZXMoZWRpdG9yLCB0ZXh0LCB7XG4gICAgICAgICAgICAgICAgYXQ6IGFmdGVyUGF0aCxcbiAgICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgYWZ0ZXIgPSBFZGl0b3IucG9pbnQoZWRpdG9yLCBhZnRlclBhdGgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBhdCA9IGFmdGVyO1xuICAgICAgICAgICAgYWx3YXlzID0gdHJ1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgc2libGluZ0hlaWdodCA9IGF0LnBhdGgubGVuZ3RoIC0gdm9pZFBhdGgubGVuZ3RoO1xuICAgICAgICAgIGhlaWdodCA9IHNpYmxpbmdIZWlnaHQgKyAxO1xuICAgICAgICAgIGFsd2F5cyA9IHRydWU7XG4gICAgICAgIH1cblxuICAgICAgICBhZnRlclJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIGF0KTtcbiAgICAgICAgdmFyIGRlcHRoID0gYXQucGF0aC5sZW5ndGggLSBoZWlnaHQ7XG4gICAgICAgIHZhciBbLCBoaWdoZXN0UGF0aF0gPSBoaWdoZXN0O1xuICAgICAgICB2YXIgbG93ZXN0UGF0aCA9IGF0LnBhdGguc2xpY2UoMCwgZGVwdGgpO1xuICAgICAgICB2YXIgcG9zaXRpb24gPSBoZWlnaHQgPT09IDAgPyBhdC5vZmZzZXQgOiBhdC5wYXRoW2RlcHRoXSArIG51ZGdlO1xuXG4gICAgICAgIGZvciAodmFyIFtub2RlLCBfcGF0aDJdIG9mIEVkaXRvci5sZXZlbHMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IGxvd2VzdFBhdGgsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KSkge1xuICAgICAgICAgIHZhciBzcGxpdCA9IGZhbHNlO1xuXG4gICAgICAgICAgaWYgKF9wYXRoMi5sZW5ndGggPCBoaWdoZXN0UGF0aC5sZW5ndGggfHwgX3BhdGgyLmxlbmd0aCA9PT0gMCB8fCAhdm9pZHMgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgX3BvaW50ID0gYmVmb3JlUmVmLmN1cnJlbnQ7XG4gICAgICAgICAgdmFyIGlzRW5kID0gRWRpdG9yLmlzRW5kKGVkaXRvciwgX3BvaW50LCBfcGF0aDIpO1xuXG4gICAgICAgICAgaWYgKGFsd2F5cyB8fCAhYmVmb3JlUmVmIHx8ICFFZGl0b3IuaXNFZGdlKGVkaXRvciwgX3BvaW50LCBfcGF0aDIpKSB7XG4gICAgICAgICAgICBzcGxpdCA9IHRydWU7XG4gICAgICAgICAgICB2YXIgcHJvcGVydGllcyA9IE5vZGUuZXh0cmFjdFByb3BzKG5vZGUpO1xuICAgICAgICAgICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgICAgICAgdHlwZTogJ3NwbGl0X25vZGUnLFxuICAgICAgICAgICAgICBwYXRoOiBfcGF0aDIsXG4gICAgICAgICAgICAgIHBvc2l0aW9uLFxuICAgICAgICAgICAgICBwcm9wZXJ0aWVzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBwb3NpdGlvbiA9IF9wYXRoMltfcGF0aDIubGVuZ3RoIC0gMV0gKyAoc3BsaXQgfHwgaXNFbmQgPyAxIDogMCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIF9wb2ludDIgPSBhZnRlclJlZi5jdXJyZW50IHx8IEVkaXRvci5lbmQoZWRpdG9yLCBbXSk7XG5cbiAgICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIF9wb2ludDIpO1xuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICB2YXIgX2FmdGVyUmVmO1xuXG4gICAgICAgIGJlZm9yZVJlZi51bnJlZigpO1xuICAgICAgICAoX2FmdGVyUmVmID0gYWZ0ZXJSZWYpID09PSBudWxsIHx8IF9hZnRlclJlZiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2FmdGVyUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5zZXQgcHJvcGVydGllcyBvbiB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbi5cclxuICAgKi9cbiAgdW5zZXROb2RlcyhlZGl0b3IsIHByb3BzKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgICAgcHJvcHMgPSBbcHJvcHNdO1xuICAgIH1cblxuICAgIHZhciBvYmogPSB7fTtcblxuICAgIGZvciAodmFyIGtleSBvZiBwcm9wcykge1xuICAgICAgb2JqW2tleV0gPSBudWxsO1xuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0Tm9kZXMoZWRpdG9yLCBvYmosIG9wdGlvbnMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFVud3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBmcm9tIGEgcGFyZW50IG5vZGUsIHNwbGl0dGluZyB0aGUgcGFyZW50IGlmXHJcbiAgICogbmVjZXNzYXJ5IHRvIGVuc3VyZSB0aGF0IG9ubHkgdGhlIGNvbnRlbnQgaW4gdGhlIHJhbmdlIGlzIHVud3JhcHBlZC5cclxuICAgKi9cbiAgdW53cmFwTm9kZXMoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uLFxuICAgICAgICBtYXRjaFxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBtYXRjaCA9IFBhdGguaXNQYXRoKGF0KSA/IG1hdGNoUGF0aChlZGl0b3IsIGF0KSA6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKTtcbiAgICAgIH1cblxuICAgICAgaWYgKFBhdGguaXNQYXRoKGF0KSkge1xuICAgICAgICBhdCA9IEVkaXRvci5yYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJhbmdlUmVmID0gUmFuZ2UuaXNSYW5nZShhdCkgPyBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCkgOiBudWxsO1xuICAgICAgdmFyIG1hdGNoZXMgPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaCxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuICAgICAgdmFyIHBhdGhSZWZzID0gQXJyYXkuZnJvbShtYXRjaGVzLCBfcmVmNSA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY1O1xuICAgICAgICByZXR1cm4gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBwKTtcbiAgICAgIH0gLy8gdW53cmFwTm9kZSB3aWxsIGNhbGwgbGlmdE5vZGUgd2hpY2ggZG9lcyBub3Qgc3VwcG9ydCBzcGxpdHRpbmcgdGhlIG5vZGUgd2hlbiBuZXN0ZWQuXG4gICAgICAvLyBJZiB3ZSBkbyBub3QgcmV2ZXJzZSB0aGUgb3JkZXIgYW5kIGNhbGwgaXQgZnJvbSB0b3AgdG8gdGhlIGJvdHRvbSwgaXQgd2lsbCByZW1vdmUgYWxsIGJsb2Nrc1xuICAgICAgLy8gdGhhdCB3cmFwIHRhcmdldCBub2RlLiBTbyB3ZSByZXZlcnNlIHRoZSBvcmRlci5cbiAgICAgICkucmV2ZXJzZSgpO1xuXG4gICAgICB2YXIgX2xvb3AgPSBmdW5jdGlvbiBfbG9vcChwYXRoUmVmKSB7XG4gICAgICAgIHZhciBwYXRoID0gcGF0aFJlZi51bnJlZigpO1xuICAgICAgICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgcGF0aCk7XG5cbiAgICAgICAgaWYgKHNwbGl0ICYmIHJhbmdlUmVmKSB7XG4gICAgICAgICAgcmFuZ2UgPSBSYW5nZS5pbnRlcnNlY3Rpb24ocmFuZ2VSZWYuY3VycmVudCwgcmFuZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgVHJhbnNmb3Jtcy5saWZ0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgIG1hdGNoOiBuID0+IEVsZW1lbnQuaXNBbmNlc3Rvcihub2RlKSAmJiBub2RlLmNoaWxkcmVuLmluY2x1ZGVzKG4pLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfTtcblxuICAgICAgZm9yICh2YXIgcGF0aFJlZiBvZiBwYXRoUmVmcykge1xuICAgICAgICBfbG9vcChwYXRoUmVmKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJhbmdlUmVmKSB7XG4gICAgICAgIHJhbmdlUmVmLnVucmVmKCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogV3JhcCB0aGUgbm9kZXMgYXQgYSBsb2NhdGlvbiBpbiBhIG5ldyBjb250YWluZXIgbm9kZSwgc3BsaXR0aW5nIHRoZSBlZGdlc1xyXG4gICAqIG9mIHRoZSByYW5nZSBmaXJzdCB0byBlbnN1cmUgdGhhdCBvbmx5IHRoZSBjb250ZW50IGluIHRoZSByYW5nZSBpcyB3cmFwcGVkLlxyXG4gICAqL1xuICB3cmFwTm9kZXMoZWRpdG9yLCBlbGVtZW50KSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xuICAgIEVkaXRvci53aXRob3V0Tm9ybWFsaXppbmcoZWRpdG9yLCAoKSA9PiB7XG4gICAgICB2YXIge1xuICAgICAgICBtb2RlID0gJ2xvd2VzdCcsXG4gICAgICAgIHNwbGl0ID0gZmFsc2UsXG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgbWF0Y2gsXG4gICAgICAgIGF0ID0gZWRpdG9yLnNlbGVjdGlvblxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAobWF0Y2ggPT0gbnVsbCkge1xuICAgICAgICBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBtYXRjaFBhdGgoZWRpdG9yLCBhdCk7XG4gICAgICAgIH0gZWxzZSBpZiAoZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpKSB7XG4gICAgICAgICAgbWF0Y2ggPSBuID0+IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pIHx8IFRleHQuaXNUZXh0KG4pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG1hdGNoID0gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChzcGxpdCAmJiBSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICB2YXIgW3N0YXJ0LCBlbmRdID0gUmFuZ2UuZWRnZXMoYXQpO1xuICAgICAgICB2YXIgcmFuZ2VSZWYgPSBFZGl0b3IucmFuZ2VSZWYoZWRpdG9yLCBhdCwge1xuICAgICAgICAgIGFmZmluaXR5OiAnaW53YXJkJ1xuICAgICAgICB9KTtcbiAgICAgICAgVHJhbnNmb3Jtcy5zcGxpdE5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBlbmQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIFRyYW5zZm9ybXMuc3BsaXROb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogc3RhcnQsXG4gICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICAgIGF0ID0gcmFuZ2VSZWYudW5yZWYoKTtcblxuICAgICAgICBpZiAob3B0aW9ucy5hdCA9PSBudWxsKSB7XG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBhdCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHJvb3RzID0gQXJyYXkuZnJvbShFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaDogZWRpdG9yLmlzSW5saW5lKGVsZW1lbnQpID8gbiA9PiBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogbiA9PiBFZGl0b3IuaXNFZGl0b3IobiksXG4gICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSkpO1xuXG4gICAgICBmb3IgKHZhciBbLCByb290UGF0aF0gb2Ygcm9vdHMpIHtcbiAgICAgICAgdmFyIGEgPSBSYW5nZS5pc1JhbmdlKGF0KSA/IFJhbmdlLmludGVyc2VjdGlvbihhdCwgRWRpdG9yLnJhbmdlKGVkaXRvciwgcm9vdFBhdGgpKSA6IGF0O1xuXG4gICAgICAgIGlmICghYSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIG1hdGNoZXMgPSBBcnJheS5mcm9tKEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYSxcbiAgICAgICAgICBtYXRjaCxcbiAgICAgICAgICBtb2RlLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pKTtcblxuICAgICAgICBpZiAobWF0Y2hlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgdmFyIF9yZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgW2ZpcnN0XSA9IG1hdGNoZXM7XG4gICAgICAgICAgICB2YXIgbGFzdCA9IG1hdGNoZXNbbWF0Y2hlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgIHZhciBbLCBmaXJzdFBhdGhdID0gZmlyc3Q7XG4gICAgICAgICAgICB2YXIgWywgbGFzdFBhdGhdID0gbGFzdDtcblxuICAgICAgICAgICAgaWYgKGZpcnN0UGF0aC5sZW5ndGggPT09IDAgJiYgbGFzdFBhdGgubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgIC8vIGlmIHRoZXJlJ3Mgbm8gbWF0Y2hpbmcgcGFyZW50IC0gdXN1YWxseSBtZWFucyB0aGUgbm9kZSBpcyBhbiBlZGl0b3IgLSBkb24ndCBkbyBhbnl0aGluZ1xuICAgICAgICAgICAgICByZXR1cm4gXCJjb250aW51ZVwiO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY29tbW9uUGF0aCA9IFBhdGguZXF1YWxzKGZpcnN0UGF0aCwgbGFzdFBhdGgpID8gUGF0aC5wYXJlbnQoZmlyc3RQYXRoKSA6IFBhdGguY29tbW9uKGZpcnN0UGF0aCwgbGFzdFBhdGgpO1xuICAgICAgICAgICAgdmFyIHJhbmdlID0gRWRpdG9yLnJhbmdlKGVkaXRvciwgZmlyc3RQYXRoLCBsYXN0UGF0aCk7XG4gICAgICAgICAgICB2YXIgY29tbW9uTm9kZUVudHJ5ID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBjb21tb25QYXRoKTtcbiAgICAgICAgICAgIHZhciBbY29tbW9uTm9kZV0gPSBjb21tb25Ob2RlRW50cnk7XG4gICAgICAgICAgICB2YXIgZGVwdGggPSBjb21tb25QYXRoLmxlbmd0aCArIDE7XG4gICAgICAgICAgICB2YXIgd3JhcHBlclBhdGggPSBQYXRoLm5leHQobGFzdFBhdGguc2xpY2UoMCwgZGVwdGgpKTtcblxuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBfb2JqZWN0U3ByZWFkJDIoX29iamVjdFNwcmVhZCQyKHt9LCBlbGVtZW50KSwge30sIHtcbiAgICAgICAgICAgICAgY2hpbGRyZW46IFtdXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHdyYXBwZXIsIHtcbiAgICAgICAgICAgICAgYXQ6IHdyYXBwZXJQYXRoLFxuICAgICAgICAgICAgICB2b2lkc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBUcmFuc2Zvcm1zLm1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICAgICAgYXQ6IHJhbmdlLFxuICAgICAgICAgICAgICBtYXRjaDogbiA9PiBFbGVtZW50LmlzQW5jZXN0b3IoY29tbW9uTm9kZSkgJiYgY29tbW9uTm9kZS5jaGlsZHJlbi5pbmNsdWRlcyhuKSxcbiAgICAgICAgICAgICAgdG86IHdyYXBwZXJQYXRoLmNvbmNhdCgwKSxcbiAgICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0oKTtcblxuICAgICAgICAgIGlmIChfcmV0ID09PSBcImNvbnRpbnVlXCIpIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxufTtcblxudmFyIGhhc1NpbmdsZUNoaWxkTmVzdCA9IChlZGl0b3IsIG5vZGUpID0+IHtcbiAgaWYgKEVsZW1lbnQuaXNFbGVtZW50KG5vZGUpKSB7XG4gICAgdmFyIGVsZW1lbnQgPSBub2RlO1xuXG4gICAgaWYgKEVkaXRvci5pc1ZvaWQoZWRpdG9yLCBub2RlKSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIGlmIChlbGVtZW50LmNoaWxkcmVuLmxlbmd0aCA9PT0gMSkge1xuICAgICAgcmV0dXJuIGhhc1NpbmdsZUNoaWxkTmVzdChlZGl0b3IsIGVsZW1lbnQuY2hpbGRyZW5bMF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICB9IGVsc2UgaWYgKEVkaXRvci5pc0VkaXRvcihub2RlKSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcbi8qKlxyXG4gKiBDb252ZXJ0IGEgcmFuZ2UgaW50byBhIHBvaW50IGJ5IGRlbGV0aW5nIGl0J3MgY29udGVudC5cclxuICovXG5cblxudmFyIGRlbGV0ZVJhbmdlID0gKGVkaXRvciwgcmFuZ2UpID0+IHtcbiAgaWYgKFJhbmdlLmlzQ29sbGFwc2VkKHJhbmdlKSkge1xuICAgIHJldHVybiByYW5nZS5hbmNob3I7XG4gIH0gZWxzZSB7XG4gICAgdmFyIFssIGVuZF0gPSBSYW5nZS5lZGdlcyhyYW5nZSk7XG4gICAgdmFyIHBvaW50UmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgIGF0OiByYW5nZVxuICAgIH0pO1xuICAgIHJldHVybiBwb2ludFJlZi51bnJlZigpO1xuICB9XG59O1xuXG52YXIgbWF0Y2hQYXRoID0gKGVkaXRvciwgcGF0aCkgPT4ge1xuICB2YXIgW25vZGVdID0gRWRpdG9yLm5vZGUoZWRpdG9yLCBwYXRoKTtcbiAgcmV0dXJuIG4gPT4gbiA9PT0gbm9kZTtcbn07XG5cbmZ1bmN0aW9uIG93bktleXMkMShvYmplY3QsIGVudW1lcmFibGVPbmx5KSB7IHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTsgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHsgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7IGlmIChlbnVtZXJhYmxlT25seSkgeyBzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoZnVuY3Rpb24gKHN5bSkgeyByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTsgfSk7IH0ga2V5cy5wdXNoLmFwcGx5KGtleXMsIHN5bWJvbHMpOyB9IHJldHVybiBrZXlzOyB9XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQkMSh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzJDEoT2JqZWN0KHNvdXJjZSksIHRydWUpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBfZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNvdXJjZVtrZXldKTsgfSk7IH0gZWxzZSBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMpIHsgT2JqZWN0LmRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhzb3VyY2UpKTsgfSBlbHNlIHsgb3duS2V5cyQxKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7IH0pOyB9IH0gcmV0dXJuIHRhcmdldDsgfVxuXG52YXIgU2VsZWN0aW9uVHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogQ29sbGFwc2UgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgY29sbGFwc2UoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBlZGdlID0gJ2FuY2hvcidcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfSBlbHNlIGlmIChlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBzZWxlY3Rpb24uYW5jaG9yKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdmb2N1cycpIHtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc2VsZWN0aW9uLmZvY3VzKTtcbiAgICB9IGVsc2UgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIHZhciBbc3RhcnRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgc3RhcnQpO1xuICAgIH0gZWxzZSBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIHZhciBbLCBlbmRdID0gUmFuZ2UuZWRnZXMoc2VsZWN0aW9uKTtcbiAgICAgIFRyYW5zZm9ybXMuc2VsZWN0KGVkaXRvciwgZW5kKTtcbiAgICB9XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogVW5zZXQgdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgZGVzZWxlY3QoZWRpdG9yKSB7XG4gICAgdmFyIHtcbiAgICAgIHNlbGVjdGlvblxuICAgIH0gPSBlZGl0b3I7XG5cbiAgICBpZiAoc2VsZWN0aW9uKSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgICAgbmV3UHJvcGVydGllczogbnVsbFxuICAgICAgfSk7XG4gICAgfVxuICB9LFxuXG4gIC8qKlxyXG4gICAqIE1vdmUgdGhlIHNlbGVjdGlvbidzIHBvaW50IGZvcndhcmQgb3IgYmFja3dhcmQuXHJcbiAgICovXG4gIG1vdmUoZWRpdG9yKSB7XG4gICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHZhciB7XG4gICAgICBzZWxlY3Rpb25cbiAgICB9ID0gZWRpdG9yO1xuICAgIHZhciB7XG4gICAgICBkaXN0YW5jZSA9IDEsXG4gICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgICByZXZlcnNlID0gZmFsc2VcbiAgICB9ID0gb3B0aW9ucztcbiAgICB2YXIge1xuICAgICAgZWRnZSA9IG51bGxcbiAgICB9ID0gb3B0aW9ucztcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdzdGFydCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnZm9jdXMnIDogJ2FuY2hvcic7XG4gICAgfVxuXG4gICAgaWYgKGVkZ2UgPT09ICdlbmQnKSB7XG4gICAgICBlZGdlID0gUmFuZ2UuaXNCYWNrd2FyZChzZWxlY3Rpb24pID8gJ2FuY2hvcicgOiAnZm9jdXMnO1xuICAgIH1cblxuICAgIHZhciB7XG4gICAgICBhbmNob3IsXG4gICAgICBmb2N1c1xuICAgIH0gPSBzZWxlY3Rpb247XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBkaXN0YW5jZSxcbiAgICAgIHVuaXRcbiAgICB9O1xuICAgIHZhciBwcm9wcyA9IHt9O1xuXG4gICAgaWYgKGVkZ2UgPT0gbnVsbCB8fCBlZGdlID09PSAnYW5jaG9yJykge1xuICAgICAgdmFyIHBvaW50ID0gcmV2ZXJzZSA/IEVkaXRvci5iZWZvcmUoZWRpdG9yLCBhbmNob3IsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgYW5jaG9yLCBvcHRzKTtcblxuICAgICAgaWYgKHBvaW50KSB7XG4gICAgICAgIHByb3BzLmFuY2hvciA9IHBvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChlZGdlID09IG51bGwgfHwgZWRnZSA9PT0gJ2ZvY3VzJykge1xuICAgICAgdmFyIF9wb2ludCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgZm9jdXMsIG9wdHMpIDogRWRpdG9yLmFmdGVyKGVkaXRvciwgZm9jdXMsIG9wdHMpO1xuXG4gICAgICBpZiAoX3BvaW50KSB7XG4gICAgICAgIHByb3BzLmZvY3VzID0gX3BvaW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgc2VsZWN0aW9uIHRvIGEgbmV3IHZhbHVlLlxyXG4gICAqL1xuICBzZWxlY3QoZWRpdG9yLCB0YXJnZXQpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB0YXJnZXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCB0YXJnZXQpO1xuXG4gICAgaWYgKHNlbGVjdGlvbikge1xuICAgICAgVHJhbnNmb3Jtcy5zZXRTZWxlY3Rpb24oZWRpdG9yLCB0YXJnZXQpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICghUmFuZ2UuaXNSYW5nZSh0YXJnZXQpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJXaGVuIHNldHRpbmcgdGhlIHNlbGVjdGlvbiBhbmQgdGhlIGN1cnJlbnQgc2VsZWN0aW9uIGlzIGBudWxsYCB5b3UgbXVzdCBwcm92aWRlIGF0IGxlYXN0IGFuIGBhbmNob3JgIGFuZCBgZm9jdXNgLCBidXQgeW91IHBhc3NlZDogXCIuY29uY2F0KFNjcnViYmVyLnN0cmluZ2lmeSh0YXJnZXQpKSk7XG4gICAgfVxuXG4gICAgZWRpdG9yLmFwcGx5KHtcbiAgICAgIHR5cGU6ICdzZXRfc2VsZWN0aW9uJyxcbiAgICAgIHByb3BlcnRpZXM6IHNlbGVjdGlvbixcbiAgICAgIG5ld1Byb3BlcnRpZXM6IHRhcmdldFxuICAgIH0pO1xuICB9LFxuXG4gIC8qKlxyXG4gICAqIFNldCBuZXcgcHJvcGVydGllcyBvbiBvbmUgb2YgdGhlIHNlbGVjdGlvbidzIHBvaW50cy5cclxuICAgKi9cbiAgc2V0UG9pbnQoZWRpdG9yLCBwcm9wcykge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIge1xuICAgICAgZWRnZSA9ICdib3RoJ1xuICAgIH0gPSBvcHRpb25zO1xuXG4gICAgaWYgKCFzZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ3N0YXJ0Jykge1xuICAgICAgZWRnZSA9IFJhbmdlLmlzQmFja3dhcmQoc2VsZWN0aW9uKSA/ICdmb2N1cycgOiAnYW5jaG9yJztcbiAgICB9XG5cbiAgICBpZiAoZWRnZSA9PT0gJ2VuZCcpIHtcbiAgICAgIGVkZ2UgPSBSYW5nZS5pc0JhY2t3YXJkKHNlbGVjdGlvbikgPyAnYW5jaG9yJyA6ICdmb2N1cyc7XG4gICAgfVxuXG4gICAgdmFyIHtcbiAgICAgIGFuY2hvcixcbiAgICAgIGZvY3VzXG4gICAgfSA9IHNlbGVjdGlvbjtcbiAgICB2YXIgcG9pbnQgPSBlZGdlID09PSAnYW5jaG9yJyA/IGFuY2hvciA6IGZvY3VzO1xuICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgW2VkZ2UgPT09ICdhbmNob3InID8gJ2FuY2hvcicgOiAnZm9jdXMnXTogX29iamVjdFNwcmVhZCQxKF9vYmplY3RTcHJlYWQkMSh7fSwgcG9pbnQpLCBwcm9wcylcbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBTZXQgbmV3IHByb3BlcnRpZXMgb24gdGhlIHNlbGVjdGlvbi5cclxuICAgKi9cbiAgc2V0U2VsZWN0aW9uKGVkaXRvciwgcHJvcHMpIHtcbiAgICB2YXIge1xuICAgICAgc2VsZWN0aW9uXG4gICAgfSA9IGVkaXRvcjtcbiAgICB2YXIgb2xkUHJvcHMgPSB7fTtcbiAgICB2YXIgbmV3UHJvcHMgPSB7fTtcblxuICAgIGlmICghc2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZm9yICh2YXIgayBpbiBwcm9wcykge1xuICAgICAgaWYgKGsgPT09ICdhbmNob3InICYmIHByb3BzLmFuY2hvciAhPSBudWxsICYmICFQb2ludC5lcXVhbHMocHJvcHMuYW5jaG9yLCBzZWxlY3Rpb24uYW5jaG9yKSB8fCBrID09PSAnZm9jdXMnICYmIHByb3BzLmZvY3VzICE9IG51bGwgJiYgIVBvaW50LmVxdWFscyhwcm9wcy5mb2N1cywgc2VsZWN0aW9uLmZvY3VzKSB8fCBrICE9PSAnYW5jaG9yJyAmJiBrICE9PSAnZm9jdXMnICYmIHByb3BzW2tdICE9PSBzZWxlY3Rpb25ba10pIHtcbiAgICAgICAgb2xkUHJvcHNba10gPSBzZWxlY3Rpb25ba107XG4gICAgICAgIG5ld1Byb3BzW2tdID0gcHJvcHNba107XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKE9iamVjdC5rZXlzKG9sZFByb3BzKS5sZW5ndGggPiAwKSB7XG4gICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICB0eXBlOiAnc2V0X3NlbGVjdGlvbicsXG4gICAgICAgIHByb3BlcnRpZXM6IG9sZFByb3BzLFxuICAgICAgICBuZXdQcm9wZXJ0aWVzOiBuZXdQcm9wc1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbn07XG5cbnZhciBUZXh0VHJhbnNmb3JtcyA9IHtcbiAgLyoqXHJcbiAgICogRGVsZXRlIGNvbnRlbnQgaW4gdGhlIGVkaXRvci5cclxuICAgKi9cbiAgZGVsZXRlKGVkaXRvcikge1xuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBFZGl0b3Iud2l0aG91dE5vcm1hbGl6aW5nKGVkaXRvciwgKCkgPT4ge1xuICAgICAgdmFyIHtcbiAgICAgICAgcmV2ZXJzZSA9IGZhbHNlLFxuICAgICAgICB1bml0ID0gJ2NoYXJhY3RlcicsXG4gICAgICAgIGRpc3RhbmNlID0gMSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb24sXG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgaXNDb2xsYXBzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKFJhbmdlLmlzUmFuZ2UoYXQpICYmIFJhbmdlLmlzQ29sbGFwc2VkKGF0KSkge1xuICAgICAgICBpc0NvbGxhcHNlZCA9IHRydWU7XG4gICAgICAgIGF0ID0gYXQuYW5jaG9yO1xuICAgICAgfVxuXG4gICAgICBpZiAoUG9pbnQuaXNQb2ludChhdCkpIHtcbiAgICAgICAgdmFyIGZ1cnRoZXN0Vm9pZCA9IEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgIGF0LFxuICAgICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoIXZvaWRzICYmIGZ1cnRoZXN0Vm9pZCkge1xuICAgICAgICAgIHZhciBbLCB2b2lkUGF0aF0gPSBmdXJ0aGVzdFZvaWQ7XG4gICAgICAgICAgYXQgPSB2b2lkUGF0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IHtcbiAgICAgICAgICAgIHVuaXQsXG4gICAgICAgICAgICBkaXN0YW5jZVxuICAgICAgICAgIH07XG4gICAgICAgICAgdmFyIHRhcmdldCA9IHJldmVyc2UgPyBFZGl0b3IuYmVmb3JlKGVkaXRvciwgYXQsIG9wdHMpIHx8IEVkaXRvci5zdGFydChlZGl0b3IsIFtdKSA6IEVkaXRvci5hZnRlcihlZGl0b3IsIGF0LCBvcHRzKSB8fCBFZGl0b3IuZW5kKGVkaXRvciwgW10pO1xuICAgICAgICAgIGF0ID0ge1xuICAgICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICAgIGZvY3VzOiB0YXJnZXRcbiAgICAgICAgICB9O1xuICAgICAgICAgIGhhbmdpbmcgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgVHJhbnNmb3Jtcy5yZW1vdmVOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdCxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKCFoYW5naW5nKSB7XG4gICAgICAgIHZhciBbLCBfZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcbiAgICAgICAgdmFyIGVuZE9mRG9jID0gRWRpdG9yLmVuZChlZGl0b3IsIFtdKTtcblxuICAgICAgICBpZiAoIVBvaW50LmVxdWFscyhfZW5kLCBlbmRPZkRvYykpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0LCB7XG4gICAgICAgICAgICB2b2lkc1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBbc3RhcnQsIGVuZF0gPSBSYW5nZS5lZGdlcyhhdCk7XG4gICAgICB2YXIgc3RhcnRCbG9jayA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgYXQ6IHN0YXJ0LFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgZW5kQmxvY2sgPSBFZGl0b3IuYWJvdmUoZWRpdG9yLCB7XG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBpc0Fjcm9zc0Jsb2NrcyA9IHN0YXJ0QmxvY2sgJiYgZW5kQmxvY2sgJiYgIVBhdGguZXF1YWxzKHN0YXJ0QmxvY2tbMV0sIGVuZEJsb2NrWzFdKTtcbiAgICAgIHZhciBpc1NpbmdsZVRleHQgPSBQYXRoLmVxdWFscyhzdGFydC5wYXRoLCBlbmQucGF0aCk7XG4gICAgICB2YXIgc3RhcnRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBzdGFydCxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnXG4gICAgICB9KTtcbiAgICAgIHZhciBlbmRWb2lkID0gdm9pZHMgPyBudWxsIDogRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0OiBlbmQsXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0J1xuICAgICAgfSk7IC8vIElmIHRoZSBzdGFydCBvciBlbmQgcG9pbnRzIGFyZSBpbnNpZGUgYW4gaW5saW5lIHZvaWQsIG51ZGdlIHRoZW0gb3V0LlxuXG4gICAgICBpZiAoc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBiZWZvcmUgPSBFZGl0b3IuYmVmb3JlKGVkaXRvciwgc3RhcnQpO1xuXG4gICAgICAgIGlmIChiZWZvcmUgJiYgc3RhcnRCbG9jayAmJiBQYXRoLmlzQW5jZXN0b3Ioc3RhcnRCbG9ja1sxXSwgYmVmb3JlLnBhdGgpKSB7XG4gICAgICAgICAgc3RhcnQgPSBiZWZvcmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGVuZFZvaWQpIHtcbiAgICAgICAgdmFyIGFmdGVyID0gRWRpdG9yLmFmdGVyKGVkaXRvciwgZW5kKTtcblxuICAgICAgICBpZiAoYWZ0ZXIgJiYgZW5kQmxvY2sgJiYgUGF0aC5pc0FuY2VzdG9yKGVuZEJsb2NrWzFdLCBhZnRlci5wYXRoKSkge1xuICAgICAgICAgIGVuZCA9IGFmdGVyO1xuICAgICAgICB9XG4gICAgICB9IC8vIEdldCB0aGUgaGlnaGVzdCBub2RlcyB0aGF0IGFyZSBjb21wbGV0ZWx5IGluc2lkZSB0aGUgcmFuZ2UsIGFzIHdlbGwgYXNcbiAgICAgIC8vIHRoZSBzdGFydCBhbmQgZW5kIG5vZGVzLlxuXG5cbiAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICB2YXIgbGFzdFBhdGg7XG5cbiAgICAgIGZvciAodmFyIGVudHJ5IG9mIEVkaXRvci5ub2RlcyhlZGl0b3IsIHtcbiAgICAgICAgYXQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KSkge1xuICAgICAgICB2YXIgW25vZGUsIHBhdGhdID0gZW50cnk7XG5cbiAgICAgICAgaWYgKGxhc3RQYXRoICYmIFBhdGguY29tcGFyZShwYXRoLCBsYXN0UGF0aCkgPT09IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLmlzVm9pZChlZGl0b3IsIG5vZGUpIHx8ICFQYXRoLmlzQ29tbW9uKHBhdGgsIHN0YXJ0LnBhdGgpICYmICFQYXRoLmlzQ29tbW9uKHBhdGgsIGVuZC5wYXRoKSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgICAgbGFzdFBhdGggPSBwYXRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBwYXRoUmVmcyA9IEFycmF5LmZyb20obWF0Y2hlcywgX3JlZiA9PiB7XG4gICAgICAgIHZhciBbLCBwXSA9IF9yZWY7XG4gICAgICAgIHJldHVybiBFZGl0b3IucGF0aFJlZihlZGl0b3IsIHApO1xuICAgICAgfSk7XG4gICAgICB2YXIgc3RhcnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBzdGFydCk7XG4gICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgIHZhciByZW1vdmVkVGV4dCA9ICcnO1xuXG4gICAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiAhc3RhcnRWb2lkKSB7XG4gICAgICAgIHZhciBfcG9pbnQgPSBzdGFydFJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgW19ub2RlXSA9IEVkaXRvci5sZWFmKGVkaXRvciwgX3BvaW50KTtcbiAgICAgICAgdmFyIHtcbiAgICAgICAgICBwYXRoOiBfcGF0aFxuICAgICAgICB9ID0gX3BvaW50O1xuICAgICAgICB2YXIge1xuICAgICAgICAgIG9mZnNldFxuICAgICAgICB9ID0gc3RhcnQ7XG5cbiAgICAgICAgdmFyIHRleHQgPSBfbm9kZS50ZXh0LnNsaWNlKG9mZnNldCk7XG5cbiAgICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkge1xuICAgICAgICAgIGVkaXRvci5hcHBseSh7XG4gICAgICAgICAgICB0eXBlOiAncmVtb3ZlX3RleHQnLFxuICAgICAgICAgICAgcGF0aDogX3BhdGgsXG4gICAgICAgICAgICBvZmZzZXQsXG4gICAgICAgICAgICB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVtb3ZlZFRleHQgPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIHBhdGhSZWYgb2YgcGF0aFJlZnMpIHtcbiAgICAgICAgdmFyIF9wYXRoMiA9IHBhdGhSZWYudW5yZWYoKTtcblxuICAgICAgICBUcmFuc2Zvcm1zLnJlbW92ZU5vZGVzKGVkaXRvciwge1xuICAgICAgICAgIGF0OiBfcGF0aDIsXG4gICAgICAgICAgdm9pZHNcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGlmICghZW5kVm9pZCkge1xuICAgICAgICB2YXIgX3BvaW50MiA9IGVuZFJlZi5jdXJyZW50O1xuICAgICAgICB2YXIgW19ub2RlMl0gPSBFZGl0b3IubGVhZihlZGl0b3IsIF9wb2ludDIpO1xuICAgICAgICB2YXIge1xuICAgICAgICAgIHBhdGg6IF9wYXRoM1xuICAgICAgICB9ID0gX3BvaW50MjtcblxuICAgICAgICB2YXIgX29mZnNldCA9IGlzU2luZ2xlVGV4dCA/IHN0YXJ0Lm9mZnNldCA6IDA7XG5cbiAgICAgICAgdmFyIF90ZXh0ID0gX25vZGUyLnRleHQuc2xpY2UoX29mZnNldCwgZW5kLm9mZnNldCk7XG5cbiAgICAgICAgaWYgKF90ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBlZGl0b3IuYXBwbHkoe1xuICAgICAgICAgICAgdHlwZTogJ3JlbW92ZV90ZXh0JyxcbiAgICAgICAgICAgIHBhdGg6IF9wYXRoMyxcbiAgICAgICAgICAgIG9mZnNldDogX29mZnNldCxcbiAgICAgICAgICAgIHRleHQ6IF90ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgICAgcmVtb3ZlZFRleHQgPSBfdGV4dDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoIWlzU2luZ2xlVGV4dCAmJiBpc0Fjcm9zc0Jsb2NrcyAmJiBlbmRSZWYuY3VycmVudCAmJiBzdGFydFJlZi5jdXJyZW50KSB7XG4gICAgICAgIFRyYW5zZm9ybXMubWVyZ2VOb2RlcyhlZGl0b3IsIHtcbiAgICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICAgICAgaGFuZ2luZzogdHJ1ZSxcbiAgICAgICAgICB2b2lkc1xuICAgICAgICB9KTtcbiAgICAgIH0gLy8gRm9yIFRoYWkgc2NyaXB0LCBkZWxldGluZyBOIGNoYXJhY3RlcihzKSBiYWNrd2FyZCBzaG91bGQgZGVsZXRlXG4gICAgICAvLyBOIGNvZGUgcG9pbnQocykgaW5zdGVhZCBvZiBhbiBlbnRpcmUgZ3JhcGhlbWUgY2x1c3Rlci5cbiAgICAgIC8vIFRoZXJlZm9yZSwgdGhlIHJlbWFpbmluZyBjb2RlIHBvaW50cyBzaG91bGQgYmUgaW5zZXJ0ZWQgYmFjay5cblxuXG4gICAgICBpZiAoaXNDb2xsYXBzZWQgJiYgcmV2ZXJzZSAmJiB1bml0ID09PSAnY2hhcmFjdGVyJyAmJiByZW1vdmVkVGV4dC5sZW5ndGggPiAxICYmIHJlbW92ZWRUZXh0Lm1hdGNoKC9bXFx1MEUwMC1cXHUwRTdGXSsvKSkge1xuICAgICAgICBUcmFuc2Zvcm1zLmluc2VydFRleHQoZWRpdG9yLCByZW1vdmVkVGV4dC5zbGljZSgwLCByZW1vdmVkVGV4dC5sZW5ndGggLSBkaXN0YW5jZSkpO1xuICAgICAgfVxuXG4gICAgICB2YXIgc3RhcnRVbnJlZiA9IHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICB2YXIgZW5kVW5yZWYgPSBlbmRSZWYudW5yZWYoKTtcbiAgICAgIHZhciBwb2ludCA9IHJldmVyc2UgPyBzdGFydFVucmVmIHx8IGVuZFVucmVmIDogZW5kVW5yZWYgfHwgc3RhcnRVbnJlZjtcblxuICAgICAgaWYgKG9wdGlvbnMuYXQgPT0gbnVsbCAmJiBwb2ludCkge1xuICAgICAgICBUcmFuc2Zvcm1zLnNlbGVjdChlZGl0b3IsIHBvaW50KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSxcblxuICAvKipcclxuICAgKiBJbnNlcnQgYSBmcmFnbWVudCBhdCBhIHNwZWNpZmljIGxvY2F0aW9uIGluIHRoZSBlZGl0b3IuXHJcbiAgICovXG4gIGluc2VydEZyYWdtZW50KGVkaXRvciwgZnJhZ21lbnQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIGhhbmdpbmcgPSBmYWxzZSxcbiAgICAgICAgdm9pZHMgPSBmYWxzZVxuICAgICAgfSA9IG9wdGlvbnM7XG4gICAgICB2YXIge1xuICAgICAgICBhdCA9IGVkaXRvci5zZWxlY3Rpb25cbiAgICAgIH0gPSBvcHRpb25zO1xuXG4gICAgICBpZiAoIWZyYWdtZW50Lmxlbmd0aCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICghYXQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoIWhhbmdpbmcpIHtcbiAgICAgICAgICBhdCA9IEVkaXRvci51bmhhbmdSYW5nZShlZGl0b3IsIGF0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChSYW5nZS5pc0NvbGxhcHNlZChhdCkpIHtcbiAgICAgICAgICBhdCA9IGF0LmFuY2hvcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgWywgZW5kXSA9IFJhbmdlLmVkZ2VzKGF0KTtcblxuICAgICAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgICAgICBhdDogZW5kXG4gICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICB2YXIgcG9pbnRSZWYgPSBFZGl0b3IucG9pbnRSZWYoZWRpdG9yLCBlbmQpO1xuICAgICAgICAgIFRyYW5zZm9ybXMuZGVsZXRlKGVkaXRvciwge1xuICAgICAgICAgICAgYXRcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBhdCA9IHBvaW50UmVmLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoUGF0aC5pc1BhdGgoYXQpKSB7XG4gICAgICAgIGF0ID0gRWRpdG9yLnN0YXJ0KGVkaXRvciwgYXQpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICBhdFxuICAgICAgfSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSAvLyBJZiB0aGUgaW5zZXJ0IHBvaW50IGlzIGF0IHRoZSBlZGdlIG9mIGFuIGlubGluZSBub2RlLCBtb3ZlIGl0IG91dHNpZGVcbiAgICAgIC8vIGluc3RlYWQgc2luY2UgaXQgd2lsbCBuZWVkIHRvIGJlIHNwbGl0IG90aGVyd2lzZS5cblxuXG4gICAgICB2YXIgaW5saW5lRWxlbWVudE1hdGNoID0gRWRpdG9yLmFib3ZlKGVkaXRvciwge1xuICAgICAgICBhdCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaW5saW5lRWxlbWVudE1hdGNoKSB7XG4gICAgICAgIHZhciBbLCBfaW5saW5lUGF0aF0gPSBpbmxpbmVFbGVtZW50TWF0Y2g7XG5cbiAgICAgICAgaWYgKEVkaXRvci5pc0VuZChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgICB2YXIgYWZ0ZXIgPSBFZGl0b3IuYWZ0ZXIoZWRpdG9yLCBfaW5saW5lUGF0aCk7XG4gICAgICAgICAgYXQgPSBhZnRlcjtcbiAgICAgICAgfSBlbHNlIGlmIChFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBfaW5saW5lUGF0aCkpIHtcbiAgICAgICAgICB2YXIgYmVmb3JlID0gRWRpdG9yLmJlZm9yZShlZGl0b3IsIF9pbmxpbmVQYXRoKTtcbiAgICAgICAgICBhdCA9IGJlZm9yZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgYmxvY2tNYXRjaCA9IEVkaXRvci5hYm92ZShlZGl0b3IsIHtcbiAgICAgICAgbWF0Y2g6IG4gPT4gRWRpdG9yLmlzQmxvY2soZWRpdG9yLCBuKSxcbiAgICAgICAgYXQsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBbLCBibG9ja1BhdGhdID0gYmxvY2tNYXRjaDtcbiAgICAgIHZhciBpc0Jsb2NrU3RhcnQgPSBFZGl0b3IuaXNTdGFydChlZGl0b3IsIGF0LCBibG9ja1BhdGgpO1xuICAgICAgdmFyIGlzQmxvY2tFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgYmxvY2tQYXRoKTtcbiAgICAgIHZhciBpc0Jsb2NrRW1wdHkgPSBpc0Jsb2NrU3RhcnQgJiYgaXNCbG9ja0VuZDtcbiAgICAgIHZhciBtZXJnZVN0YXJ0ID0gIWlzQmxvY2tTdGFydCB8fCBpc0Jsb2NrU3RhcnQgJiYgaXNCbG9ja0VuZDtcbiAgICAgIHZhciBtZXJnZUVuZCA9ICFpc0Jsb2NrRW5kO1xuICAgICAgdmFyIFssIGZpcnN0UGF0aF0gPSBOb2RlLmZpcnN0KHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCBbXSk7XG4gICAgICB2YXIgWywgbGFzdFBhdGhdID0gTm9kZS5sYXN0KHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCBbXSk7XG4gICAgICB2YXIgbWF0Y2hlcyA9IFtdO1xuXG4gICAgICB2YXIgbWF0Y2hlciA9IF9yZWYyID0+IHtcbiAgICAgICAgdmFyIFtuLCBwXSA9IF9yZWYyO1xuICAgICAgICB2YXIgaXNSb290ID0gcC5sZW5ndGggPT09IDA7XG5cbiAgICAgICAgaWYgKGlzUm9vdCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0Jsb2NrRW1wdHkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChtZXJnZVN0YXJ0ICYmIFBhdGguaXNBbmNlc3RvcihwLCBmaXJzdFBhdGgpICYmIEVsZW1lbnQuaXNFbGVtZW50KG4pICYmICFlZGl0b3IuaXNWb2lkKG4pICYmICFlZGl0b3IuaXNJbmxpbmUobikpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAobWVyZ2VFbmQgJiYgUGF0aC5pc0FuY2VzdG9yKHAsIGxhc3RQYXRoKSAmJiBFbGVtZW50LmlzRWxlbWVudChuKSAmJiAhZWRpdG9yLmlzVm9pZChuKSAmJiAhZWRpdG9yLmlzSW5saW5lKG4pKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBlbnRyeSBvZiBOb2RlLm5vZGVzKHtcbiAgICAgICAgY2hpbGRyZW46IGZyYWdtZW50XG4gICAgICB9LCB7XG4gICAgICAgIHBhc3M6IG1hdGNoZXJcbiAgICAgIH0pKSB7XG4gICAgICAgIGlmIChtYXRjaGVyKGVudHJ5KSkge1xuICAgICAgICAgIG1hdGNoZXMucHVzaChlbnRyeSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHN0YXJ0cyA9IFtdO1xuICAgICAgdmFyIG1pZGRsZXMgPSBbXTtcbiAgICAgIHZhciBlbmRzID0gW107XG4gICAgICB2YXIgc3RhcnRpbmcgPSB0cnVlO1xuICAgICAgdmFyIGhhc0Jsb2NrcyA9IGZhbHNlO1xuXG4gICAgICBmb3IgKHZhciBbbm9kZV0gb2YgbWF0Y2hlcykge1xuICAgICAgICBpZiAoRWxlbWVudC5pc0VsZW1lbnQobm9kZSkgJiYgIWVkaXRvci5pc0lubGluZShub2RlKSkge1xuICAgICAgICAgIHN0YXJ0aW5nID0gZmFsc2U7XG4gICAgICAgICAgaGFzQmxvY2tzID0gdHJ1ZTtcbiAgICAgICAgICBtaWRkbGVzLnB1c2gobm9kZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoc3RhcnRpbmcpIHtcbiAgICAgICAgICBzdGFydHMucHVzaChub2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmRzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIFtpbmxpbmVNYXRjaF0gPSBFZGl0b3Iubm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaDogbiA9PiBUZXh0LmlzVGV4dChuKSB8fCBFZGl0b3IuaXNJbmxpbmUoZWRpdG9yLCBuKSxcbiAgICAgICAgbW9kZTogJ2hpZ2hlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICB2YXIgWywgaW5saW5lUGF0aF0gPSBpbmxpbmVNYXRjaDtcbiAgICAgIHZhciBpc0lubGluZVN0YXJ0ID0gRWRpdG9yLmlzU3RhcnQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgICB2YXIgaXNJbmxpbmVFbmQgPSBFZGl0b3IuaXNFbmQoZWRpdG9yLCBhdCwgaW5saW5lUGF0aCk7XG4gICAgICB2YXIgbWlkZGxlUmVmID0gRWRpdG9yLnBhdGhSZWYoZWRpdG9yLCBpc0Jsb2NrRW5kICYmICFlbmRzLmxlbmd0aCA/IFBhdGgubmV4dChibG9ja1BhdGgpIDogYmxvY2tQYXRoKTtcbiAgICAgIHZhciBlbmRSZWYgPSBFZGl0b3IucGF0aFJlZihlZGl0b3IsIGlzSW5saW5lRW5kID8gUGF0aC5uZXh0KGlubGluZVBhdGgpIDogaW5saW5lUGF0aCk7XG4gICAgICBUcmFuc2Zvcm1zLnNwbGl0Tm9kZXMoZWRpdG9yLCB7XG4gICAgICAgIGF0LFxuICAgICAgICBtYXRjaDogbiA9PiBoYXNCbG9ja3MgPyBFZGl0b3IuaXNCbG9jayhlZGl0b3IsIG4pIDogVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6IGhhc0Jsb2NrcyA/ICdsb3dlc3QnIDogJ2hpZ2hlc3QnLFxuICAgICAgICBhbHdheXM6IGhhc0Jsb2NrcyAmJiAoIWlzQmxvY2tTdGFydCB8fCBzdGFydHMubGVuZ3RoID4gMCkgJiYgKCFpc0Jsb2NrRW5kIHx8IGVuZHMubGVuZ3RoID4gMCksXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcbiAgICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wYXRoUmVmKGVkaXRvciwgIWlzSW5saW5lU3RhcnQgfHwgaXNJbmxpbmVTdGFydCAmJiBpc0lubGluZUVuZCA/IFBhdGgubmV4dChpbmxpbmVQYXRoKSA6IGlubGluZVBhdGgpO1xuICAgICAgVHJhbnNmb3Jtcy5pbnNlcnROb2RlcyhlZGl0b3IsIHN0YXJ0cywge1xuICAgICAgICBhdDogc3RhcnRSZWYuY3VycmVudCxcbiAgICAgICAgbWF0Y2g6IG4gPT4gVGV4dC5pc1RleHQobikgfHwgRWRpdG9yLmlzSW5saW5lKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdoaWdoZXN0JyxcbiAgICAgICAgdm9pZHNcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoaXNCbG9ja0VtcHR5ICYmICFzdGFydHMubGVuZ3RoICYmIG1pZGRsZXMubGVuZ3RoICYmICFlbmRzLmxlbmd0aCkge1xuICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICBhdDogYmxvY2tQYXRoLFxuICAgICAgICAgIHZvaWRzXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgbWlkZGxlcywge1xuICAgICAgICBhdDogbWlkZGxlUmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBuID0+IEVkaXRvci5pc0Jsb2NrKGVkaXRvciwgbiksXG4gICAgICAgIG1vZGU6ICdsb3dlc3QnLFxuICAgICAgICB2b2lkc1xuICAgICAgfSk7XG4gICAgICBUcmFuc2Zvcm1zLmluc2VydE5vZGVzKGVkaXRvciwgZW5kcywge1xuICAgICAgICBhdDogZW5kUmVmLmN1cnJlbnQsXG4gICAgICAgIG1hdGNoOiBuID0+IFRleHQuaXNUZXh0KG4pIHx8IEVkaXRvci5pc0lubGluZShlZGl0b3IsIG4pLFxuICAgICAgICBtb2RlOiAnaGlnaGVzdCcsXG4gICAgICAgIHZvaWRzXG4gICAgICB9KTtcblxuICAgICAgaWYgKCFvcHRpb25zLmF0KSB7XG4gICAgICAgIHZhciBwYXRoO1xuXG4gICAgICAgIGlmIChlbmRzLmxlbmd0aCA+IDAgJiYgZW5kUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhlbmRSZWYuY3VycmVudCk7XG4gICAgICAgIH0gZWxzZSBpZiAobWlkZGxlcy5sZW5ndGggPiAwICYmIG1pZGRsZVJlZi5jdXJyZW50KSB7XG4gICAgICAgICAgcGF0aCA9IFBhdGgucHJldmlvdXMobWlkZGxlUmVmLmN1cnJlbnQpO1xuICAgICAgICB9IGVsc2UgaWYgKHN0YXJ0UmVmLmN1cnJlbnQpIHtcbiAgICAgICAgICBwYXRoID0gUGF0aC5wcmV2aW91cyhzdGFydFJlZi5jdXJyZW50KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgdmFyIF9lbmQyID0gRWRpdG9yLmVuZChlZGl0b3IsIHBhdGgpO1xuXG4gICAgICAgICAgVHJhbnNmb3Jtcy5zZWxlY3QoZWRpdG9yLCBfZW5kMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgc3RhcnRSZWYudW5yZWYoKTtcbiAgICAgIG1pZGRsZVJlZi51bnJlZigpO1xuICAgICAgZW5kUmVmLnVucmVmKCk7XG4gICAgfSk7XG4gIH0sXG5cbiAgLyoqXHJcbiAgICogSW5zZXJ0IGEgc3RyaW5nIG9mIHRleHQgaW4gdGhlIEVkaXRvci5cclxuICAgKi9cbiAgaW5zZXJ0VGV4dChlZGl0b3IsIHRleHQpIHtcbiAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDoge307XG4gICAgRWRpdG9yLndpdGhvdXROb3JtYWxpemluZyhlZGl0b3IsICgpID0+IHtcbiAgICAgIHZhciB7XG4gICAgICAgIHZvaWRzID0gZmFsc2VcbiAgICAgIH0gPSBvcHRpb25zO1xuICAgICAgdmFyIHtcbiAgICAgICAgYXQgPSBlZGl0b3Iuc2VsZWN0aW9uXG4gICAgICB9ID0gb3B0aW9ucztcblxuICAgICAgaWYgKCFhdCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmIChQYXRoLmlzUGF0aChhdCkpIHtcbiAgICAgICAgYXQgPSBFZGl0b3IucmFuZ2UoZWRpdG9yLCBhdCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChSYW5nZS5pc1JhbmdlKGF0KSkge1xuICAgICAgICBpZiAoUmFuZ2UuaXNDb2xsYXBzZWQoYXQpKSB7XG4gICAgICAgICAgYXQgPSBhdC5hbmNob3I7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGVuZCA9IFJhbmdlLmVuZChhdCk7XG5cbiAgICAgICAgICBpZiAoIXZvaWRzICYmIEVkaXRvci52b2lkKGVkaXRvciwge1xuICAgICAgICAgICAgYXQ6IGVuZFxuICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIHN0YXJ0ID0gUmFuZ2Uuc3RhcnQoYXQpO1xuICAgICAgICAgIHZhciBzdGFydFJlZiA9IEVkaXRvci5wb2ludFJlZihlZGl0b3IsIHN0YXJ0KTtcbiAgICAgICAgICB2YXIgZW5kUmVmID0gRWRpdG9yLnBvaW50UmVmKGVkaXRvciwgZW5kKTtcbiAgICAgICAgICBUcmFuc2Zvcm1zLmRlbGV0ZShlZGl0b3IsIHtcbiAgICAgICAgICAgIGF0LFxuICAgICAgICAgICAgdm9pZHNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB2YXIgc3RhcnRQb2ludCA9IHN0YXJ0UmVmLnVucmVmKCk7XG4gICAgICAgICAgdmFyIGVuZFBvaW50ID0gZW5kUmVmLnVucmVmKCk7XG4gICAgICAgICAgYXQgPSBzdGFydFBvaW50IHx8IGVuZFBvaW50O1xuICAgICAgICAgIFRyYW5zZm9ybXMuc2V0U2VsZWN0aW9uKGVkaXRvciwge1xuICAgICAgICAgICAgYW5jaG9yOiBhdCxcbiAgICAgICAgICAgIGZvY3VzOiBhdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICghdm9pZHMgJiYgRWRpdG9yLnZvaWQoZWRpdG9yLCB7XG4gICAgICAgIGF0XG4gICAgICB9KSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHZhciB7XG4gICAgICAgIHBhdGgsXG4gICAgICAgIG9mZnNldFxuICAgICAgfSA9IGF0O1xuICAgICAgaWYgKHRleHQubGVuZ3RoID4gMCkgZWRpdG9yLmFwcGx5KHtcbiAgICAgICAgdHlwZTogJ2luc2VydF90ZXh0JyxcbiAgICAgICAgcGF0aCxcbiAgICAgICAgb2Zmc2V0LFxuICAgICAgICB0ZXh0XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG59O1xuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHsgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmplY3QpOyBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykgeyB2YXIgc3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMob2JqZWN0KTsgaWYgKGVudW1lcmFibGVPbmx5KSB7IHN5bWJvbHMgPSBzeW1ib2xzLmZpbHRlcihmdW5jdGlvbiAoc3ltKSB7IHJldHVybiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iamVjdCwgc3ltKS5lbnVtZXJhYmxlOyB9KTsgfSBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7IH0gcmV0dXJuIGtleXM7IH1cblxuZnVuY3Rpb24gX29iamVjdFNwcmVhZCh0YXJnZXQpIHsgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHsgdmFyIHNvdXJjZSA9IGFyZ3VtZW50c1tpXSAhPSBudWxsID8gYXJndW1lbnRzW2ldIDoge307IGlmIChpICUgMikgeyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCB0cnVlKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHsgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7IH0pOyB9IGVsc2UgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSk7IH0gZWxzZSB7IG93bktleXMoT2JqZWN0KHNvdXJjZSkpLmZvckVhY2goZnVuY3Rpb24gKGtleSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Ioc291cmNlLCBrZXkpKTsgfSk7IH0gfSByZXR1cm4gdGFyZ2V0OyB9XG52YXIgVHJhbnNmb3JtcyA9IF9vYmplY3RTcHJlYWQoX29iamVjdFNwcmVhZChfb2JqZWN0U3ByZWFkKF9vYmplY3RTcHJlYWQoe30sIEdlbmVyYWxUcmFuc2Zvcm1zKSwgTm9kZVRyYW5zZm9ybXMpLCBTZWxlY3Rpb25UcmFuc2Zvcm1zKSwgVGV4dFRyYW5zZm9ybXMpO1xuXG5leHBvcnQgeyBFZGl0b3IsIEVsZW1lbnQsIExvY2F0aW9uLCBOb2RlLCBPcGVyYXRpb24sIFBhdGgsIFBhdGhSZWYsIFBvaW50LCBQb2ludFJlZiwgUmFuZ2UsIFJhbmdlUmVmLCBTY3J1YmJlciwgU3BhbiwgVGV4dCwgVHJhbnNmb3JtcywgY3JlYXRlRWRpdG9yIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5lcy5qcy5tYXBcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/slate@0.82.0/node_modules/slate/dist/index.es.js\n");

/***/ })

};
;